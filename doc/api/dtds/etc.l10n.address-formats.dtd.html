<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>address-formats.dtd - sierra-php v1.1.3</title>
<script type="text/javascript">
<!--
var _qsAbortNext = false;
var _tipsIdx = 0;
var _tipIds;

function clearQsTips() {
  document.getElementById('quicksearch_tips').innerHTML = '';
}
function hideQsTips() {
  setTimeout("document.getElementById('quicksearch_tips').style.display = 'none'", 100);
}
function showQsTips() {
  document.getElementById('quicksearch_tips').style.display = '';
}
function qsTipsVisible() {
  return document.getElementById('quicksearch_tips').style.display != 'none';
}
function updateQsTips(evt) {
  if (qsTipsVisible() && evt && (evt.keyCode == 40 || evt.keyCode == 38 || evt.keyCode == 13)) {
    switch(evt.keyCode) {
      // up
      case 38:
      // down
      case 40:
        if (_tipsIdx >= 0) document.getElementById(_tipIds[_tipsIdx]).style.backgroundColor = '';
        evt.keyCode == 38 ? _tipsIdx-- : _tipsIdx++;
        if (_tipsIdx > _tipIds.length) _tipsIdx = 0;
        if (_tipsIdx < 0) _tipsIdx = _tipIds.length - 1;
        if (_tipsIdx >= 0) document.getElementById(_tipIds[_tipsIdx]).style.backgroundColor = '#ddd';
        break;
      // enter
      case 13:
        if (_tipsIdx >= 0 && _tipIds[_tipsIdx]) {
          document.location.replace('#' + _tipIds[_tipsIdx].substr(3));
        }
        break;
    }
    return;
  }
  
  _tipsIdx = -1;
  _tipIds = [];
  var str = document.getElementById('quicksearch').value.toLowerCase();
  var matches = {}
  var match = false;
  
  if (str) {
  // check constants
  if ("sra_workflow_task_due_date_rel_cur".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_WORKFLOW_TASK_DUE_DATE_REL_CUR'] = "SRA_WORKFLOW_TASK_DUE_DATE_REL_CUR";
  }
  if ("sra_workflow_task_due_date_rel_wf_start".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_WORKFLOW_TASK_DUE_DATE_REL_WF_START'] = "SRA_WORKFLOW_TASK_DUE_DATE_REL_WF_START";
  }
  if ("sra_workflow_task_due_date_rel_wf_due_date".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_WORKFLOW_TASK_DUE_DATE_REL_WF_DUE_DATE'] = "SRA_WORKFLOW_TASK_DUE_DATE_REL_WF_DUE_DATE";
  }
  if ("sra_workflow_task_due_date_rel_step_due_date".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_WORKFLOW_TASK_DUE_DATE_REL_STEP_DUE_DATE'] = "SRA_WORKFLOW_TASK_DUE_DATE_REL_STEP_DUE_DATE";
  }



  // check classes
  if ("sra_workflow".indexOf(str) != -1) {
    match = true;
    matches['qs_class_SRA_Workflow'] = "SRA_Workflow";
  }
  if ("sra_workflowconstraint".indexOf(str) != -1) {
    match = true;
    matches['qs_class_SRA_WorkflowConstraint'] = "SRA_WorkflowConstraint";
  }
  if ("sra_workflowconstraintgroup".indexOf(str) != -1) {
    match = true;
    matches['qs_class_SRA_WorkflowConstraintGroup'] = "SRA_WorkflowConstraintGroup";
  }
  if ("sra_workflowdecision".indexOf(str) != -1) {
    match = true;
    matches['qs_class_SRA_WorkflowDecision'] = "SRA_WorkflowDecision";
  }
  if ("sra_workflowmanager".indexOf(str) != -1) {
    match = true;
    matches['qs_class_SRA_WorkflowManager'] = "SRA_WorkflowManager";
  }
  if ("sra_workflowstep".indexOf(str) != -1) {
    match = true;
    matches['qs_class_SRA_WorkflowStep'] = "SRA_WorkflowStep";
  }
  if ("sra_workflowtask".indexOf(str) != -1) {
    match = true;
    matches['qs_class_SRA_WorkflowTask'] = "SRA_WorkflowTask";
  }


  // check dtds
  if ("workflow.dtd".indexOf(str) != -1) {
    match = true;
    matches['qs_dtd_workflow.dtd'] = "workflow.dtd";
  }

  // check packages
  if ("etc".indexOf(str) != -1) {
    match = true;
    matches['qs_package_etc'] = "etc";
  }
  if ("etc.l10n".indexOf(str) != -1) {
    match = true;
    matches['qs_package_etc.l10n'] = "etc.l10n";
  }
  if ("auth".indexOf(str) != -1) {
    match = true;
    matches['qs_package_auth'] = "auth";
  }
  if ("core".indexOf(str) != -1) {
    match = true;
    matches['qs_package_core'] = "core";
  }
  if ("model".indexOf(str) != -1) {
    match = true;
    matches['qs_package_model'] = "model";
  }
  if ("sql".indexOf(str) != -1) {
    match = true;
    matches['qs_package_sql'] = "sql";
  }
  if ("test".indexOf(str) != -1) {
    match = true;
    matches['qs_package_test'] = "test";
  }
  if ("util".indexOf(str) != -1) {
    match = true;
    matches['qs_package_util'] = "util";
  }
  if ("util.installer".indexOf(str) != -1) {
    match = true;
    matches['qs_package_util.installer'] = "util.installer";
  }
  if ("util.l10n".indexOf(str) != -1) {
    match = true;
    matches['qs_package_util.l10n'] = "util.l10n";
  }
  if ("workflow".indexOf(str) != -1) {
    match = true;
    matches['qs_package_workflow'] = "workflow";
  }

  // elements
  if ("address-formats".indexOf(str) != -1) {
    match = true;
    matches['qs_element_address-formats'] = "address-formats";
  }
  if ("address-format".indexOf(str) != -1) {
    match = true;
    matches['qs_element_address-format'] = "address-format";
  }
  // address-format element attributes
  if ("address-format".indexOf(str) != -1 || "address-format::key".indexOf(str) != -1 || "key".indexOf(str) != -1) {
    match = true;
    matches['qs_element_address-format_key'] = "address-format::key";
  }
  if ("field".indexOf(str) != -1) {
    match = true;
    matches['qs_element_field'] = "field";
  }
  // field element attributes
  if ("field".indexOf(str) != -1 || "field::key".indexOf(str) != -1 || "key".indexOf(str) != -1) {
    match = true;
    matches['qs_element_field_key'] = "field::key";
  }
  // field element attributes
  if ("field".indexOf(str) != -1 || "field::bundle".indexOf(str) != -1 || "bundle".indexOf(str) != -1) {
    match = true;
    matches['qs_element_field_bundle'] = "field::bundle";
  }
  // field element attributes
  if ("field".indexOf(str) != -1 || "field::col".indexOf(str) != -1 || "col".indexOf(str) != -1) {
    match = true;
    matches['qs_element_field_col'] = "field::col";
  }
  // field element attributes
  if ("field".indexOf(str) != -1 || "field::regex".indexOf(str) != -1 || "regex".indexOf(str) != -1) {
    match = true;
    matches['qs_element_field_regex'] = "field::regex";
  }
  // field element attributes
  if ("field".indexOf(str) != -1 || "field::required".indexOf(str) != -1 || "required".indexOf(str) != -1) {
    match = true;
    matches['qs_element_field_required'] = "field::required";
  }
  // field element attributes
  if ("field".indexOf(str) != -1 || "field::row".indexOf(str) != -1 || "row".indexOf(str) != -1) {
    match = true;
    matches['qs_element_field_row'] = "field::row";
  }
  // field element attributes
  if ("field".indexOf(str) != -1 || "field::show-key".indexOf(str) != -1 || "show-key".indexOf(str) != -1) {
    match = true;
    matches['qs_element_field_show-key'] = "field::show-key";
  }

  }
  
  if (match) {
    var html = '';
    for(var i in matches) {
      _tipIds.push(i);
      html += '<div id="' + i + '" style="background-color: white; cursor: pointer;" onclick="document.location.replace(\'#\' + this.id.substr(3))">' + matches[i] + '</div>\n';
    }
    document.getElementById('quicksearch_tips').innerHTML = html;
    showQsTips();
  }
  else {
    hideQsTips();
  }
}
-->
</script></head>
<body id="dtd" onload="document.getElementById('quicksearch').onkeyup = updateQsTips; document.getElementById('quicksearch').focus()">
  <h1 id="top">address-formats.dtd</h1>
<p>&nbsp;&nbsp;&nbsp;&nbsp;package <a href="../packages/etc.l10n.html" target="contentFrame">etc.l10n</a></p>  <hr />
  
  <form onsubmit="return false">
  
  <div style="float:right">
    <b><label for="quicksearch">Quick Search:</label></b><br />
    <input id="quicksearch" type="text" onfocus="clearQsTips()" onblur="hideQsTips()" autocomplete="off" onclick="this.select()" /><br />
    <div id="quicksearch_tips" style="border: 1px solid #333; position:absolute; display:none"></div>
  </div>
  
  <h2>DTD Information</h2>
  <ul>
    <li><a href="#comments">DTD Comments</a></li>
    <li><a href="#elements">Elements</a></li>
    <li><a href="#element_details">Element Details</a></li>
  </ul>
  
  <h2 id="comments">Comment</h2>
  <pre>XML DTD for SIERRA address formats configuration

This xml structure defines how addresses should be formatted for different 
countries

To support validation of your configuration file, include the following
DOCTYPE element at the beginning (after the &quot;xml&quot; declaration):

&lt;!DOCTYPE address-formats PUBLIC &quot;-//SIERRA//DTD ADDRESS FORMATS//EN&quot; 
  &quot;http://sierra-php.googlecode.com/svn/trunk/etc/l10n/address-formats.dtd&quot;&gt;
</pre>
  

  <h2 id="elements">Elements</h2>
  <table border="1" width="100%">
    <tr>
      <th><pre><a href="#element_address-formats">address-formats</a><strong> [root element]</strong></pre></th>
      <td><pre>The &quot;address-formats&quot; element is the root element. It contains one or more 
address-format sub-elements

</pre></td>
    </tr>
    <tr>
      <th><pre><a href="#element_address-format">address-format</a></pre></th>
      <td><pre>The &quot;address-format&quot; element is used to define a single address format. each 
such format defines the tabular layout, selection options and field validation 
for addresses associated with the countries specified</pre></td>
    </tr>
    <tr>
      <th><pre><a href="#element_field">field</a></pre></th>
      <td><pre>The &quot;field&quot; element is used to define a single address format field including 
its tabular position, selection options and validation constraints</pre></td>
    </tr>
  </table>
  
  <h2 id="element_details">Element Details</h2>
  <a href="#top" style="float:right">Top</a>
  <a href="#top" style="float:right">Top</a>
  <h3 id="element_address-formats">address-formats [root element]</h3>
  <pre>The &quot;address-formats&quot; element is the root element. It contains one or more 
address-format sub-elements

</pre>

  <h4>Sub Elements</h4>
  <table border="1">
    <tr>
      <th>Sub Element</th>
      <th>Required?</th>
      <th>More than one?</th>
    </tr>
    <tr>
      <td><pre><a href="#element_address-format">address-format</a></pre></td>
      <td>Yes</td>
      <td>Yes</td>
    </tr>
  </table>

  <h4>Attributes</h4>
  <p>This element does not have any attributes</p>

 <hr />  <a href="#top" style="float:right">Top</a>
  <h3 id="element_address-format">address-format</h3>
  <pre>The &quot;address-format&quot; element is used to define a single address format. each 
such format defines the tabular layout, selection options and field validation 
for addresses associated with the countries specified</pre>
  <h4>Used In</h4>
  <ul>
    <li><a href="#element_address-formats">address-formats</a></li>
  </ul>

  <h4>Sub Elements</h4>
  <table border="1">
    <tr>
      <th>Sub Element</th>
      <th>Required?</th>
      <th>More than one?</th>
    </tr>
    <tr>
      <td><pre><a href="#element_field">field</a></pre></td>
      <td>Yes</td>
      <td>Yes</td>
    </tr>
  </table>

  <h4>Attributes</h4>
  <table border="1">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default Value</th>
      <th>Required?</th>
      <th>Comment</th>
    </tr>
    <tr id="element_address-format_key">
      <th><pre>key</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>space separated list of ISO 3166 country identifiers where this
     address format is applicable. these identifiers should not be 
     repeated in other address-format entries. the * identifier will 
     match any country where the identifier is not otherwise found in 
     the xml document

</pre></td>
    </tr>
  </table>

 <hr />  <a href="#top" style="float:right">Top</a>
  <h3 id="element_field">field</h3>
  <pre>The &quot;field&quot; element is used to define a single address format field including 
its tabular position, selection options and validation constraints</pre>
  <h4>Used In</h4>
  <ul>
    <li><a href="#element_address-format">address-format</a></li>
  </ul>

  <h4>Sub Elements</h4>
  <p>This element does not have any sub-elements</p>

  <h4>Attributes</h4>
  <table border="1">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default Value</th>
      <th>Required?</th>
      <th>Comment</th>
    </tr>
    <tr id="element_field_key">
      <th><pre>key</pre></th>
      <td><pre>(city | cityRegion | country | county | countyCity | districtRegion | districtTown | federalSubject | furtherDivisions | locality | pinCode | prefecture | province | postalCode | postalDistrict | region | state | street | suburb | village | zip)</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>the field identifier
</pre></td>
    </tr>
    <tr id="element_field_bundle">
      <th><pre>bundle</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>resource bundle containing the value/name options for this field.
this value may contain the keyword &quot;{$country}&quot; which will be 
replaced dynamically with the country code (lower case). if this 
field is for the &#039;country&#039;, it will automatically be assigned to 
the iso3166 bundle
</pre></td>
    </tr>
    <tr id="element_field_col">
      <th><pre>col</pre></th>
      <td><pre>(1 | 2 | 3 | 4 | 5)</pre></td>
      <td><pre>"1"</pre></td>
      <td>No</td>
      <td><pre>the column position within &quot;row&quot; for this field. the row/col value
for each field within an address-format should be unique, 
otherwise the first stated field will take priority over any other 
duplicate positioned fields
</pre></td>
    </tr>
    <tr id="element_field_regex">
      <th><pre>regex</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>a regular expression validation constraint for this field
</pre></td>
    </tr>
    <tr id="element_field_required">
      <th><pre>required</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>whether or not this field is required. the default is false
</pre></td>
    </tr>
    <tr id="element_field_row">
      <th><pre>row</pre></th>
      <td><pre>(1 | 2 | 3 | 4 | 5)</pre></td>
      <td><pre>"1"</pre></td>
      <td>No</td>
      <td><pre>the row position for this field. the row/col value for each field
within an address-format should be unique, otherwise the first 
stated field will take priority over any other duplicate 
positioned fields
</pre></td>
    </tr>
    <tr id="element_field_show-key">
      <th><pre>show-key</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>if &#039;bundle&#039; is specified, this attribute determines whether the
key or the actual value will be shown in display mode

</pre></td>
    </tr>
  </table>

  
  </form>
</body>
</html>