<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>entity-model-ws.dtd - sierra-php v1.1.3</title>
<script type="text/javascript">
<!--
var _qsAbortNext = false;
var _tipsIdx = 0;
var _tipIds;

function clearQsTips() {
  document.getElementById('quicksearch_tips').innerHTML = '';
}
function hideQsTips() {
  setTimeout("document.getElementById('quicksearch_tips').style.display = 'none'", 100);
}
function showQsTips() {
  document.getElementById('quicksearch_tips').style.display = '';
}
function qsTipsVisible() {
  return document.getElementById('quicksearch_tips').style.display != 'none';
}
function updateQsTips(evt) {
  if (qsTipsVisible() && evt && (evt.keyCode == 40 || evt.keyCode == 38 || evt.keyCode == 13)) {
    switch(evt.keyCode) {
      // up
      case 38:
      // down
      case 40:
        if (_tipsIdx >= 0) document.getElementById(_tipIds[_tipsIdx]).style.backgroundColor = '';
        evt.keyCode == 38 ? _tipsIdx-- : _tipsIdx++;
        if (_tipsIdx > _tipIds.length) _tipsIdx = 0;
        if (_tipsIdx < 0) _tipsIdx = _tipIds.length - 1;
        if (_tipsIdx >= 0) document.getElementById(_tipIds[_tipsIdx]).style.backgroundColor = '#ddd';
        break;
      // enter
      case 13:
        if (_tipsIdx >= 0 && _tipIds[_tipsIdx]) {
          document.location.replace('#' + _tipIds[_tipsIdx].substr(3));
        }
        break;
    }
    return;
  }
  
  _tipsIdx = -1;
  _tipIds = [];
  var str = document.getElementById('quicksearch').value.toLowerCase();
  var matches = {}
  var match = false;
  
  if (str) {
  // check constants
  if ("sra_workflow_task_due_date_rel_cur".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_WORKFLOW_TASK_DUE_DATE_REL_CUR'] = "SRA_WORKFLOW_TASK_DUE_DATE_REL_CUR";
  }
  if ("sra_workflow_task_due_date_rel_wf_start".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_WORKFLOW_TASK_DUE_DATE_REL_WF_START'] = "SRA_WORKFLOW_TASK_DUE_DATE_REL_WF_START";
  }
  if ("sra_workflow_task_due_date_rel_wf_due_date".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_WORKFLOW_TASK_DUE_DATE_REL_WF_DUE_DATE'] = "SRA_WORKFLOW_TASK_DUE_DATE_REL_WF_DUE_DATE";
  }
  if ("sra_workflow_task_due_date_rel_step_due_date".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_WORKFLOW_TASK_DUE_DATE_REL_STEP_DUE_DATE'] = "SRA_WORKFLOW_TASK_DUE_DATE_REL_STEP_DUE_DATE";
  }



  // check classes
  if ("sra_workflow".indexOf(str) != -1) {
    match = true;
    matches['qs_class_SRA_Workflow'] = "SRA_Workflow";
  }
  if ("sra_workflowconstraint".indexOf(str) != -1) {
    match = true;
    matches['qs_class_SRA_WorkflowConstraint'] = "SRA_WorkflowConstraint";
  }
  if ("sra_workflowconstraintgroup".indexOf(str) != -1) {
    match = true;
    matches['qs_class_SRA_WorkflowConstraintGroup'] = "SRA_WorkflowConstraintGroup";
  }
  if ("sra_workflowdecision".indexOf(str) != -1) {
    match = true;
    matches['qs_class_SRA_WorkflowDecision'] = "SRA_WorkflowDecision";
  }
  if ("sra_workflowmanager".indexOf(str) != -1) {
    match = true;
    matches['qs_class_SRA_WorkflowManager'] = "SRA_WorkflowManager";
  }
  if ("sra_workflowstep".indexOf(str) != -1) {
    match = true;
    matches['qs_class_SRA_WorkflowStep'] = "SRA_WorkflowStep";
  }
  if ("sra_workflowtask".indexOf(str) != -1) {
    match = true;
    matches['qs_class_SRA_WorkflowTask'] = "SRA_WorkflowTask";
  }


  // check dtds
  if ("workflow.dtd".indexOf(str) != -1) {
    match = true;
    matches['qs_dtd_workflow.dtd'] = "workflow.dtd";
  }

  // check packages
  if ("etc".indexOf(str) != -1) {
    match = true;
    matches['qs_package_etc'] = "etc";
  }
  if ("etc.l10n".indexOf(str) != -1) {
    match = true;
    matches['qs_package_etc.l10n'] = "etc.l10n";
  }
  if ("auth".indexOf(str) != -1) {
    match = true;
    matches['qs_package_auth'] = "auth";
  }
  if ("core".indexOf(str) != -1) {
    match = true;
    matches['qs_package_core'] = "core";
  }
  if ("model".indexOf(str) != -1) {
    match = true;
    matches['qs_package_model'] = "model";
  }
  if ("sql".indexOf(str) != -1) {
    match = true;
    matches['qs_package_sql'] = "sql";
  }
  if ("test".indexOf(str) != -1) {
    match = true;
    matches['qs_package_test'] = "test";
  }
  if ("util".indexOf(str) != -1) {
    match = true;
    matches['qs_package_util'] = "util";
  }
  if ("util.installer".indexOf(str) != -1) {
    match = true;
    matches['qs_package_util.installer'] = "util.installer";
  }
  if ("util.l10n".indexOf(str) != -1) {
    match = true;
    matches['qs_package_util.l10n'] = "util.l10n";
  }
  if ("workflow".indexOf(str) != -1) {
    match = true;
    matches['qs_package_workflow'] = "workflow";
  }

  // elements
  if ("entity-model".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity-model'] = "entity-model";
  }
  // entity-model element attributes
  if ("entity-model".indexOf(str) != -1 || "entity-model::abstract".indexOf(str) != -1 || "abstract".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity-model_abstract'] = "entity-model::abstract";
  }
  // entity-model element attributes
  if ("entity-model".indexOf(str) != -1 || "entity-model::auto-pk".indexOf(str) != -1 || "auto-pk".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity-model_auto-pk'] = "entity-model::auto-pk";
  }
  // entity-model element attributes
  if ("entity-model".indexOf(str) != -1 || "entity-model::dao-suffix".indexOf(str) != -1 || "dao-suffix".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity-model_dao-suffix'] = "entity-model::dao-suffix";
  }
  // entity-model element attributes
  if ("entity-model".indexOf(str) != -1 || "entity-model::db".indexOf(str) != -1 || "db".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity-model_db'] = "entity-model::db";
  }
  // entity-model element attributes
  if ("entity-model".indexOf(str) != -1 || "entity-model::ddl-camel-case".indexOf(str) != -1 || "ddl-camel-case".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity-model_ddl-camel-case'] = "entity-model::ddl-camel-case";
  }
  // entity-model element attributes
  if ("entity-model".indexOf(str) != -1 || "entity-model::ddl-path".indexOf(str) != -1 || "ddl-path".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity-model_ddl-path'] = "entity-model::ddl-path";
  }
  // entity-model element attributes
  if ("entity-model".indexOf(str) != -1 || "entity-model::ddl-upper-case".indexOf(str) != -1 || "ddl-upper-case".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity-model_ddl-upper-case'] = "entity-model::ddl-upper-case";
  }
  // entity-model element attributes
  if ("entity-model".indexOf(str) != -1 || "entity-model::dtd-camel-case".indexOf(str) != -1 || "dtd-camel-case".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity-model_dtd-camel-case'] = "entity-model::dtd-camel-case";
  }
  // entity-model element attributes
  if ("entity-model".indexOf(str) != -1 || "entity-model::dtd-path".indexOf(str) != -1 || "dtd-path".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity-model_dtd-path'] = "entity-model::dtd-path";
  }
  // entity-model element attributes
  if ("entity-model".indexOf(str) != -1 || "entity-model::dtd-uri".indexOf(str) != -1 || "dtd-uri".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity-model_dtd-uri'] = "entity-model::dtd-uri";
  }
  // entity-model element attributes
  if ("entity-model".indexOf(str) != -1 || "entity-model::file-dir".indexOf(str) != -1 || "file-dir".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity-model_file-dir'] = "entity-model::file-dir";
  }
  // entity-model element attributes
  if ("entity-model".indexOf(str) != -1 || "entity-model::file-dir-uri".indexOf(str) != -1 || "file-dir-uri".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity-model_file-dir-uri'] = "entity-model::file-dir-uri";
  }
  // entity-model element attributes
  if ("entity-model".indexOf(str) != -1 || "entity-model::file-handling".indexOf(str) != -1 || "file-handling".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity-model_file-handling'] = "entity-model::file-handling";
  }
  // entity-model element attributes
  if ("entity-model".indexOf(str) != -1 || "entity-model::file-icon-dir".indexOf(str) != -1 || "file-icon-dir".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity-model_file-icon-dir'] = "entity-model::file-icon-dir";
  }
  // entity-model element attributes
  if ("entity-model".indexOf(str) != -1 || "entity-model::file-script-rewrite".indexOf(str) != -1 || "file-script-rewrite".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity-model_file-script-rewrite'] = "entity-model::file-script-rewrite";
  }
  // entity-model element attributes
  if ("entity-model".indexOf(str) != -1 || "entity-model::file-script-uri".indexOf(str) != -1 || "file-script-uri".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity-model_file-script-uri'] = "entity-model::file-script-uri";
  }
  // entity-model element attributes
  if ("entity-model".indexOf(str) != -1 || "entity-model::generate-path".indexOf(str) != -1 || "generate-path".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity-model_generate-path'] = "entity-model::generate-path";
  }
  // entity-model element attributes
  if ("entity-model".indexOf(str) != -1 || "entity-model::header-tpl".indexOf(str) != -1 || "header-tpl".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity-model_header-tpl'] = "entity-model::header-tpl";
  }
  // entity-model element attributes
  if ("entity-model".indexOf(str) != -1 || "entity-model::ignore-bad-import".indexOf(str) != -1 || "ignore-bad-import".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity-model_ignore-bad-import'] = "entity-model::ignore-bad-import";
  }
  // entity-model element attributes
  if ("entity-model".indexOf(str) != -1 || "entity-model::import".indexOf(str) != -1 || "import".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity-model_import'] = "entity-model::import";
  }
  // entity-model element attributes
  if ("entity-model".indexOf(str) != -1 || "entity-model::mysql-table-type".indexOf(str) != -1 || "mysql-table-type".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity-model_mysql-table-type'] = "entity-model::mysql-table-type";
  }
  // entity-model element attributes
  if ("entity-model".indexOf(str) != -1 || "entity-model::ref-integrity".indexOf(str) != -1 || "ref-integrity".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity-model_ref-integrity'] = "entity-model::ref-integrity";
  }
  // entity-model element attributes
  if ("entity-model".indexOf(str) != -1 || "entity-model::nested-queries-ok".indexOf(str) != -1 || "nested-queries-ok".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity-model_nested-queries-ok'] = "entity-model::nested-queries-ok";
  }
  // entity-model element attributes
  if ("entity-model".indexOf(str) != -1 || "entity-model::resources".indexOf(str) != -1 || "resources".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity-model_resources'] = "entity-model::resources";
  }
  // entity-model element attributes
  if ("entity-model".indexOf(str) != -1 || "entity-model::sync-schema".indexOf(str) != -1 || "sync-schema".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity-model_sync-schema'] = "entity-model::sync-schema";
  }
  // entity-model element attributes
  if ("entity-model".indexOf(str) != -1 || "entity-model::sys-err-resource".indexOf(str) != -1 || "sys-err-resource".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity-model_sys-err-resource'] = "entity-model::sys-err-resource";
  }
  // entity-model element attributes
  if ("entity-model".indexOf(str) != -1 || "entity-model::vo-suffix".indexOf(str) != -1 || "vo-suffix".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity-model_vo-suffix'] = "entity-model::vo-suffix";
  }
  // entity-model element attributes
  if ("entity-model".indexOf(str) != -1 || "entity-model::ws-db".indexOf(str) != -1 || "ws-db".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity-model_ws-db'] = "entity-model::ws-db";
  }
  // entity-model element attributes
  if ("entity-model".indexOf(str) != -1 || "entity-model::ws-api-css-uri".indexOf(str) != -1 || "ws-api-css-uri".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity-model_ws-api-css-uri'] = "entity-model::ws-api-css-uri";
  }
  // entity-model element attributes
  if ("entity-model".indexOf(str) != -1 || "entity-model::ws-gateway-rewrite".indexOf(str) != -1 || "ws-gateway-rewrite".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity-model_ws-gateway-rewrite'] = "entity-model::ws-gateway-rewrite";
  }
  // entity-model element attributes
  if ("entity-model".indexOf(str) != -1 || "entity-model::ws-gateway-uri".indexOf(str) != -1 || "ws-gateway-uri".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity-model_ws-gateway-uri'] = "entity-model::ws-gateway-uri";
  }
  if ("entity".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity'] = "entity";
  }
  // entity element attributes
  if ("entity".indexOf(str) != -1 || "entity::key".indexOf(str) != -1 || "key".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity_key'] = "entity::key";
  }
  // entity element attributes
  if ("entity".indexOf(str) != -1 || "entity::abstract".indexOf(str) != -1 || "abstract".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity_abstract'] = "entity::abstract";
  }
  // entity element attributes
  if ("entity".indexOf(str) != -1 || "entity::api-resource".indexOf(str) != -1 || "api-resource".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity_api-resource'] = "entity::api-resource";
  }
  // entity element attributes
  if ("entity".indexOf(str) != -1 || "entity::column-postfix".indexOf(str) != -1 || "column-postfix".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity_column-postfix'] = "entity::column-postfix";
  }
  // entity element attributes
  if ("entity".indexOf(str) != -1 || "entity::column-prefix".indexOf(str) != -1 || "column-prefix".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity_column-prefix'] = "entity::column-prefix";
  }
  // entity element attributes
  if ("entity".indexOf(str) != -1 || "entity::constraint".indexOf(str) != -1 || "constraint".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity_constraint'] = "entity::constraint";
  }
  // entity element attributes
  if ("entity".indexOf(str) != -1 || "entity::dao".indexOf(str) != -1 || "dao".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity_dao'] = "entity::dao";
  }
  // entity element attributes
  if ("entity".indexOf(str) != -1 || "entity::dao-extends".indexOf(str) != -1 || "dao-extends".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity_dao-extends'] = "entity::dao-extends";
  }
  // entity element attributes
  if ("entity".indexOf(str) != -1 || "entity::extends".indexOf(str) != -1 || "extends".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity_extends'] = "entity::extends";
  }
  // entity element attributes
  if ("entity".indexOf(str) != -1 || "entity::file-dir".indexOf(str) != -1 || "file-dir".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity_file-dir'] = "entity::file-dir";
  }
  // entity element attributes
  if ("entity".indexOf(str) != -1 || "entity::file-dir-uri".indexOf(str) != -1 || "file-dir-uri".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity_file-dir-uri'] = "entity::file-dir-uri";
  }
  // entity element attributes
  if ("entity".indexOf(str) != -1 || "entity::file-handling".indexOf(str) != -1 || "file-handling".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity_file-handling'] = "entity::file-handling";
  }
  // entity element attributes
  if ("entity".indexOf(str) != -1 || "entity::file-icon-dir".indexOf(str) != -1 || "file-icon-dir".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity_file-icon-dir'] = "entity::file-icon-dir";
  }
  // entity element attributes
  if ("entity".indexOf(str) != -1 || "entity::file-script-rewrite".indexOf(str) != -1 || "file-script-rewrite".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity_file-script-rewrite'] = "entity::file-script-rewrite";
  }
  // entity element attributes
  if ("entity".indexOf(str) != -1 || "entity::file-script-uri".indexOf(str) != -1 || "file-script-uri".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity_file-script-uri'] = "entity::file-script-uri";
  }
  // entity element attributes
  if ("entity".indexOf(str) != -1 || "entity::ignore-bad-import".indexOf(str) != -1 || "ignore-bad-import".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity_ignore-bad-import'] = "entity::ignore-bad-import";
  }
  // entity element attributes
  if ("entity".indexOf(str) != -1 || "entity::is-global".indexOf(str) != -1 || "is-global".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity_is-global'] = "entity::is-global";
  }
  // entity element attributes
  if ("entity".indexOf(str) != -1 || "entity::match-user-id".indexOf(str) != -1 || "match-user-id".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity_match-user-id'] = "entity::match-user-id";
  }
  // entity element attributes
  if ("entity".indexOf(str) != -1 || "entity::null-db-empty-str".indexOf(str) != -1 || "null-db-empty-str".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity_null-db-empty-str'] = "entity::null-db-empty-str";
  }
  // entity element attributes
  if ("entity".indexOf(str) != -1 || "entity::on-create-import".indexOf(str) != -1 || "on-create-import".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity_on-create-import'] = "entity::on-create-import";
  }
  // entity element attributes
  if ("entity".indexOf(str) != -1 || "entity::on-delete-update".indexOf(str) != -1 || "on-delete-update".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity_on-delete-update'] = "entity::on-delete-update";
  }
  // entity element attributes
  if ("entity".indexOf(str) != -1 || "entity::order-by".indexOf(str) != -1 || "order-by".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity_order-by'] = "entity::order-by";
  }
  // entity element attributes
  if ("entity".indexOf(str) != -1 || "entity::primary-key".indexOf(str) != -1 || "primary-key".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity_primary-key'] = "entity::primary-key";
  }
  // entity element attributes
  if ("entity".indexOf(str) != -1 || "entity::propagate-update".indexOf(str) != -1 || "propagate-update".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity_propagate-update'] = "entity::propagate-update";
  }
  // entity element attributes
  if ("entity".indexOf(str) != -1 || "entity::render-append".indexOf(str) != -1 || "render-append".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity_render-append'] = "entity::render-append";
  }
  // entity element attributes
  if ("entity".indexOf(str) != -1 || "entity::render-exclude".indexOf(str) != -1 || "render-exclude".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity_render-exclude'] = "entity::render-exclude";
  }
  // entity element attributes
  if ("entity".indexOf(str) != -1 || "entity::render-include".indexOf(str) != -1 || "render-include".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity_render-include'] = "entity::render-include";
  }
  // entity element attributes
  if ("entity".indexOf(str) != -1 || "entity::resource".indexOf(str) != -1 || "resource".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity_resource'] = "entity::resource";
  }
  // entity element attributes
  if ("entity".indexOf(str) != -1 || "entity::resources".indexOf(str) != -1 || "resources".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity_resources'] = "entity::resources";
  }
  // entity element attributes
  if ("entity".indexOf(str) != -1 || "entity::resource-help".indexOf(str) != -1 || "resource-help".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity_resource-help'] = "entity::resource-help";
  }
  // entity element attributes
  if ("entity".indexOf(str) != -1 || "entity::skip-persistence".indexOf(str) != -1 || "skip-persistence".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity_skip-persistence'] = "entity::skip-persistence";
  }
  // entity element attributes
  if ("entity".indexOf(str) != -1 || "entity::skip-wsdl".indexOf(str) != -1 || "skip-wsdl".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity_skip-wsdl'] = "entity::skip-wsdl";
  }
  // entity element attributes
  if ("entity".indexOf(str) != -1 || "entity::table".indexOf(str) != -1 || "table".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity_table'] = "entity::table";
  }
  // entity element attributes
  if ("entity".indexOf(str) != -1 || "entity::unit-test".indexOf(str) != -1 || "unit-test".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity_unit-test'] = "entity::unit-test";
  }
  // entity element attributes
  if ("entity".indexOf(str) != -1 || "entity::vo-extends".indexOf(str) != -1 || "vo-extends".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity_vo-extends'] = "entity::vo-extends";
  }
  // entity element attributes
  if ("entity".indexOf(str) != -1 || "entity::ws-db".indexOf(str) != -1 || "ws-db".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity_ws-db'] = "entity::ws-db";
  }
  // entity element attributes
  if ("entity".indexOf(str) != -1 || "entity::ws-db-name".indexOf(str) != -1 || "ws-db-name".indexOf(str) != -1) {
    match = true;
    matches['qs_element_entity_ws-db-name'] = "entity::ws-db-name";
  }
  if ("global-views".indexOf(str) != -1) {
    match = true;
    matches['qs_element_global-views'] = "global-views";
  }
  if ("aop".indexOf(str) != -1) {
    match = true;
    matches['qs_element_aop'] = "aop";
  }
  if ("advice".indexOf(str) != -1) {
    match = true;
    matches['qs_element_advice'] = "advice";
  }
  // advice element attributes
  if ("advice".indexOf(str) != -1 || "advice::key".indexOf(str) != -1 || "key".indexOf(str) != -1) {
    match = true;
    matches['qs_element_advice_key'] = "advice::key";
  }
  // advice element attributes
  if ("advice".indexOf(str) != -1 || "advice::when".indexOf(str) != -1 || "when".indexOf(str) != -1) {
    match = true;
    matches['qs_element_advice_when'] = "advice::when";
  }
  if ("aspect".indexOf(str) != -1) {
    match = true;
    matches['qs_element_aspect'] = "aspect";
  }
  // aspect element attributes
  if ("aspect".indexOf(str) != -1 || "aspect::key".indexOf(str) != -1 || "key".indexOf(str) != -1) {
    match = true;
    matches['qs_element_aspect_key'] = "aspect::key";
  }
  // aspect element attributes
  if ("aspect".indexOf(str) != -1 || "aspect::advice".indexOf(str) != -1 || "advice".indexOf(str) != -1) {
    match = true;
    matches['qs_element_aspect_advice'] = "aspect::advice";
  }
  // aspect element attributes
  if ("aspect".indexOf(str) != -1 || "aspect::comment".indexOf(str) != -1 || "comment".indexOf(str) != -1) {
    match = true;
    matches['qs_element_aspect_comment'] = "aspect::comment";
  }
  // aspect element attributes
  if ("aspect".indexOf(str) != -1 || "aspect::pointcut".indexOf(str) != -1 || "pointcut".indexOf(str) != -1) {
    match = true;
    matches['qs_element_aspect_pointcut'] = "aspect::pointcut";
  }
  // aspect element attributes
  if ("aspect".indexOf(str) != -1 || "aspect::when".indexOf(str) != -1 || "when".indexOf(str) != -1) {
    match = true;
    matches['qs_element_aspect_when'] = "aspect::when";
  }
  if ("introduction".indexOf(str) != -1) {
    match = true;
    matches['qs_element_introduction'] = "introduction";
  }
  // introduction element attributes
  if ("introduction".indexOf(str) != -1 || "introduction::key".indexOf(str) != -1 || "key".indexOf(str) != -1) {
    match = true;
    matches['qs_element_introduction_key'] = "introduction::key";
  }
  // introduction element attributes
  if ("introduction".indexOf(str) != -1 || "introduction::class".indexOf(str) != -1 || "class".indexOf(str) != -1) {
    match = true;
    matches['qs_element_introduction_class'] = "introduction::class";
  }
  // introduction element attributes
  if ("introduction".indexOf(str) != -1 || "introduction::type".indexOf(str) != -1 || "type".indexOf(str) != -1) {
    match = true;
    matches['qs_element_introduction_type'] = "introduction::type";
  }
  // introduction element attributes
  if ("introduction".indexOf(str) != -1 || "introduction::value".indexOf(str) != -1 || "value".indexOf(str) != -1) {
    match = true;
    matches['qs_element_introduction_value'] = "introduction::value";
  }
  if ("pointcut".indexOf(str) != -1) {
    match = true;
    matches['qs_element_pointcut'] = "pointcut";
  }
  // pointcut element attributes
  if ("pointcut".indexOf(str) != -1 || "pointcut::key".indexOf(str) != -1 || "key".indexOf(str) != -1) {
    match = true;
    matches['qs_element_pointcut_key'] = "pointcut::key";
  }
  // pointcut element attributes
  if ("pointcut".indexOf(str) != -1 || "pointcut::joinpoints".indexOf(str) != -1 || "joinpoints".indexOf(str) != -1) {
    match = true;
    matches['qs_element_pointcut_joinpoints'] = "pointcut::joinpoints";
  }
  if ("attribute".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute'] = "attribute";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::key".indexOf(str) != -1 || "key".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_key'] = "attribute::key";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::aggregate".indexOf(str) != -1 || "aggregate".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_aggregate'] = "attribute::aggregate";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::aggregate-prefix".indexOf(str) != -1 || "aggregate-prefix".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_aggregate-prefix'] = "attribute::aggregate-prefix";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::api-resource".indexOf(str) != -1 || "api-resource".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_api-resource'] = "attribute::api-resource";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::cardinality".indexOf(str) != -1 || "cardinality".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_cardinality'] = "attribute::cardinality";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::cardinality-delimiter".indexOf(str) != -1 || "cardinality-delimiter".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_cardinality-delimiter'] = "attribute::cardinality-delimiter";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::cardinality-err-resource".indexOf(str) != -1 || "cardinality-err-resource".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_cardinality-err-resource'] = "attribute::cardinality-err-resource";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::cardinality-unique".indexOf(str) != -1 || "cardinality-unique".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_cardinality-unique'] = "attribute::cardinality-unique";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::circular-ref".indexOf(str) != -1 || "circular-ref".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_circular-ref'] = "attribute::circular-ref";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::column".indexOf(str) != -1 || "column".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_column'] = "attribute::column";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::column-type".indexOf(str) != -1 || "column-type".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_column-type'] = "attribute::column-type";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::constraint".indexOf(str) != -1 || "constraint".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_constraint'] = "attribute::constraint";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::date-format".indexOf(str) != -1 || "date-format".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_date-format'] = "attribute::date-format";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::default".indexOf(str) != -1 || "default".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_default'] = "attribute::default";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::depends".indexOf(str) != -1 || "depends".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_depends'] = "attribute::depends";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::dtd-name".indexOf(str) != -1 || "dtd-name".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_dtd-name'] = "attribute::dtd-name";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::file-icon-attr".indexOf(str) != -1 || "file-icon-attr".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_file-icon-attr'] = "attribute::file-icon-attr";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::file-icon-dir".indexOf(str) != -1 || "file-icon-dir".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_file-icon-dir'] = "attribute::file-icon-dir";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::file-index-attr".indexOf(str) != -1 || "file-index-attr".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_file-index-attr'] = "attribute::file-index-attr";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::file-size-attr".indexOf(str) != -1 || "file-size-attr".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_file-size-attr'] = "attribute::file-size-attr";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::file-size-kb-attr".indexOf(str) != -1 || "file-size-kb-attr".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_file-size-kb-attr'] = "attribute::file-size-kb-attr";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::file-size-mb-attr".indexOf(str) != -1 || "file-size-mb-attr".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_file-size-mb-attr'] = "attribute::file-size-mb-attr";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::file-uri-attr".indexOf(str) != -1 || "file-uri-attr".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_file-uri-attr'] = "attribute::file-uri-attr";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::file-processor".indexOf(str) != -1 || "file-processor".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_file-processor'] = "attribute::file-processor";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::global-name".indexOf(str) != -1 || "global-name".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_global-name'] = "attribute::global-name";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::indexed".indexOf(str) != -1 || "indexed".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_indexed'] = "attribute::indexed";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::is-file".indexOf(str) != -1 || "is-file".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_is-file'] = "attribute::is-file";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::is-global".indexOf(str) != -1 || "is-global".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_is-global'] = "attribute::is-global";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::json-view".indexOf(str) != -1 || "json-view".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_json-view'] = "attribute::json-view";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::lazy-load".indexOf(str) != -1 || "lazy-load".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_lazy-load'] = "attribute::lazy-load";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::lazy-load-exclusive".indexOf(str) != -1 || "lazy-load-exclusive".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_lazy-load-exclusive'] = "attribute::lazy-load-exclusive";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::mapped".indexOf(str) != -1 || "mapped".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_mapped'] = "attribute::mapped";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::mapped-exclude".indexOf(str) != -1 || "mapped-exclude".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_mapped-exclude'] = "attribute::mapped-exclude";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::mapped-include".indexOf(str) != -1 || "mapped-include".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_mapped-include'] = "attribute::mapped-include";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::mapped-postfix".indexOf(str) != -1 || "mapped-postfix".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_mapped-postfix'] = "attribute::mapped-postfix";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::mapped-prefix".indexOf(str) != -1 || "mapped-prefix".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_mapped-prefix'] = "attribute::mapped-prefix";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::mapped-resource-postfix".indexOf(str) != -1 || "mapped-resource-postfix".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_mapped-resource-postfix'] = "attribute::mapped-resource-postfix";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::mapped-resource-prefix".indexOf(str) != -1 || "mapped-resource-prefix".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_mapped-resource-prefix'] = "attribute::mapped-resource-prefix";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::match-user-id".indexOf(str) != -1 || "match-user-id".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_match-user-id'] = "attribute::match-user-id";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::max-length".indexOf(str) != -1 || "max-length".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_max-length'] = "attribute::max-length";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::min-length".indexOf(str) != -1 || "min-length".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_min-length'] = "attribute::min-length";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::null-db-empty-str".indexOf(str) != -1 || "null-db-empty-str".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_null-db-empty-str'] = "attribute::null-db-empty-str";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::on-delete-cascade".indexOf(str) != -1 || "on-delete-cascade".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_on-delete-cascade'] = "attribute::on-delete-cascade";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::on-remove-delete".indexOf(str) != -1 || "on-remove-delete".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_on-remove-delete'] = "attribute::on-remove-delete";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::order-by".indexOf(str) != -1 || "order-by".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_order-by'] = "attribute::order-by";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::read-only".indexOf(str) != -1 || "read-only".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_read-only'] = "attribute::read-only";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::recursive-link".indexOf(str) != -1 || "recursive-link".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_recursive-link'] = "attribute::recursive-link";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::render-displ-option".indexOf(str) != -1 || "render-displ-option".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_render-displ-option'] = "attribute::render-displ-option";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::render-exclude".indexOf(str) != -1 || "render-exclude".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_render-exclude'] = "attribute::render-exclude";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::render-include".indexOf(str) != -1 || "render-include".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_render-include'] = "attribute::render-include";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::resource".indexOf(str) != -1 || "resource".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_resource'] = "attribute::resource";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::resource-help".indexOf(str) != -1 || "resource-help".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_resource-help'] = "attribute::resource-help";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::retrieve-function".indexOf(str) != -1 || "retrieve-function".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_retrieve-function'] = "attribute::retrieve-function";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::sequence".indexOf(str) != -1 || "sequence".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_sequence'] = "attribute::sequence";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::set-convert".indexOf(str) != -1 || "set-convert".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_set-convert'] = "attribute::set-convert";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::set-function".indexOf(str) != -1 || "set-function".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_set-function'] = "attribute::set-function";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::set-only".indexOf(str) != -1 || "set-only".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_set-only'] = "attribute::set-only";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::skip-default-views".indexOf(str) != -1 || "skip-default-views".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_skip-default-views'] = "attribute::skip-default-views";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::skip-include".indexOf(str) != -1 || "skip-include".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_skip-include'] = "attribute::skip-include";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::skip-persistence".indexOf(str) != -1 || "skip-persistence".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_skip-persistence'] = "attribute::skip-persistence";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::skip-wsdl".indexOf(str) != -1 || "skip-wsdl".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_skip-wsdl'] = "attribute::skip-wsdl";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::sync-attributes".indexOf(str) != -1 || "sync-attributes".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_sync-attributes'] = "attribute::sync-attributes";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::table".indexOf(str) != -1 || "table".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_table'] = "attribute::table";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::table-pk-column".indexOf(str) != -1 || "table-pk-column".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_table-pk-column'] = "attribute::table-pk-column";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::type".indexOf(str) != -1 || "type".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_type'] = "attribute::type";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::type-err-resource".indexOf(str) != -1 || "type-err-resource".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_type-err-resource'] = "attribute::type-err-resource";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::union-link".indexOf(str) != -1 || "union-link".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_union-link'] = "attribute::union-link";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::xml-use-attribute".indexOf(str) != -1 || "xml-use-attribute".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_xml-use-attribute'] = "attribute::xml-use-attribute";
  }
  // attribute element attributes
  if ("attribute".indexOf(str) != -1 || "attribute::xml-view".indexOf(str) != -1 || "xml-view".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attribute_xml-view'] = "attribute::xml-view";
  }
  if ("validate".indexOf(str) != -1) {
    match = true;
    matches['qs_element_validate'] = "validate";
  }
  // validate element attributes
  if ("validate".indexOf(str) != -1 || "validate::key".indexOf(str) != -1 || "key".indexOf(str) != -1) {
    match = true;
    matches['qs_element_validate_key'] = "validate::key";
  }
  // validate element attributes
  if ("validate".indexOf(str) != -1 || "validate::attrs".indexOf(str) != -1 || "attrs".indexOf(str) != -1) {
    match = true;
    matches['qs_element_validate_attrs'] = "validate::attrs";
  }
  // validate element attributes
  if ("validate".indexOf(str) != -1 || "validate::equal".indexOf(str) != -1 || "equal".indexOf(str) != -1) {
    match = true;
    matches['qs_element_validate_equal'] = "validate::equal";
  }
  // validate element attributes
  if ("validate".indexOf(str) != -1 || "validate::eval-php-false".indexOf(str) != -1 || "eval-php-false".indexOf(str) != -1) {
    match = true;
    matches['qs_element_validate_eval-php-false'] = "validate::eval-php-false";
  }
  // validate element attributes
  if ("validate".indexOf(str) != -1 || "validate::mandatory".indexOf(str) != -1 || "mandatory".indexOf(str) != -1) {
    match = true;
    matches['qs_element_validate_mandatory'] = "validate::mandatory";
  }
  // validate element attributes
  if ("validate".indexOf(str) != -1 || "validate::not-equal".indexOf(str) != -1 || "not-equal".indexOf(str) != -1) {
    match = true;
    matches['qs_element_validate_not-equal'] = "validate::not-equal";
  }
  // validate element attributes
  if ("validate".indexOf(str) != -1 || "validate::require-all".indexOf(str) != -1 || "require-all".indexOf(str) != -1) {
    match = true;
    matches['qs_element_validate_require-all'] = "validate::require-all";
  }
  // validate element attributes
  if ("validate".indexOf(str) != -1 || "validate::resource".indexOf(str) != -1 || "resource".indexOf(str) != -1) {
    match = true;
    matches['qs_element_validate_resource'] = "validate::resource";
  }
  if ("attr-mapping".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attr-mapping'] = "attr-mapping";
  }
  // attr-mapping element attributes
  if ("attr-mapping".indexOf(str) != -1 || "attr-mapping::key".indexOf(str) != -1 || "key".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attr-mapping_key'] = "attr-mapping::key";
  }
  // attr-mapping element attributes
  if ("attr-mapping".indexOf(str) != -1 || "attr-mapping::column".indexOf(str) != -1 || "column".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attr-mapping_column'] = "attr-mapping::column";
  }
  // attr-mapping element attributes
  if ("attr-mapping".indexOf(str) != -1 || "attr-mapping::resource".indexOf(str) != -1 || "resource".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attr-mapping_resource'] = "attr-mapping::resource";
  }
  // attr-mapping element attributes
  if ("attr-mapping".indexOf(str) != -1 || "attr-mapping::resource-help".indexOf(str) != -1 || "resource-help".indexOf(str) != -1) {
    match = true;
    matches['qs_element_attr-mapping_resource-help'] = "attr-mapping::resource-help";
  }
  if ("thumbnail".indexOf(str) != -1) {
    match = true;
    matches['qs_element_thumbnail'] = "thumbnail";
  }
  // thumbnail element attributes
  if ("thumbnail".indexOf(str) != -1 || "thumbnail::key".indexOf(str) != -1 || "key".indexOf(str) != -1) {
    match = true;
    matches['qs_element_thumbnail_key'] = "thumbnail::key";
  }
  // thumbnail element attributes
  if ("thumbnail".indexOf(str) != -1 || "thumbnail::attr".indexOf(str) != -1 || "attr".indexOf(str) != -1) {
    match = true;
    matches['qs_element_thumbnail_attr'] = "thumbnail::attr";
  }
  // thumbnail element attributes
  if ("thumbnail".indexOf(str) != -1 || "thumbnail::attr-page-num".indexOf(str) != -1 || "attr-page-num".indexOf(str) != -1) {
    match = true;
    matches['qs_element_thumbnail_attr-page-num'] = "thumbnail::attr-page-num";
  }
  // thumbnail element attributes
  if ("thumbnail".indexOf(str) != -1 || "thumbnail::format".indexOf(str) != -1 || "format".indexOf(str) != -1) {
    match = true;
    matches['qs_element_thumbnail_format'] = "thumbnail::format";
  }
  // thumbnail element attributes
  if ("thumbnail".indexOf(str) != -1 || "thumbnail::include-types".indexOf(str) != -1 || "include-types".indexOf(str) != -1) {
    match = true;
    matches['qs_element_thumbnail_include-types'] = "thumbnail::include-types";
  }
  // thumbnail element attributes
  if ("thumbnail".indexOf(str) != -1 || "thumbnail::height".indexOf(str) != -1 || "height".indexOf(str) != -1) {
    match = true;
    matches['qs_element_thumbnail_height'] = "thumbnail::height";
  }
  // thumbnail element attributes
  if ("thumbnail".indexOf(str) != -1 || "thumbnail::preserve-aspect".indexOf(str) != -1 || "preserve-aspect".indexOf(str) != -1) {
    match = true;
    matches['qs_element_thumbnail_preserve-aspect'] = "thumbnail::preserve-aspect";
  }
  // thumbnail element attributes
  if ("thumbnail".indexOf(str) != -1 || "thumbnail::skip-types".indexOf(str) != -1 || "skip-types".indexOf(str) != -1) {
    match = true;
    matches['qs_element_thumbnail_skip-types'] = "thumbnail::skip-types";
  }
  // thumbnail element attributes
  if ("thumbnail".indexOf(str) != -1 || "thumbnail::width".indexOf(str) != -1 || "width".indexOf(str) != -1) {
    match = true;
    matches['qs_element_thumbnail_width'] = "thumbnail::width";
  }
  if ("default-view".indexOf(str) != -1) {
    match = true;
    matches['qs_element_default-view'] = "default-view";
  }
  // default-view element attributes
  if ("default-view".indexOf(str) != -1 || "default-view::id".indexOf(str) != -1 || "id".indexOf(str) != -1) {
    match = true;
    matches['qs_element_default-view_id'] = "default-view::id";
  }
  // default-view element attributes
  if ("default-view".indexOf(str) != -1 || "default-view::attrs".indexOf(str) != -1 || "attrs".indexOf(str) != -1) {
    match = true;
    matches['qs_element_default-view_attrs'] = "default-view::attrs";
  }
  // default-view element attributes
  if ("default-view".indexOf(str) != -1 || "default-view::cardinality".indexOf(str) != -1 || "cardinality".indexOf(str) != -1) {
    match = true;
    matches['qs_element_default-view_cardinality'] = "default-view::cardinality";
  }
  // default-view element attributes
  if ("default-view".indexOf(str) != -1 || "default-view::depends".indexOf(str) != -1 || "depends".indexOf(str) != -1) {
    match = true;
    matches['qs_element_default-view_depends'] = "default-view::depends";
  }
  // default-view element attributes
  if ("default-view".indexOf(str) != -1 || "default-view::entities".indexOf(str) != -1 || "entities".indexOf(str) != -1) {
    match = true;
    matches['qs_element_default-view_entities'] = "default-view::entities";
  }
  // default-view element attributes
  if ("default-view".indexOf(str) != -1 || "default-view::types".indexOf(str) != -1 || "types".indexOf(str) != -1) {
    match = true;
    matches['qs_element_default-view_types'] = "default-view::types";
  }
  // default-view element attributes
  if ("default-view".indexOf(str) != -1 || "default-view::view".indexOf(str) != -1 || "view".indexOf(str) != -1) {
    match = true;
    matches['qs_element_default-view_view'] = "default-view::view";
  }
  if ("view".indexOf(str) != -1) {
    match = true;
    matches['qs_element_view'] = "view";
  }
  // view element attributes
  if ("view".indexOf(str) != -1 || "view::key".indexOf(str) != -1 || "key".indexOf(str) != -1) {
    match = true;
    matches['qs_element_view_key'] = "view::key";
  }
  // view element attributes
  if ("view".indexOf(str) != -1 || "view::attrs".indexOf(str) != -1 || "attrs".indexOf(str) != -1) {
    match = true;
    matches['qs_element_view_attrs'] = "view::attrs";
  }
  // view element attributes
  if ("view".indexOf(str) != -1 || "view::cardinality-attr".indexOf(str) != -1 || "cardinality-attr".indexOf(str) != -1) {
    match = true;
    matches['qs_element_view_cardinality-attr'] = "view::cardinality-attr";
  }
  // view element attributes
  if ("view".indexOf(str) != -1 || "view::default".indexOf(str) != -1 || "default".indexOf(str) != -1) {
    match = true;
    matches['qs_element_view_default'] = "view::default";
  }
  // view element attributes
  if ("view".indexOf(str) != -1 || "view::extends".indexOf(str) != -1 || "extends".indexOf(str) != -1) {
    match = true;
    matches['qs_element_view_extends'] = "view::extends";
  }
  // view element attributes
  if ("view".indexOf(str) != -1 || "view::field-name".indexOf(str) != -1 || "field-name".indexOf(str) != -1) {
    match = true;
    matches['qs_element_view_field-name'] = "view::field-name";
  }
  // view element attributes
  if ("view".indexOf(str) != -1 || "view::forward-view".indexOf(str) != -1 || "forward-view".indexOf(str) != -1) {
    match = true;
    matches['qs_element_view_forward-view'] = "view::forward-view";
  }
  // view element attributes
  if ("view".indexOf(str) != -1 || "view::id-constraint".indexOf(str) != -1 || "id-constraint".indexOf(str) != -1) {
    match = true;
    matches['qs_element_view_id-constraint'] = "view::id-constraint";
  }
  // view element attributes
  if ("view".indexOf(str) != -1 || "view::iterate".indexOf(str) != -1 || "iterate".indexOf(str) != -1) {
    match = true;
    matches['qs_element_view_iterate'] = "view::iterate";
  }
  // view element attributes
  if ("view".indexOf(str) != -1 || "view::lookup-processor".indexOf(str) != -1 || "lookup-processor".indexOf(str) != -1) {
    match = true;
    matches['qs_element_view_lookup-processor'] = "view::lookup-processor";
  }
  // view element attributes
  if ("view".indexOf(str) != -1 || "view::lp-no-results-msg".indexOf(str) != -1 || "lp-no-results-msg".indexOf(str) != -1) {
    match = true;
    matches['qs_element_view_lp-no-results-msg'] = "view::lp-no-results-msg";
  }
  // view element attributes
  if ("view".indexOf(str) != -1 || "view::lp-no-results-tpl".indexOf(str) != -1 || "lp-no-results-tpl".indexOf(str) != -1) {
    match = true;
    matches['qs_element_view_lp-no-results-tpl'] = "view::lp-no-results-tpl";
  }
  // view element attributes
  if ("view".indexOf(str) != -1 || "view::mime-type".indexOf(str) != -1 || "mime-type".indexOf(str) != -1) {
    match = true;
    matches['qs_element_view_mime-type'] = "view::mime-type";
  }
  // view element attributes
  if ("view".indexOf(str) != -1 || "view::multiplicty-attr".indexOf(str) != -1 || "multiplicty-attr".indexOf(str) != -1) {
    match = true;
    matches['qs_element_view_multiplicty-attr'] = "view::multiplicty-attr";
  }
  // view element attributes
  if ("view".indexOf(str) != -1 || "view::post".indexOf(str) != -1 || "post".indexOf(str) != -1) {
    match = true;
    matches['qs_element_view_post'] = "view::post";
  }
  // view element attributes
  if ("view".indexOf(str) != -1 || "view::post-template".indexOf(str) != -1 || "post-template".indexOf(str) != -1) {
    match = true;
    matches['qs_element_view_post-template'] = "view::post-template";
  }
  // view element attributes
  if ("view".indexOf(str) != -1 || "view::pre".indexOf(str) != -1 || "pre".indexOf(str) != -1) {
    match = true;
    matches['qs_element_view_pre'] = "view::pre";
  }
  // view element attributes
  if ("view".indexOf(str) != -1 || "view::pre-template".indexOf(str) != -1 || "pre-template".indexOf(str) != -1) {
    match = true;
    matches['qs_element_view_pre-template'] = "view::pre-template";
  }
  // view element attributes
  if ("view".indexOf(str) != -1 || "view::render-attributes".indexOf(str) != -1 || "render-attributes".indexOf(str) != -1) {
    match = true;
    matches['qs_element_view_render-attributes'] = "view::render-attributes";
  }
  // view element attributes
  if ("view".indexOf(str) != -1 || "view::skip-attributes".indexOf(str) != -1 || "skip-attributes".indexOf(str) != -1) {
    match = true;
    matches['qs_element_view_skip-attributes'] = "view::skip-attributes";
  }
  // view element attributes
  if ("view".indexOf(str) != -1 || "view::template".indexOf(str) != -1 || "template".indexOf(str) != -1) {
    match = true;
    matches['qs_element_view_template'] = "view::template";
  }
  // view element attributes
  if ("view".indexOf(str) != -1 || "view::view-processors".indexOf(str) != -1 || "view-processors".indexOf(str) != -1) {
    match = true;
    matches['qs_element_view_view-processors'] = "view::view-processors";
  }
  if ("view-header".indexOf(str) != -1) {
    match = true;
    matches['qs_element_view-header'] = "view-header";
  }
  // view-header element attributes
  if ("view-header".indexOf(str) != -1 || "view-header::key".indexOf(str) != -1 || "key".indexOf(str) != -1) {
    match = true;
    matches['qs_element_view-header_key'] = "view-header::key";
  }
  // view-header element attributes
  if ("view-header".indexOf(str) != -1 || "view-header::replace".indexOf(str) != -1 || "replace".indexOf(str) != -1) {
    match = true;
    matches['qs_element_view-header_replace'] = "view-header::replace";
  }
  // view-header element attributes
  if ("view-header".indexOf(str) != -1 || "view-header::response-code".indexOf(str) != -1 || "response-code".indexOf(str) != -1) {
    match = true;
    matches['qs_element_view-header_response-code'] = "view-header::response-code";
  }
  if ("view-label".indexOf(str) != -1) {
    match = true;
    matches['qs_element_view-label'] = "view-label";
  }
  // view-label element attributes
  if ("view-label".indexOf(str) != -1 || "view-label::key".indexOf(str) != -1 || "key".indexOf(str) != -1) {
    match = true;
    matches['qs_element_view-label_key'] = "view-label::key";
  }
  // view-label element attributes
  if ("view-label".indexOf(str) != -1 || "view-label::label".indexOf(str) != -1 || "label".indexOf(str) != -1) {
    match = true;
    matches['qs_element_view-label_label'] = "view-label::label";
  }
  if ("view-value".indexOf(str) != -1) {
    match = true;
    matches['qs_element_view-value'] = "view-value";
  }
  // view-value element attributes
  if ("view-value".indexOf(str) != -1 || "view-value::key".indexOf(str) != -1 || "key".indexOf(str) != -1) {
    match = true;
    matches['qs_element_view-value_key'] = "view-value::key";
  }
  // view-value element attributes
  if ("view-value".indexOf(str) != -1 || "view-value::value".indexOf(str) != -1 || "value".indexOf(str) != -1) {
    match = true;
    matches['qs_element_view-value_value'] = "view-value::value";
  }
  if ("view-processor".indexOf(str) != -1) {
    match = true;
    matches['qs_element_view-processor'] = "view-processor";
  }
  // view-processor element attributes
  if ("view-processor".indexOf(str) != -1 || "view-processor::key".indexOf(str) != -1 || "key".indexOf(str) != -1) {
    match = true;
    matches['qs_element_view-processor_key'] = "view-processor::key";
  }
  // view-processor element attributes
  if ("view-processor".indexOf(str) != -1 || "view-processor::args".indexOf(str) != -1 || "args".indexOf(str) != -1) {
    match = true;
    matches['qs_element_view-processor_args'] = "view-processor::args";
  }
  // view-processor element attributes
  if ("view-processor".indexOf(str) != -1 || "view-processor::input-view".indexOf(str) != -1 || "input-view".indexOf(str) != -1) {
    match = true;
    matches['qs_element_view-processor_input-view'] = "view-processor::input-view";
  }
  // view-processor element attributes
  if ("view-processor".indexOf(str) != -1 || "view-processor::output-file-path".indexOf(str) != -1 || "output-file-path".indexOf(str) != -1) {
    match = true;
    matches['qs_element_view-processor_output-file-path'] = "view-processor::output-file-path";
  }
  // view-processor element attributes
  if ("view-processor".indexOf(str) != -1 || "view-processor::path".indexOf(str) != -1 || "path".indexOf(str) != -1) {
    match = true;
    matches['qs_element_view-processor_path'] = "view-processor::path";
  }
  // view-processor element attributes
  if ("view-processor".indexOf(str) != -1 || "view-processor::post-process-cmd".indexOf(str) != -1 || "post-process-cmd".indexOf(str) != -1) {
    match = true;
    matches['qs_element_view-processor_post-process-cmd'] = "view-processor::post-process-cmd";
  }
  // view-processor element attributes
  if ("view-processor".indexOf(str) != -1 || "view-processor::pre-process-cmd".indexOf(str) != -1 || "pre-process-cmd".indexOf(str) != -1) {
    match = true;
    matches['qs_element_view-processor_pre-process-cmd'] = "view-processor::pre-process-cmd";
  }
  if ("index".indexOf(str) != -1) {
    match = true;
    matches['qs_element_index'] = "index";
  }
  // index element attributes
  if ("index".indexOf(str) != -1 || "index::key".indexOf(str) != -1 || "key".indexOf(str) != -1) {
    match = true;
    matches['qs_element_index_key'] = "index::key";
  }
  // index element attributes
  if ("index".indexOf(str) != -1 || "index::columns".indexOf(str) != -1 || "columns".indexOf(str) != -1) {
    match = true;
    matches['qs_element_index_columns'] = "index::columns";
  }
  // index element attributes
  if ("index".indexOf(str) != -1 || "index::modifier".indexOf(str) != -1 || "modifier".indexOf(str) != -1) {
    match = true;
    matches['qs_element_index_modifier'] = "index::modifier";
  }
  // index element attributes
  if ("index".indexOf(str) != -1 || "index::postfix".indexOf(str) != -1 || "postfix".indexOf(str) != -1) {
    match = true;
    matches['qs_element_index_postfix'] = "index::postfix";
  }
  // index element attributes
  if ("index".indexOf(str) != -1 || "index::table".indexOf(str) != -1 || "table".indexOf(str) != -1) {
    match = true;
    matches['qs_element_index_table'] = "index::table";
  }
  if ("ws".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws'] = "ws";
  }
  // ws element attributes
  if ("ws".indexOf(str) != -1 || "ws::key".indexOf(str) != -1 || "key".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws_key'] = "ws::key";
  }
  // ws element attributes
  if ("ws".indexOf(str) != -1 || "ws::api".indexOf(str) != -1 || "api".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws_api'] = "ws::api";
  }
  // ws element attributes
  if ("ws".indexOf(str) != -1 || "ws::authenticate".indexOf(str) != -1 || "authenticate".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws_authenticate'] = "ws::authenticate";
  }
  // ws element attributes
  if ("ws".indexOf(str) != -1 || "ws::create".indexOf(str) != -1 || "create".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws_create'] = "ws::create";
  }
  // ws element attributes
  if ("ws".indexOf(str) != -1 || "ws::delete".indexOf(str) != -1 || "delete".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws_delete'] = "ws::delete";
  }
  // ws element attributes
  if ("ws".indexOf(str) != -1 || "ws::exclude-attrs".indexOf(str) != -1 || "exclude-attrs".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws_exclude-attrs'] = "ws::exclude-attrs";
  }
  // ws element attributes
  if ("ws".indexOf(str) != -1 || "ws::format".indexOf(str) != -1 || "format".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws_format'] = "ws::format";
  }
  // ws element attributes
  if ("ws".indexOf(str) != -1 || "ws::format-fixed".indexOf(str) != -1 || "format-fixed".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws_format-fixed'] = "ws::format-fixed";
  }
  // ws element attributes
  if ("ws".indexOf(str) != -1 || "ws::hidden".indexOf(str) != -1 || "hidden".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws_hidden'] = "ws::hidden";
  }
  // ws element attributes
  if ("ws".indexOf(str) != -1 || "ws::hidden-method".indexOf(str) != -1 || "hidden-method".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws_hidden-method'] = "ws::hidden-method";
  }
  // ws element attributes
  if ("ws".indexOf(str) != -1 || "ws::include-attrs".indexOf(str) != -1 || "include-attrs".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws_include-attrs'] = "ws::include-attrs";
  }
  // ws element attributes
  if ("ws".indexOf(str) != -1 || "ws::ip-authenticator".indexOf(str) != -1 || "ip-authenticator".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws_ip-authenticator'] = "ws::ip-authenticator";
  }
  // ws element attributes
  if ("ws".indexOf(str) != -1 || "ws::limit".indexOf(str) != -1 || "limit".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws_limit'] = "ws::limit";
  }
  // ws element attributes
  if ("ws".indexOf(str) != -1 || "ws::limit-fixed".indexOf(str) != -1 || "limit-fixed".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws_limit-fixed'] = "ws::limit-fixed";
  }
  // ws element attributes
  if ("ws".indexOf(str) != -1 || "ws::meta-format".indexOf(str) != -1 || "meta-format".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws_meta-format'] = "ws::meta-format";
  }
  // ws element attributes
  if ("ws".indexOf(str) != -1 || "ws::meta-format-fixed".indexOf(str) != -1 || "meta-format-fixed".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws_meta-format-fixed'] = "ws::meta-format-fixed";
  }
  // ws element attributes
  if ("ws".indexOf(str) != -1 || "ws::rest".indexOf(str) != -1 || "rest".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws_rest'] = "ws::rest";
  }
  // ws element attributes
  if ("ws".indexOf(str) != -1 || "ws::retrieve".indexOf(str) != -1 || "retrieve".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws_retrieve'] = "ws::retrieve";
  }
  // ws element attributes
  if ("ws".indexOf(str) != -1 || "ws::soap".indexOf(str) != -1 || "soap".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws_soap'] = "ws::soap";
  }
  // ws element attributes
  if ("ws".indexOf(str) != -1 || "ws::sub-entities".indexOf(str) != -1 || "sub-entities".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws_sub-entities'] = "ws::sub-entities";
  }
  // ws element attributes
  if ("ws".indexOf(str) != -1 || "ws::update".indexOf(str) != -1 || "update".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws_update'] = "ws::update";
  }
  // ws element attributes
  if ("ws".indexOf(str) != -1 || "ws::validators".indexOf(str) != -1 || "validators".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws_validators'] = "ws::validators";
  }
  // ws element attributes
  if ("ws".indexOf(str) != -1 || "ws::view".indexOf(str) != -1 || "view".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws_view'] = "ws::view";
  }
  // ws element attributes
  if ("ws".indexOf(str) != -1 || "ws::view-json".indexOf(str) != -1 || "view-json".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws_view-json'] = "ws::view-json";
  }
  // ws element attributes
  if ("ws".indexOf(str) != -1 || "ws::view-xml".indexOf(str) != -1 || "view-xml".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws_view-xml'] = "ws::view-xml";
  }
  if ("ws-constraint-group".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws-constraint-group'] = "ws-constraint-group";
  }
  // ws-constraint-group element attributes
  if ("ws-constraint-group".indexOf(str) != -1 || "ws-constraint-group::connective".indexOf(str) != -1 || "connective".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws-constraint-group_connective'] = "ws-constraint-group::connective";
  }
  if ("ws-constraint".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws-constraint'] = "ws-constraint";
  }
  // ws-constraint element attributes
  if ("ws-constraint".indexOf(str) != -1 || "ws-constraint::attr".indexOf(str) != -1 || "attr".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws-constraint_attr'] = "ws-constraint::attr";
  }
  // ws-constraint element attributes
  if ("ws-constraint".indexOf(str) != -1 || "ws-constraint::attr-type".indexOf(str) != -1 || "attr-type".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws-constraint_attr-type'] = "ws-constraint::attr-type";
  }
  // ws-constraint element attributes
  if ("ws-constraint".indexOf(str) != -1 || "ws-constraint::auto-set".indexOf(str) != -1 || "auto-set".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws-constraint_auto-set'] = "ws-constraint::auto-set";
  }
  // ws-constraint element attributes
  if ("ws-constraint".indexOf(str) != -1 || "ws-constraint::operator".indexOf(str) != -1 || "operator".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws-constraint_operator'] = "ws-constraint::operator";
  }
  // ws-constraint element attributes
  if ("ws-constraint".indexOf(str) != -1 || "ws-constraint::value".indexOf(str) != -1 || "value".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws-constraint_value'] = "ws-constraint::value";
  }
  // ws-constraint element attributes
  if ("ws-constraint".indexOf(str) != -1 || "ws-constraint::value-type".indexOf(str) != -1 || "value-type".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws-constraint_value-type'] = "ws-constraint::value-type";
  }
  if ("ws-global".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws-global'] = "ws-global";
  }
  // ws-global element attributes
  if ("ws-global".indexOf(str) != -1 || "ws-global::key".indexOf(str) != -1 || "key".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws-global_key'] = "ws-global::key";
  }
  // ws-global element attributes
  if ("ws-global".indexOf(str) != -1 || "ws-global::api".indexOf(str) != -1 || "api".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws-global_api'] = "ws-global::api";
  }
  // ws-global element attributes
  if ("ws-global".indexOf(str) != -1 || "ws-global::authenticate".indexOf(str) != -1 || "authenticate".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws-global_authenticate'] = "ws-global::authenticate";
  }
  // ws-global element attributes
  if ("ws-global".indexOf(str) != -1 || "ws-global::format".indexOf(str) != -1 || "format".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws-global_format'] = "ws-global::format";
  }
  // ws-global element attributes
  if ("ws-global".indexOf(str) != -1 || "ws-global::format-fixed".indexOf(str) != -1 || "format-fixed".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws-global_format-fixed'] = "ws-global::format-fixed";
  }
  // ws-global element attributes
  if ("ws-global".indexOf(str) != -1 || "ws-global::hidden".indexOf(str) != -1 || "hidden".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws-global_hidden'] = "ws-global::hidden";
  }
  // ws-global element attributes
  if ("ws-global".indexOf(str) != -1 || "ws-global::hidden-method".indexOf(str) != -1 || "hidden-method".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws-global_hidden-method'] = "ws-global::hidden-method";
  }
  // ws-global element attributes
  if ("ws-global".indexOf(str) != -1 || "ws-global::identifier".indexOf(str) != -1 || "identifier".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws-global_identifier'] = "ws-global::identifier";
  }
  // ws-global element attributes
  if ("ws-global".indexOf(str) != -1 || "ws-global::introspect-api".indexOf(str) != -1 || "introspect-api".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws-global_introspect-api'] = "ws-global::introspect-api";
  }
  // ws-global element attributes
  if ("ws-global".indexOf(str) != -1 || "ws-global::ip-authenticator".indexOf(str) != -1 || "ip-authenticator".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws-global_ip-authenticator'] = "ws-global::ip-authenticator";
  }
  // ws-global element attributes
  if ("ws-global".indexOf(str) != -1 || "ws-global::limit".indexOf(str) != -1 || "limit".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws-global_limit'] = "ws-global::limit";
  }
  // ws-global element attributes
  if ("ws-global".indexOf(str) != -1 || "ws-global::limit-fixed".indexOf(str) != -1 || "limit-fixed".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws-global_limit-fixed'] = "ws-global::limit-fixed";
  }
  // ws-global element attributes
  if ("ws-global".indexOf(str) != -1 || "ws-global::meta-format".indexOf(str) != -1 || "meta-format".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws-global_meta-format'] = "ws-global::meta-format";
  }
  // ws-global element attributes
  if ("ws-global".indexOf(str) != -1 || "ws-global::meta-format-fixed".indexOf(str) != -1 || "meta-format-fixed".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws-global_meta-format-fixed'] = "ws-global::meta-format-fixed";
  }
  // ws-global element attributes
  if ("ws-global".indexOf(str) != -1 || "ws-global::rest".indexOf(str) != -1 || "rest".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws-global_rest'] = "ws-global::rest";
  }
  // ws-global element attributes
  if ("ws-global".indexOf(str) != -1 || "ws-global::soap".indexOf(str) != -1 || "soap".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws-global_soap'] = "ws-global::soap";
  }
  // ws-global element attributes
  if ("ws-global".indexOf(str) != -1 || "ws-global::type".indexOf(str) != -1 || "type".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws-global_type'] = "ws-global::type";
  }
  if ("ws-param".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws-param'] = "ws-param";
  }
  // ws-param element attributes
  if ("ws-param".indexOf(str) != -1 || "ws-param::key".indexOf(str) != -1 || "key".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws-param_key'] = "ws-param::key";
  }
  // ws-param element attributes
  if ("ws-param".indexOf(str) != -1 || "ws-param::allow-override".indexOf(str) != -1 || "allow-override".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws-param_allow-override'] = "ws-param::allow-override";
  }
  // ws-param element attributes
  if ("ws-param".indexOf(str) != -1 || "ws-param::value".indexOf(str) != -1 || "value".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws-param_value'] = "ws-param::value";
  }
  // ws-param element attributes
  if ("ws-param".indexOf(str) != -1 || "ws-param::value-type".indexOf(str) != -1 || "value-type".indexOf(str) != -1) {
    match = true;
    matches['qs_element_ws-param_value-type'] = "ws-param::value-type";
  }
  if ("msg".indexOf(str) != -1) {
    match = true;
    matches['qs_element_msg'] = "msg";
  }
  // msg element attributes
  if ("msg".indexOf(str) != -1 || "msg::key".indexOf(str) != -1 || "key".indexOf(str) != -1) {
    match = true;
    matches['qs_element_msg_key'] = "msg::key";
  }
  // msg element attributes
  if ("msg".indexOf(str) != -1 || "msg::resource".indexOf(str) != -1 || "resource".indexOf(str) != -1) {
    match = true;
    matches['qs_element_msg_resource'] = "msg::resource";
  }
  if ("param".indexOf(str) != -1) {
    match = true;
    matches['qs_element_param'] = "param";
  }
  // param element attributes
  if ("param".indexOf(str) != -1 || "param::id".indexOf(str) != -1 || "id".indexOf(str) != -1) {
    match = true;
    matches['qs_element_param_id'] = "param::id";
  }
  // param element attributes
  if ("param".indexOf(str) != -1 || "param::type".indexOf(str) != -1 || "type".indexOf(str) != -1) {
    match = true;
    matches['qs_element_param_type'] = "param::type";
  }
  // param element attributes
  if ("param".indexOf(str) != -1 || "param::value".indexOf(str) != -1 || "value".indexOf(str) != -1) {
    match = true;
    matches['qs_element_param_value'] = "param::value";
  }
  if ("var".indexOf(str) != -1) {
    match = true;
    matches['qs_element_var'] = "var";
  }
  // var element attributes
  if ("var".indexOf(str) != -1 || "var::key".indexOf(str) != -1 || "key".indexOf(str) != -1) {
    match = true;
    matches['qs_element_var_key'] = "var::key";
  }
  // var element attributes
  if ("var".indexOf(str) != -1 || "var::value".indexOf(str) != -1 || "value".indexOf(str) != -1) {
    match = true;
    matches['qs_element_var_value'] = "var::value";
  }

  }
  
  if (match) {
    var html = '';
    for(var i in matches) {
      _tipIds.push(i);
      html += '<div id="' + i + '" style="background-color: white; cursor: pointer;" onclick="document.location.replace(\'#\' + this.id.substr(3))">' + matches[i] + '</div>\n';
    }
    document.getElementById('quicksearch_tips').innerHTML = html;
    showQsTips();
  }
  else {
    hideQsTips();
  }
}
-->
</script></head>
<body id="dtd" onload="document.getElementById('quicksearch').onkeyup = updateQsTips; document.getElementById('quicksearch').focus()">
  <h1 id="top">entity-model-ws.dtd</h1>
<p>&nbsp;&nbsp;&nbsp;&nbsp;package <a href="../packages/model.html" target="contentFrame">model</a></p>  <hr />
  
  <form onsubmit="return false">
  
  <div style="float:right">
    <b><label for="quicksearch">Quick Search:</label></b><br />
    <input id="quicksearch" type="text" onfocus="clearQsTips()" onblur="hideQsTips()" autocomplete="off" onclick="this.select()" /><br />
    <div id="quicksearch_tips" style="border: 1px solid #333; position:absolute; display:none"></div>
  </div>
  
  <h2>DTD Information</h2>
  <ul>
    <li><a href="#comments">DTD Comments</a></li>
    <li><a href="#entities">Entities</a></li>
    <li><a href="#elements">Elements</a></li>
    <li><a href="#element_details">Element Details</a></li>
  </ul>
  
  <h2 id="comments">Comment</h2>
  <pre>XML DTD for a SIERRA app entity model

This file defines a app entity model.

To support validation of your entity-model xml file, include the following
DOCTYPE element at the beginning (after the &quot;xml&quot; declaration):

&lt;!DOCTYPE entity-model PUBLIC &quot;-//SIERRA//DTD ENTITY MODEL//EN&quot; 
  &quot;http://sierra-php.googlecode.com/svn/trunk/lib/model/entity-model.dtd&quot;&gt;
</pre>
  
  <h2 id="entities">Entities</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Value</th>
      <th>Comment</th>
    </tr>
    <tr>
      <th><pre>Resource</pre></th>
      <td>CDATA</td>
      <td><pre>An &quot;Resource&quot; is the key in the application SRA_ResourceBundle that contains a 
string or name for an element. 
</pre></td>
    </tr>
  </table>

  <h2 id="elements">Elements</h2>
  <table border="1" width="100%">
    <tr>
      <th><pre><a href="#element_entity-model">entity-model</a><strong> [root element]</strong></pre></th>
      <td><pre>The &quot;entity-model&quot; element is the root element of an entity model. It defines 
1 or more entity sub-elements as well as the following attributes (default 
values are specified). &quot;msg&quot; sub-elements will be propogated down to this 
all of the &quot;entity&quot; sub-elements

file*             global &quot;file*&quot; attributes. these will be assigned to all 
                  entities for which DAOs are generated unless overriden by 
                  those entities. for details on the meaning of these 
                  attributes, see the &#039;entity&#039; ELEMENT documentation.</pre></td>
    </tr>
    <tr>
      <th><pre><a href="#element_entity">entity</a></pre></th>
      <td><pre>The &quot;entity&quot; element describes the characteristics of a single Entity in an 
application&#039;s object model. This includes attributes, relational 
characteristics, and validation. An entity must contain at least 1 attribute. 
&quot;msg&quot; sub-elements will be propogated down to this entity&#039;s attributes. Every 
persistable entity MUST have at least 1 non-sequence attribute in its primary 
database table in order for inserts to be able to be performed</pre></td>
    </tr>
    <tr>
      <th><pre><a href="#element_global-views">global-views</a></pre></th>
      <td><pre>The &quot;global-views&quot; element contains one or more &#039;view&#039; configurations that may 
be used throughout the model in entity and attribute configurations. For 
example, a global view may be created for displaying links that may then be 
referenced in any link type attributes. it also may define default view for 
attributes based on the type


</pre></td>
    </tr>
    <tr>
      <th><pre><a href="#element_aop">aop</a></pre></th>
      <td><pre>The &quot;aop&quot; element is used to apply cross-cutting concerns to classes derived 
from this entity-model. these are secondary requirements that will be 
dynamically attached to the class source files. for more an introduction to AOP 
programming, do a google search for &quot;AOP Introduction&quot;. For our purposes, the 
aop terms you will need to understand are as follows:

advice:       the code to attach to the joinpoints as well as when that should 
              occur (either before the method starts, or after it ends)
              
aspect:       the combination of a pointcut and advice. as aspect will result in 
              code modification at build time
              
introduction: an additional include, attribute or method that should be added to 
              a class
              
pointcut:     a set of join points where advice should be applied

</pre></td>
    </tr>
    <tr>
      <th><pre><a href="#element_advice">advice</a></pre></th>
      <td><pre>The &quot;advice&quot; element defines cross-cutting code. this is code that is applied as
an aspect to a method in a class that is derived from this entity model. advice 
may be applied to multiple such methods. the body of this element is the code 
that should be applied. this code may perform such activities as logging, 
validation, additional logic, etc. It has full access to the parameters to that 
method invocation as well as the object instance variables and any other data 
and/or code accessible within the current running php process. the code may 
additionally pre-maturely exit the method using return.</pre></td>
    </tr>
    <tr>
      <th><pre><a href="#element_aspect">aspect</a></pre></th>
      <td><pre>The &quot;aspect&quot; element is the glue between advice and pointcuts. it defines the 
code to be attached (advice) as well as the location(s) where that code should 
be attached (pointcut). the advice and pointcut may either be defined in this 
element (if never will never be used in another aspect) or in external 
referenced advice and pointcut elements</pre></td>
    </tr>
    <tr>
      <th><pre><a href="#element_introduction">introduction</a></pre></th>
      <td><pre>The &quot;introduction&quot; element defines an additional include, attribute or method 
that should be attached to a class. for method introductions, the body of this 
element should define the method body code</pre></td>
    </tr>
    <tr>
      <th><pre><a href="#element_pointcut">pointcut</a></pre></th>
      <td><pre>The &quot;pointcut&quot; element defines a set of join points where advice should be 
applied. it is referenced in aspects.</pre></td>
    </tr>
    <tr>
      <th><pre><a href="#element_attribute">attribute</a></pre></th>
      <td><pre>The &quot;attribute&quot; element describes a single attribute in an entity. attributes 
can have any type of associative relationship to the entity such as 1..1, 1..*, 
0..* etc. Relational attributes reference other entities. This element also 
describes validation constraints and o/r mapping details.</pre></td>
    </tr>
    <tr>
      <th><pre><a href="#element_validate">validate</a></pre></th>
      <td><pre>The &quot;validate&quot; element defines an entity validation sequence. these are 
different then attribute validators defined using &quot;depends&quot;. &quot;validate&quot; is used 
to specify sets of attributes that are required either as a whole (all required) 
or partially (at least one required)</pre></td>
    </tr>
    <tr>
      <th><pre><a href="#element_attr-mapping">attr-mapping</a></pre></th>
      <td><pre>The &quot;attr-mapping&quot; element defines a limited scope of which attributes of an 
entity type attribute will actually be used and persisted by the attribute that 
maps them. If specified, these mappings will define entirely which attributes of 
the entity will be persistable. Any attributes for which a attr-mapping is not 
specified will not be persisted</pre></td>
    </tr>
    <tr>
      <th><pre><a href="#element_thumbnail">thumbnail</a></pre></th>
      <td><pre>The &quot;thumbnail&quot; element is used in conjunction with file type attributes 
(where is-file is true) when the model should automatically attempt to generate
a thumbnail (or thumbnails) for that attribute and store those also as file 
type attributes using another member attribute in the same entity. for more 
information on this functionality, see the api for 
SRA_FileAttribute::toThumbnail. this attribute may be used only with file 
attributes without cardinality. the value stored in the referenced attribute 
will be a new SRA_FileAttribute instance representing the thumbnail. at least 
1 height or width (or both) MUST be specified for all thumbnails. if both height 
and width are specified, and &quot;preserve-aspect&quot; is not true, the aspect ratio of 
the image may be affected because that exact height/width will be used for the 
generated thumbnail. if only one, height or width is specified, or if both are 
specified and &quot;preserve-aspect&quot; is true, those values will be the max height
or width of the generated thumbnail while the other dimension will be 
proportional to the dimension that is used according to the image aspect ratio. 
thumbnails will be generated to png format by default. gif and jpeg are also 
supported formats and may be specified using the &quot;format&quot; attribute. if multiple 
thumbnails are created as a result of the thumbnail generation process (i.e. 
when file is pdf with multiple pages), the first page thumbnail will be used 
UNLESS the thumbnail attribute referenced has cardinality in which case ALL of 
the thumbnails will be set in the same order of the pages. thumbnails cannot be 
generated for file attributes with cardinality</pre></td>
    </tr>
    <tr>
      <th><pre><a href="#element_default-view">default-view</a></pre></th>
      <td><pre>The &quot;default-view&quot; element is used to automatically associate a a view within 
&quot;global-views&quot; to all attributes of a given type. for example, if you wanted all 
&quot;string&quot; attributes to automatically use a global view named &quot;output&quot; which is 
simple a text label output, you could use this element instead of creating a 
&quot;view&quot; extends sub-element for each attribute. in this case you would first 
create a global-view named &quot;output-text&quot; and then create a &quot;default-view&quot; where 
id=&quot;output&quot;, type=&quot;string&quot; and view=&quot;output-text&quot;. you may restrict associations 
using the optional attributes, cardinality, and entities attributes. default 
views can be ignored or overriden in model attributes using the 
&quot;skip-default-views&quot; attribute or by creating a custom view using the same name.
default views apply ONLY to attributes. &quot;default-view&quot; elements can also be 
overriden at the entity level using by nesting them within the entity element</pre></td>
    </tr>
    <tr>
      <th><pre><a href="#element_view">view</a></pre></th>
      <td><pre>The &quot;view&quot; element defines a single entity/attribute view. These views are used 
to display the entities/attributes for viewing or editing. For example, one view 
may be defined to display in a read-only format, one in a form that a user can 
fill in, and one to display the entity data in a printable pdf format. views can 
be rendered utilizing the corresponding VO::render and VO::renderAttribute 
methods. The following template variables will automatically be set:
    entity: a reference to the entity instance/value
    attribute: a reference to the attribute instance/value
    [attribute|entity]Name: the name of the entity or attribute
    [attribute|entity]Label: the label for the entity or attribute
    attributeIndex: the current attribute index (where multiplicty is used)
    fieldName: the field name for an attribute view. this value may be 
               automatically prefixed or postfixed using SRA_EntityView::getGlobalFieldNamePrefix() 
               and SRA_EntityView::getGlobalFieldNamePostfix()
    params: SRA_Params object representing the params specified for the view
    attrs: an array of the names of the attributes that will be rendered as determined by the &quot;attrs&quot; value
    viewName: the name of the view being rendered
    
A view named &#039;xml&#039; (not case sensitive) is reserved for every entity. rendering 
that view will result in a pass-thru call to the VO::renderXml method.

A view may have 0..* nested param elements. the corresponding view templates 
used by the view may use these values in different ways. consult the documentation 
for those view templates for further information. 

One reserved param type is &#039;view-resources&#039; (SRA_ENTITY_MODELER_VIEW_RESOURCES_PARAM_TYPE)
which may be used to specify resource bundles that should be made available 
within an entity (attr views not supported) view. The &#039;id&#039; for these params will 
be the template variable through which that resource bundle reference may be 
accessed, and the value will be the path (app/framework relative, or fixed path) 
to the resource bundle. When rendered, the correct localized resource bundle 
will be selected and made available accordingly within the template. This 
feature applies also to the &#039;xml&#039; and &#039;json&#039; built-in views. When applied within 
an xml view (template=&quot;xml&quot;), each resource bundle will be included using the 
&quot;view-resources&quot; (&quot;ViewResources&quot; for camel-case dtds) element (directly below 
the root xml document element) where the &quot;id&quot; of that element will correspond 
with the &quot;id&quot; of the &quot;param&quot;, and each of these elements will contains 0..* 
nested &quot;view-resources-string&quot; (&quot;ViewResourcesString&quot; for camel-case dtds) for 
each string included in that resource bundle file (the &quot;id&quot; attribute of this 
element will be equal to the key and the value of that element will be the 
string value). When applied within a json view (template=&quot;json&quot;), an attribute 
named &quot;ViewResources&quot; will be automatically appended to the json serialized 
object. This attribute will be an associative array indexed by the resources 
&quot;id&quot;, where the value of each will also be an associative array of key/value 
pairs representing the strings included in the resource bundle.

Additionally, the view itself may utilize nested params of type &#039;formInitVals&#039; 
defining 0..* attribute values that should be added to the object initialization 
array when [VO]::newInstanceFromForm is invoked. the key in these params will be 
the attribute name, and the value will be either an explicit value or php code 
that will generate that value. the value will be postfixed with a ;. the view 
may also utilize nested params of type &#039;formInitValsRemove&#039; which will 
remove any initialization values if they are equal to the value specified in 
the param, or just set if a value is not specified.. the view may also utilize 
nested params of type &#039;formInitValsPre&#039; which are similiar to &#039;formInitVals&#039; but 
may be overwritten by $_POST/$_GET values for the corresponding attributes</pre></td>
    </tr>
    <tr>
      <th><pre><a href="#element_view-header">view-header</a></pre></th>
      <td><pre>The &quot;view-header&quot; is a single http header output that should precede the output 
from a &quot;view&quot; (for more information see &#039;header&#039; function documentation in the 
PHP manual)</pre></td>
    </tr>
    <tr>
      <th><pre><a href="#element_view-label">view-label</a></pre></th>
      <td><pre>A &quot;view-label&quot; is used override the default label for an entity/attribute within 
a view.</pre></td>
    </tr>
    <tr>
      <th><pre><a href="#element_view-value">view-value</a></pre></th>
      <td><pre>A &quot;view-value&quot; is used override the default value for an attribute</pre></td>
    </tr>
    <tr>
      <th><pre><a href="#element_view-processor">view-processor</a></pre></th>
      <td><pre>The &quot;view-processor&quot; element allows the output of a &quot;view&quot; template or another 
&quot;view-processor&quot; to be used as input to a command line program. This is useful 
in that it allows additional processing to take place on the view output such as 
xsl-fo processing for example</pre></td>
    </tr>
    <tr>
      <th><pre><a href="#element_index">index</a></pre></th>
      <td><pre>The &quot;index&quot; element defines a single index to add to the generated ddl for this 
entity model. indexes should be used to optimize database queries. for example, 
if you know you will query frequently on a particular non-primary key column, 
then by adding an index for that table/column the performance of those queries 
will be significantly improved. indexes should only be added if &quot;ddl-path&quot; is 
defined or &quot;sync-schema&quot; is TRUE in the enclosing &quot;entity-model&quot; element. the 
sql that is generated for each defined index will be of the form:
CREATE INDEX [name] ON [table] ([columns]) [postfix]</pre></td>
    </tr>
    <tr>
      <th><pre><a href="#element_ws">ws</a></pre></th>
      <td><pre>The &quot;ws&quot; element is used to define a single entity specific web service exposed 
through the &quot;ws-gateway-uri&quot; defined for this entity model. this element 
specifies how an entity may be accessed and manipulated via a ajax/rest/soap 
web service request. this includes security implications as well as access 
control. web services can only be exposed if &quot;ws-gateway-uri&quot; has been defined 
in the enclosing entity-model. ONLY those web services specified in the 
entity-model for a given entity can be accessed. if this service contains 
multiple constraint groups, they will be joined using the AND connective. web 
services may allow users to CREATE, DELETE, RETRIEVE and UPDATE entities of the 
enclosing type. By default only the retrieve functionality is enabled. at least 
1 of the CRUD functional flags MUST be enabled. for information on how to invoke 
a web service review the documentation provided in sra-ws-gateway.php</pre></td>
    </tr>
    <tr>
      <th><pre><a href="#element_ws-constraint-group">ws-constraint-group</a></pre></th>
      <td><pre>The &quot;ws-constraint-group&quot; element is used to specify 1 or more ws-constraint 
sub-elements that will be evaluated as a whole based on the &quot;connective&quot; 
specified for the group (either conjunction or disjunction). the evaluation 
includes short-circuiting for conjunction join types (and)</pre></td>
    </tr>
    <tr>
      <th><pre><a href="#element_ws-constraint">ws-constraint</a></pre></th>
      <td><pre>The &quot;ws-constraint&quot; element is used to add implicit security or filter related 
constraint to an web service. the &quot;ws-gateway-uri&quot; may be secured through 
the sierra-php app authentication, however, past that, without any service 
constraints for a given entity web service (&quot;ws&quot;), an authenticated user (or 
non-authenticated user if the &quot;ws-gateway-uri&quot; script is not secured) may 
utilize that service. if constraints overlap between the request and the ws 
definition, the definition constraints will override those in the request</pre></td>
    </tr>
    <tr>
      <th><pre><a href="#element_ws-global">ws-global</a></pre></th>
      <td><pre>the &quot;ws-global&quot; element is used to define a web service that will be exposed 
using the &quot;ws-gateway-uri&quot; for this entity model. unlike &quot;ws&quot;, &quot;ws-global&quot; 
services are less structured and not entity specific. this element contains 0..* 
nested &quot;ws-param&quot; elements (see documentation provided below). the use of these 
nested elements varies as does the output depending on the service &quot;type&quot;. for 
information on how to invoke a web service review the documentation provided in 
sra-ws-gateway.php

TYPE DEPENDENT I/O:

method:
 ws-param:
 *        all params will be passed to the method in the form of an associative 
          array where the key is the param key and the value is the param value
          
 RESULTS OUTPUT
 the return value will be whatever value is returned by the method serialized 
 according to the &quot;format&quot; specified. method return values can be null, scalar, 
 an object, map or an array. for the latter three, the results will be an 
 associative array according to the object properties/values or array 
 keys/values. if the method invocation returns an SRA_Error object, &quot;ws-status&quot; 
 will be SRA_WS_REQUEST_STATUS_FAILED. If the return value is an array and 
 contains the key SRA_WS_RESULT_COUNT_KEY, that value will be returned as 
 the &#039;ws-count&#039; meta value in the results (and removed from the return value).
 NOTE: if &quot;format&quot; is &quot;xml&quot;, the method output must be an object or array of 
 objects that have a &quot;renderXml&quot; method or the &quot;ws-status&quot; will be 
 SRA_WS_REQUEST_STATUS_FAILED
 
 Note: api and wsdl documentation for this service type will be retrieved using 
       the SRA_Util::parsePhpSource method. using this documentation format, you 
       may specify the type of api documentation to use for the method 
       method parameters. additionally, the method api documentation will be 
       used to document this service is &quot;api&quot; is not specified

sql:  
 ws-param:
 *        dynamic sql params. the &quot;key&quot; value for these params can be nested in 
          the sql statement beginning and ending with a &quot;#&quot; symbol and will be 
          replaced at runtime with the appropriate value
 RESULTS OUTPUT
 SELECT queries:                 json: an array of associative arrays each 
                                 representing one row of the results where the 
                                 key in the associative array is the column name 
                                 (or alias) assigned in the sql query 
                                 (serialized according to the &quot;output&quot; type 
                                 specified
                                 xml: &lt;query-results&gt;
                                        &lt;row key=&quot;[row num]&quot;&gt;
                                          &lt;col key=&quot;[col name]&quot;&gt;&lt;![CDATA[[col value]]]&gt;&lt;/col&gt;
                                        &lt;/row&gt;
                                      &lt;/query-results&gt;
                                 raw: NOT SUPPORTED
 DELETE, INSERT, UPDATE queries: empty - &quot;ws-count&quot; will be the # of rows 
                                 affected by the query
 
rb: 
 ws-param:
 keys       the names of the resource bundle values to return (separated by 
            spaces). if not specified, all strings in the identified bundle will 
            be returned
 search     search string. the search is not case sensitive
 beginsWith begins with search string. the search is not case sensitive
 endsWith   ends with search string. the search is not case sensitive
 
 RESULTS OUTPUT
 json: an associative array of the resource bundle strings (names/values)
 xml:  &lt;resource-bundle path=&quot;[identifier attr value]&quot;&gt;
         &lt;string key=&quot;[resource name]&quot;&gt;&lt;![CDATA[[resource value]]]&gt;&lt;/string&gt;
       &lt;/resource-bundle&gt;
 raw: NOT SUPPORTED</pre></td>
    </tr>
    <tr>
      <th><pre><a href="#element_ws-param">ws-param</a></pre></th>
      <td><pre>The &quot;ws-param&quot; element is used to provide a generic means to specifying runtime 
parameters for a global web service (&quot;ws-global&quot;). the value should be imbedded 
between the open and close tags of this element (use &lt;![CDATA[]]&gt; to avoid 
having escape special characters) or specified as the &quot;value&quot; attribute</pre></td>
    </tr>
    <tr>
      <th><pre><a href="#element_msg">msg</a></pre></th>
      <td><pre>The &quot;msg&quot; element defines a key/value pair that will be used when &#039;depends&#039; 
validation errors occur</pre></td>
    </tr>
    <tr>
      <th><pre><a href="#element_param">param</a></pre></th>
      <td><pre>The &quot;param&quot; element defines a generic key/value pair. when used in a &quot;view&quot;, 
these params will be passed into the corresponding templates encapsulated as a 
SRA_Params object</pre></td>
    </tr>
    <tr>
      <th><pre><a href="#element_var">var</a></pre></th>
      <td><pre>The &quot;var&quot; element defines a key/value pair that will be passed into 
SRA_AttributeValidator::{method} for &#039;depends&#039; validation contraints (the second 
parameter of all SRA_AttributeValidator methods accepts an associative array of 
key/value pairs). this array will also be passed into the 
SRA_ResourceBundle::getString method when retrieving the &#039;msg&#039; specified for that 
error.</pre></td>
    </tr>
  </table>
  
  <h2 id="element_details">Element Details</h2>
  <a href="#top" style="float:right">Top</a>
  <a href="#top" style="float:right">Top</a>
  <h3 id="element_entity-model">entity-model [root element]</h3>
  <pre>The &quot;entity-model&quot; element is the root element of an entity model. It defines 
1 or more entity sub-elements as well as the following attributes (default 
values are specified). &quot;msg&quot; sub-elements will be propogated down to this 
all of the &quot;entity&quot; sub-elements

file*             global &quot;file*&quot; attributes. these will be assigned to all 
                  entities for which DAOs are generated unless overriden by 
                  those entities. for details on the meaning of these 
                  attributes, see the &#039;entity&#039; ELEMENT documentation.</pre>

  <h4>Sub Elements</h4>
  <table border="1">
    <tr>
      <th>Sub Element</th>
      <th>Required?</th>
      <th>More than one?</th>
    </tr>
    <tr>
      <td><pre><a href="#element_entity">entity</a></pre></td>
      <td>No</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td><pre><a href="#element_global-views">global-views</a></pre></td>
      <td>No</td>
      <td>No</td>
    </tr>
    <tr>
      <td><pre><a href="#element_index">index</a></pre></td>
      <td>No</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td><pre><a href="#element_msg">msg</a></pre></td>
      <td>No</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td><pre><a href="#element_view-processor">view-processor</a></pre></td>
      <td>No</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td><pre><a href="#element_ws-global">ws-global</a></pre></td>
      <td>No</td>
      <td>Yes</td>
    </tr>
  </table>

  <h4>Attributes</h4>
  <table border="1">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default Value</th>
      <th>Required?</th>
      <th>Comment</th>
    </tr>
    <tr id="element_entity-model_abstract">
      <th><pre>abstract</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>if TRUE (1), then this &quot;entity-model&quot; cannot be used
independently. rather, it is provided as an extendable 
&quot;entity-model&quot; only (see the &quot;extends&quot; element). entities in 
an abstract &quot;entity-model&quot; will not be generated and can 
only be used by specifying &quot;extends&quot; in the enclosing 
&quot;entity&quot; elements
</pre></td>
    </tr>
    <tr id="element_entity-model_auto-pk">
      <th><pre>auto-pk</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>if you do not want to have to explicitely state the primary
key attributes for your persistable entities, you may provide 
this attribute specying a name template for a primary key that
will be automatically added to each persistable entity that 
does not already have a primary key defined. the string 
&quot;{$name}&quot; will automatically be replaced with the entity name 
(with the first letter lowercase). Auto-generated primary key 
attributes will always be sequences. for example: &quot;{$name}Id&quot;
would result in an entity named &quot;Product&quot; automatically 
receiving a primary key attribute &quot;productId&quot; 
</pre></td>
    </tr>
    <tr id="element_entity-model_dao-suffix">
      <th><pre>dao-suffix</pre></th>
      <td><pre>CDATA</pre></td>
      <td><pre>"DAO"</pre></td>
      <td>No</td>
      <td><pre>the file name suffix to use for DAOs (Data Access Objects)
</pre></td>
    </tr>
    <tr id="element_entity-model_db">
      <th><pre>db</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>the key/identifier of the database that should be referenced
for this entity model. if not specified, then the default 
app database will be used. for more information, see the 
app-config DTD documentation for the &quot;db&quot; element
</pre></td>
    </tr>
    <tr id="element_entity-model_ddl-camel-case">
      <th><pre>ddl-camel-case</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>whether or not to use camel case table and column names
in the DDL. these will be an exact copy of the entity and 
attribute names specified in your entity model regardless of 
the naming convention you use and is the default value for 
this attribute. If you prefer the upper case underscore 
separated convention, then set this attribute to 0. However, 
in order for dash separated naming convention to work your 
entity and attribute names MUST STRICTLY adhere to the camel 
case convention including acronyms (e.g. myId and NOT myID)
</pre></td>
    </tr>
    <tr id="element_entity-model_ddl-path">
      <th><pre>ddl-path</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>the app relative path (including file name) where the ddl
should be auto-generated to. if not specified, no ddl will be 
generated. each entity-model is stored to a separate ddl file. 
the ddl that is generated will be dependent on the database 
type used by the app. this file will be overwritten each 
time the entity model is rendered
</pre></td>
    </tr>
    <tr id="element_entity-model_ddl-upper-case">
      <th><pre>ddl-upper-case</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>whether or not the ddl and corresponding column/table names
(if they are not explicitily provided) should be uppercase. 
this only applied if ddl-camel-case is FALSE
</pre></td>
    </tr>
    <tr id="element_entity-model_dtd-camel-case">
      <th><pre>dtd-camel-case</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>whether or not to use camel case entity and attribute names
in the DTD. these will be an exact copy of the entity and 
attribute names specified in your entity model regardless of 
the naming convention you use and is the default value for 
this attribute. If you prefer the more standard lower case 
dash separated convention, then set this attribute to 0. 
However, in order for dash separated naming convention to work 
your entity and attribute names MUST STRICTLY adhere to the 
camel case convention including acronyms (e.g. myId and NOT 
myID)
</pre></td>
    </tr>
    <tr id="element_entity-model_dtd-path">
      <th><pre>dtd-path</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>the app relative path (including file name) where the dtd
should be auto-generated to. if not specified, no dtd will be 
generated. this file will be overwritten each time the entity 
model is rendered. the name of this file (minus path and 
extension and anything following the first underscore) will 
be the DOCTYPE in the generated DTD
</pre></td>
    </tr>
    <tr id="element_entity-model_dtd-uri">
      <th><pre>dtd-uri</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>the uri to the generated dtd. this value will be placed in the
sample DOCTYPE value in the generated dtd. if not specified, 
the file path will be used (preceded by &#039;file://&#039;). it is a 
very good idea to provide a web accessible uri to your dtd if 
you intend to distribute and use it externally
</pre></td>
    </tr>
    <tr id="element_entity-model_file-dir">
      <th><pre>file-dir</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>No API comments</pre></td>
    </tr>
    <tr id="element_entity-model_file-dir-uri">
      <th><pre>file-dir-uri</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>No API comments</pre></td>
    </tr>
    <tr id="element_entity-model_file-handling">
      <th><pre>file-handling</pre></th>
      <td><pre>(db | dir)</pre></td>
      <td><pre>"db"</pre></td>
      <td>No</td>
      <td><pre>No API comments</pre></td>
    </tr>
    <tr id="element_entity-model_file-icon-dir">
      <th><pre>file-icon-dir</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>see &quot;attribute&quot; comments... inherited by nested file type
attributes where &quot;file-icon-icon&quot; is specified, but 
&quot;file-icon-dir&quot; is not specified in either it or its 
enclosing &quot;entity&quot;
</pre></td>
    </tr>
    <tr id="element_entity-model_file-script-rewrite">
      <th><pre>file-script-rewrite</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>No API comments</pre></td>
    </tr>
    <tr id="element_entity-model_file-script-uri">
      <th><pre>file-script-uri</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>No API comments</pre></td>
    </tr>
    <tr id="element_entity-model_generate-path">
      <th><pre>generate-path</pre></th>
      <td><pre>CDATA</pre></td>
      <td><pre>"lib/model"</pre></td>
      <td>No</td>
      <td><pre>the app relative path where auto-generated DAOs and VOs
should be stored. the default path is [app dir]/lib/model
</pre></td>
    </tr>
    <tr id="element_entity-model_header-tpl">
      <th><pre>header-tpl</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>an optional header template to include on top of all generated
source files (value objects and daos). this template will be 
included after the &lt;?php tag
</pre></td>
    </tr>
    <tr id="element_entity-model_ignore-bad-import">
      <th><pre>ignore-bad-import</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>whether or not to ignore listed &#039;import&#039; identifiers
(see below) that are not valid. set this flag to 1 if you 
want to simply skip over imports that do not exist. by default, 
if an import does not exist, an error is logged and the entire 
build process is aborted
</pre></td>
    </tr>
    <tr id="element_entity-model_import">
      <th><pre>import</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>defines one or more entity models that should be included by
this model. Duplicate elements or attributes will be overriden 
by the previous extends &quot;entity-model&quot; or the extending 
&quot;entity-model&quot;. each value in this attribute should be the 
fixed or relative paths to extended &quot;entity-model&quot;. the 
&quot;.xml&quot; extension is not necessary. the search order for the
xml file referenced provided in the SRA_File::getRelativePath() 
api. the import file name should not be prefixed with &#039;etc&#039; if 
it is in the etc directory (that directory will be searched 
first). elements with a &#039;key&#039; attribute will be merged as 
standard numerically indexed arrays. Any import files 
references will NOT cause the entity model to be reloaded when 
they are saved. the entity model will ONLY be reloaded when 
the base entity model xml file is saved. 
</pre></td>
    </tr>
    <tr id="element_entity-model_mysql-table-type">
      <th><pre>mysql-table-type</pre></th>
      <td><pre>CDATA</pre></td>
      <td><pre>"MyISAM"</pre></td>
      <td>No</td>
      <td><pre>MySql specific configuration parameter defining the table type
that should be used when creating ddl and schemas. the default 
type is MyIsam when &quot;ref-integrity&quot; is FALSE, InnoDB when it 
is TRUE. Alternatively, BDB, or some other supported table 
type may be used. However, if you select a type that does not 
support referential integrity constraints (any type besides 
InnoDB for mysql), but set ref-integrity to TRUE, there will 
be serious data integrity problems due to the fact that 
records will not be updated correctly
</pre></td>
    </tr>
    <tr id="element_entity-model_ref-integrity">
      <th><pre>ref-integrity</pre></th>
      <td><pre>(db | app)</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>defines at what layer referential integrity should be
enforced. the two layers that this may occur in are either the 
application or database layers. enforcing referential integrity 
at the database layer is always the best choice. however, if 
your database does not support referential integrity (i.e. 
MySql with anything but InnoDB tables), then referential 
integrity must be enforced at the application layer. the two 
disadvantages to this approach are 1) performance: the 
database is more efficient in handling referential integrity, 
and 2) data integrity: application layer referential integrity 
is not guaranteed to work in all cases. if database 
referential integrity is used, &quot;sync-schema&quot; is TRUE, and 
MySql is used, the tables that are created will be InnoDB 
instead of the default MyIsam unless another type has been 
specified by &quot;mysql-table-type&quot; (warning: only InnoDB supports 
referential integrity in mysql in the most recent version 5.0). 
The default value for this attribute is &quot;db&quot; for any database 
other than MySQL and &quot;app&quot; otherwise. 
</pre></td>
    </tr>
    <tr id="element_entity-model_nested-queries-ok">
      <th><pre>nested-queries-ok</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"1"</pre></td>
      <td>No</td>
      <td><pre>whether or not the database server supports nested queries.
prior to MySql 4.1, nested queries were not supported. if not 
supported, some database operations may be slower
</pre></td>
    </tr>
    <tr id="element_entity-model_resources">
      <th><pre>resources</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>an alternate properties file containing the resources for this
entity model. if not specified, the default application 
resource bundle will be used:
(etc/l10n/app.properties)
If specified, all entities in the model will read their 
resources from there (unless the entity specifies otherwise). 
Entities will still have access to the default app 
resource bundle because it will be merged with this bundle. 
multiple files can be separated using a space character as the 
delimiter
</pre></td>
    </tr>
    <tr id="element_entity-model_sync-schema">
      <th><pre>sync-schema</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>whether or not the database schema should be synced every
                  time that a change to the entity model is made. this means 
                  that whenever a new table, column or index is created, it 
                  will also be created in the database according to the 
                  definition provided for it in the entity model. there are two 
                  ways through which table modifications may occur. 1) if the 
                  table has no data, it will simply be dropped and re-created, 
                  or 2) if the table does have data (1 or more rows), then any 
                  new columns will be added, but removed removed or changed 
                  columns will not be altered and must be manually updated. for 
                  example, if a varchar column length was changed (determined by 
                  the &quot;maxLength&quot; attribute constraint) in a table that already 
                  contains data, that change would not be automatically applied 
                  to the table. if the table contained no data, however, the 
                  table would simply be dropped and re-created. the database 
                  user MUST have DROP, CREATE and ALTER privileges in order to 
                  use this feature. By default, this feature is enabled. Indexes 
                  can only be auto created when the table is created, meaning 
                  once a table has data, any new indexes must be manually created 
                  </pre></td>
    </tr>
    <tr id="element_entity-model_sys-err-resource">
      <th><pre>sys-err-resource</pre></th>
      <td><pre>Resource</pre></td>
      <td><pre>"error.sys"</pre></td>
      <td>No</td>
      <td><pre>key in the application SRA_ResourceBundle that contains a string
 to use for system errors
 </pre></td>
    </tr>
    <tr id="element_entity-model_vo-suffix">
      <th><pre>vo-suffix</pre></th>
      <td><pre>CDATA</pre></td>
      <td><pre>"VO"</pre></td>
      <td>No</td>
      <td><pre>the file name suffix to use for VOs (Value Objects)
</pre></td>
    </tr>
    <tr id="element_entity-model_ws-db">
      <th><pre>ws-db</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>may be used in conjunction with the &quot;entity&quot; &quot;ws-db-name&quot;
attribute and in place of the &quot;db&quot; attribute. this attribute 
specifies the URI to another server providing web services 
that will act as the persistence layer for 1 or more of the 
entities in this model. meaning, instead of using a database 
as the persistence layer, the entity dao will utilize web 
services provided by this server to CRUD the entity. if this 
server requires authentication, those credentials may be 
specified in this URI utilizing the format:
http://[user]:[pswd]@[URI]. Note: each entity MUST also 
provide the &quot;ws-db-name&quot; attribute in order to utilize web 
service persistence. Alternatively, this attribute may be set 
to &quot;1&quot; signifying that the URI will be provided at runtime 
using the $dao-&gt;setWsDb($uri) method
</pre></td>
    </tr>
    <tr id="element_entity-model_ws-api-css-uri">
      <th><pre>ws-api-css-uri</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>optional uri to a css file to use to format sra-ws-gateway.php
generated api documentation
</pre></td>
    </tr>
    <tr id="element_entity-model_ws-gateway-rewrite">
      <th><pre>ws-gateway-rewrite</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>whether or not the &quot;ws-gateway-uri&quot; has an Apache RewriteRule
allowing use of more simple web service uris

to enable this feature simply add the following to the 
.htaccess file in the app web directory:

RewriteEngine On
RewriteRule ^{ws-gateway-uri}/(.*)/(.*)/(.*)/(.*)/(.*) /{uri to &quot;sra-ws-gateway.php&quot;}?ws1=$1&amp;ws2=$2&amp;ws3=$3&amp;ws4=$4&amp;ws5=$5
RewriteRule ^{ws-gateway-uri}/(.*)/(.*)/(.*)/(.*) /{uri to &quot;sra-ws-gateway.php&quot;}?ws1=$1&amp;ws2=$2&amp;ws3=$3&amp;ws4=$4
RewriteRule ^{ws-gateway-uri}/(.*)/(.*)/(.*) /{uri to &quot;sra-ws-gateway.php&quot;}?ws1=$1&amp;ws2=$2&amp;ws3=$3
RewriteRule ^{ws-gateway-uri}/(.*)/(.*) /{uri to &quot;sra-ws-gateway.php&quot;}?ws1=$1&amp;ws2=$2
RewriteRule ^{ws-gateway-uri}/(.*) /{uri to &quot;sra-ws-gateway.php&quot;}?ws1=$1
RewriteRule ^{ws-gateway-uri} /{uri to &quot;sra-ws-gateway.php&quot;}

where the wsN parameters can be the following values:
  ws1: ws-app, ws-request-xml
  ws2: ws, ws-doc
  ws3: ws-action, ws-doc, ws-format
  ws4: ws-id, ws-format
  ws5: ws-format
and the possible parameter combinations are the following:
  ws-app=&amp;ws-request-xml=
    invoke a web service request using the request xml 
    &quot;ws-request-xml&quot;
  ws-app=&amp;ws=
    invoke web service &quot;ws&quot;
  ws-app=&amp;ws=&amp;ws-action=
    invoke action &quot;ws-action&quot; of web service &quot;ws&quot;
  ws-app=&amp;ws=&amp;ws-action=&amp;ws-id=
    invoke action &quot;ws-action&quot; of web service &quot;ws&quot; for entity 
    with primary key &quot;ws-id&quot;
  ws-app=&amp;ws=&amp;ws-action=&amp;ws-format=
    invoke action &quot;ws-action&quot; of web service &quot;ws&quot; and output 
    results in &quot;ws-format&quot;
  ws-app=&amp;ws=&amp;ws-action=&amp;ws-id=&amp;ws-format=
    invoke action &quot;ws-action&quot; of web service &quot;ws&quot; for entity 
    with primary key &quot;ws-id&quot; and output results in &quot;ws-format&quot;
  ws-app=&amp;ws-doc=
    show documentation for all app web services
  ws-app=&amp;ws=&amp;ws-doc=
    show documentation for web service &quot;ws&quot;
</pre></td>
    </tr>
    <tr id="element_entity-model_ws-gateway-uri">
      <th><pre>ws-gateway-uri</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>the uri to the sierra/lib/model/sra-ws-gateway.php script.
this attribute is required when your model defines 1 or more 
web services using the &quot;ws-global&quot; or &quot;ws&quot; 
elements


</pre></td>
    </tr>
  </table>

 <hr />  <a href="#top" style="float:right">Top</a>
  <h3 id="element_entity">entity</h3>
  <pre>The &quot;entity&quot; element describes the characteristics of a single Entity in an 
application&#039;s object model. This includes attributes, relational 
characteristics, and validation. An entity must contain at least 1 attribute. 
&quot;msg&quot; sub-elements will be propogated down to this entity&#039;s attributes. Every 
persistable entity MUST have at least 1 non-sequence attribute in its primary 
database table in order for inserts to be able to be performed</pre>
  <h4>Used In</h4>
  <ul>
    <li><a href="#element_entity-model">entity-model</a></li>
  </ul>

  <h4>Sub Elements</h4>
  <table border="1">
    <tr>
      <th>Sub Element</th>
      <th>Required?</th>
      <th>More than one?</th>
    </tr>
    <tr>
      <td><pre><a href="#element_aop">aop</a></pre></td>
      <td>No</td>
      <td>No</td>
    </tr>
    <tr>
      <td><pre><a href="#element_attribute">attribute</a></pre></td>
      <td>No</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td><pre><a href="#element_default-view">default-view</a></pre></td>
      <td>No</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td><pre><a href="#element_msg">msg</a></pre></td>
      <td>No</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td><pre><a href="#element_validate">validate</a></pre></td>
      <td>No</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td><pre><a href="#element_view">view</a></pre></td>
      <td>No</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td><pre><a href="#element_ws">ws</a></pre></td>
      <td>No</td>
      <td>Yes</td>
    </tr>
  </table>

  <h4>Attributes</h4>
  <table border="1">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default Value</th>
      <th>Required?</th>
      <th>Comment</th>
    </tr>
    <tr id="element_entity_key">
      <th><pre>key</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>the name of the entity. this will translate to the class/file
name of the generated VO. Entity names should utilize the 
Camel Case naming convention under which the first name 
character is upper case and each new word in the name is 
capitalized:
e.g. ThisIsMyEntity
</pre></td>
    </tr>
    <tr id="element_entity_abstract">
      <th><pre>abstract</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>whether or not this entity is abstract. abstract entities will
not be generated, and can only be used as extendable entities 
within an &quot;entity-model&quot;. if the enclosing &quot;entity-model&quot; is 
abstract, then all &quot;entity&quot; elements in that model will also 
implicitely be &quot;abstract&quot;
</pre></td>
    </tr>
    <tr id="element_entity_api-resource">
      <th><pre>api-resource</pre></th>
      <td><pre>Resource</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>key in the application SRA_ResourceBundle that contains a string
 that should be used in the generated api documentation for 
 this entity
 </pre></td>
    </tr>
    <tr id="element_entity_column-postfix">
      <th><pre>column-postfix</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>this value will automatically be added to the end of
each of this entity&#039;s persistable attributes column names 
unless those names are explicitily provided. cannot be used in 
conjunction with ws-db
</pre></td>
    </tr>
    <tr id="element_entity_column-prefix">
      <th><pre>column-prefix</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>this value will automatically be added to the beginning of
each of this entity&#039;s persistable attributes column names 
unless those names are explicitily provided. cannot be used in 
conjunction with ws-db
</pre></td>
    </tr>
    <tr id="element_entity_constraint">
      <th><pre>constraint</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>an sql constraint to apply defining active/inactive records
in the entity table. if not specified, all records will be 
considered active. this would most likely be the inverse of 
the &#039;on-delete-update&#039; attribute. cannot be used in 
conjunction with ws-db
</pre></td>
    </tr>
    <tr id="element_entity_dao">
      <th><pre>dao</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>if an existing DAO already exists, then this should be the
app relative path to that DAO (without the file 
extension). For example, &quot;daos/MyDao&quot;. In this case, only 
the VO class will be generated. the &#039;lib&#039; path prefix is 
optional if the file is in the standard app lib directory
</pre></td>
    </tr>
    <tr id="element_entity_dao-extends">
      <th><pre>dao-extends</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>the app relative path to a PHP class file that the
generated DAO should extend. for example: &quot;lib/MyDao&quot; (do not 
include file extension). the &#039;lib&#039; path prefix is optional if 
the file is in the standard app lib directory
</pre></td>
    </tr>
    <tr id="element_entity_extends">
      <th><pre>extends</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>the name of another entity in the enclosing &quot;entity-model&quot;
or an extending &quot;entity-model&quot; that this entity extends. the 
resulting generated 
VO class will not &quot;extend&quot; this class, but the attributes 
specified in that class will be merged into the attributes 
specified for this class. if duplicate attributes exist, then 
the extending entity attribute properties will override those 
of the extended
</pre></td>
    </tr>
    <tr id="element_entity_file-dir">
      <th><pre>file-dir</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>the fixed or relative directory where files should be stored.
if relative, the following search order will be used:

  {app-dir}
  {sierra-dir}
  
the web server must have read/write access to this directory. 
the DAOs will handle the unique naming of files. 
file extensions will automatically be appended to the file 
names to facilitate browser mime-type recognition. the 
trailing forward slash should not be added to this attribute.
it is the implementor&#039;s responsibility to provide security on 
this directory
</pre></td>
    </tr>
    <tr id="element_entity_file-dir-uri">
      <th><pre>file-dir-uri</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>the web server recognizable uri to the &quot;file-dir&quot; identified
 </pre></td>
    </tr>
    <tr id="element_entity_file-handling">
      <th><pre>file-handling</pre></th>
      <td><pre>(db | dir)</pre></td>
      <td><pre>"db"</pre></td>
      <td>No</td>
      <td><pre>determines how &quot;is-file&quot; attributes in this entity should be
stored. if not specified, the enclosing &quot;entity-model&quot; 
&quot;file-handling&quot; will be used. the following handling methods 
are supported:

&quot;db&quot; : files will be stored in the entity/attribute database 
table. if this handling method is used, the &quot;file-script-uri&quot; 
attributes MUST be specified as well. the database column type 
for this file handling method must be BLOB (BYTEA in postgres)
this is the default &quot;file-handling&quot; method. If &quot;type&quot; is not 
set for a given file attribute, that type will automatically 
be set to SRA_DATA_TYPE_BLOB.

&quot;dir&quot; : files will be stored in the local file system. if this 
handling method is used, the &quot;file-dir&quot; and &quot;file-dir-uri&quot; 
attributes MUST be specified as well. the database column type 
for this file handling method must be VARCHAR(255) or CHAR(255). 
If &quot;type&quot; is not set for a given file attribute, that type 
will automatically be set to SRA_DATA_TYPE_STRING with a 
&quot;max-length&quot; of 255
</pre></td>
    </tr>
    <tr id="element_entity_file-icon-dir">
      <th><pre>file-icon-dir</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>see &quot;attribute&quot; comments... inherited by nested file type
attributes where &quot;file-icon-icon&quot; is specified, but 
&quot;file-icon-dir&quot; is not
</pre></td>
    </tr>
    <tr id="element_entity_file-script-rewrite">
      <th><pre>file-script-rewrite</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>whether or not the &quot;file-script-uri&quot; is an Apache RewriteRule
                  It is better to use this option because it will result in 
                  more browser compatible mime-type recognition for file 
                  downloads (the uri will be in a friendly format such as:
                  /{file-script-uri}/{encrypted id}/{file name w/ extension}
                  rather than: 
                  /{file-script-uri}?eid={encrypted id}
                  
                  To enable this feature simply add the following to the 
                  .htaccess file in the app web directory:
                  
                  RewriteEngine On
                  RewriteRule ^{file-script-uri}/(.*)/(.*) /{uri to &quot;sra-file-renderer.php&quot;}?eid=$1
</pre></td>
    </tr>
    <tr id="element_entity_file-script-uri">
      <th><pre>file-script-uri</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>the app specific uri to the &quot;sra-file-renderer.php&quot; file (a
script that includes that file, a copy or a symlink) provided 
in the lib/model/ directory.
</pre></td>
    </tr>
    <tr id="element_entity_ignore-bad-import">
      <th><pre>ignore-bad-import</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>whether or not to ignore listed &#039;on-create-import&#039; identifiers
(see below) that are not valid. set this flag to 1 if you 
want to simply skip over imports that do not exist. by default, 
if an import does not exist, an error is logged
</pre></td>
    </tr>
    <tr id="element_entity_is-global">
      <th><pre>is-global</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>when true, all of this entity&#039;s attributes will have is-global
automatically set to true (unless a value has been explicitely 
set for that attribute)
</pre></td>
    </tr>
    <tr id="element_entity_match-user-id">
      <th><pre>match-user-id</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>the name of the entity attribute that the user-id should match
in order for a user to be able to &quot;get&quot; any attribute in this 
entity. this value will be passed to the &quot;getAttribute&quot; method 
and the results compared. if the return value is an array, 
then the user will only be able to access the attribute if 
their user id exists in that array. in order to use this 
feature, the SRA_Authenticator::getUserId method must return a 
user id. use this configuration to restrict access to db 
stored files. if a security violation is detected, the return 
value of the corresponding getter/setter will be aborted 
(getter returns null) and the activity will be logged
</pre></td>
    </tr>
    <tr id="element_entity_null-db-empty-str">
      <th><pre>null-db-empty-str</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>whether or not empty string (&#039;&#039;) should be used in place of
NULL for any of this entitys&#039; attributes when database edits 
occur and the value of that attribute is NULL. this will also 
have the reverse effect of setting the attribute values to 
NULL whenever they are set to an emtpy string using the 
attribute set method. cannot be used in conjunction with ws-db
</pre></td>
    </tr>
    <tr id="element_entity_on-create-import">
      <th><pre>on-create-import</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>the path to a file containing newline separated sql statements that
should be loaded dynamically whenever the table this entity 
uses is created. this will ONLY be used in conjunction with 
the &#039;sync-schema&#039; option set to true. all imports are performed 
after ALL missing tables have been created, so this file may 
contain references to other tables as well. the search path 
for this file will be first the &#039;etc&#039; directory for the 
platform, followed by the normal platform relative search 
traversal. this value can contain multiple space separated 
values. Invalid files will be skipped and an error logged 
unless ignore-bad-import (above) is set to true. comments can 
be delimited in this file starting with /* and ending with */
cannot be used in conjunction with ws-db
</pre></td>
    </tr>
    <tr id="element_entity_on-delete-update">
      <th><pre>on-delete-update</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>an alternate update criteria for the entity table when a
record is deleted. for example, &quot;ENABLED=0&quot;. this value will 
be used in the &quot;SET&quot; clause of the generated SQL update query. 
if not specified, the record will simply be deleted. if specified, 
you will also most likely need to specify a &quot;constraint&quot; value 
that is the inverse of the on-delete-update criteria. cannot 
be used in conjunction with ws-db
</pre></td>
    </tr>
    <tr id="element_entity_order-by">
      <th><pre>order-by</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>an optional &#039;ORDER BY&#039; sql value for the DAO findAll method
 This value will be the name of a column in the entity &#039;table&#039; 
 specified upon which ordering should be based. Multiple 
 column name may be specified separated by commas and 
 optionally followed by &#039;ASC&#039; or &#039;DESC&#039;. cannot be used in 
 conjunction with ws-db
 </pre></td>
    </tr>
    <tr id="element_entity_primary-key">
      <th><pre>primary-key</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>the identifier or the attribute that is the primary key (unique
identifier) for this entity. every persistable entity MUST have 
a primary key designated. 
</pre></td>
    </tr>
    <tr id="element_entity_propagate-update">
      <th><pre>propagate-update</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>whether or not &#039;entity&#039; type attributes should be scanned for
changes, and updated when updates to this entity are made. 
cannot be used in conjunction with ws-db
</pre></td>
    </tr>
    <tr id="element_entity_render-append">
      <th><pre>render-append</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>a space separated list of non-standard attribute names and
method names the values of which should be included in xml or 
json output rendering of this entity using the toJson/toXml 
methods or the built-in json/xml views. for example, to have 
the return value of invoking the aop introduction methods 
&quot;getNumChildren&quot; and &quot;getParent&quot; in the rendered output, the 
value of this attribute would be &quot;getNumChildren getParent&quot;. 
If the return value of any appended values is an entity 
instance, the rendered xml will not validate against the dtd 
for the entity model
</pre></td>
    </tr>
    <tr id="element_entity_render-exclude">
      <th><pre>render-exclude</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>attributes that should always be excluded from the xml or
json output rendering of this entity using the toJson/toXml 
methods or the built-in json/xml views. this should be a space 
separated list of attribute names. these attributes will NEVER 
be included in the json/xml rendering of this entity
</pre></td>
    </tr>
    <tr id="element_entity_render-include">
      <th><pre>render-include</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>the opposite of &#039;render-exclude&#039;. ONLY these attributes and
 those listed in render-append will be rendered
 </pre></td>
    </tr>
    <tr id="element_entity_resource">
      <th><pre>resource</pre></th>
      <td><pre>Resource</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>key in the application SRA_ResourceBundle that contains a string
 or name describing this entity. If not specified, the 
 following search order will be used to determine the correct 
 resource key:
   {entity name}
   entity.{entity name}
   text.{entity name}
 </pre></td>
    </tr>
    <tr id="element_entity_resources">
      <th><pre>resources</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>an alternate properties file containing the resources for this
entity. if not specified in the entity, or the enclosing 
entity-model, the default application resource bundle will be 
used. Entities will still have access to the default app 
resource bundle because it will be merged with this bundle.
multiple files can be separated using a space character as the 
delimiter
</pre></td>
    </tr>
    <tr id="element_entity_resource-help">
      <th><pre>resource-help</pre></th>
      <td><pre>Resource</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>key in the application SRA_ResourceBundle that contains a string
 or name providing help for this entity
 </pre></td>
    </tr>
    <tr id="element_entity_skip-persistence">
      <th><pre>skip-persistence</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>if TRUE, then this entity will be non-persistent, meaning no
DAO will be generated for it. additionally, auto-pk, if 
specified, will not be applied to non-persistent entities
</pre></td>
    </tr>
    <tr id="element_entity_skip-wsdl">
      <th><pre>skip-wsdl</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>whether or not to skip adding this entity to the wsdl
generated by the web services gateway
</pre></td>
    </tr>
    <tr id="element_entity_table">
      <th><pre>table</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>if the &#039;dao&#039; attribute has not been defined, this method
identifies the application database table where this entity&#039;s 
base attributes are stored. if neither &#039;table&#039; nor &#039;dao&#039; is 
defined, and &quot;skip-persistence&quot; is not true, the table name 
will be auto-set based on the entity-model camel-case-ddl 
setting. cannot be used in conjunction with ws-db
</pre></td>
    </tr>
    <tr id="element_entity_unit-test">
      <th><pre>unit-test</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>the app relative or absolute path to a php class file that
extends test/SRA_TestCase.php and provides the unit testing 
for this entity. an instance of this class can be obtained 
utilizing the VO::getUnitTestInstance method. the name of the
class should be the same as the name of the file minus the 
.php extension. the .php extension is not required for this 
attribute
</pre></td>
    </tr>
    <tr id="element_entity_vo-extends">
      <th><pre>vo-extends</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>the app relative path to a PHP class file that the
generated VO should extend. for example: &quot;lib/MyVo&quot; (do not 
include file extension). the &#039;lib&#039; path prefix is optional if 
the file is in the standard app lib directory
</pre></td>
    </tr>
    <tr id="element_entity_ws-db">
      <th><pre>ws-db</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>may be used to override the enclosing &quot;entity-model&quot; attribute
of the same name
</pre></td>
    </tr>
    <tr id="element_entity_ws-db-name">
      <th><pre>ws-db-name</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>the name of the web service provided by &quot;ws-db&quot; which allows
persistence for this entity. if specified, a different dao 
template (dao-ws.tpl) will be used for this entity and it will
NOT be persisted in the database, but instead using the 
&quot;ws-db&quot;. In order for full CRUD logic to be available, this 
web service must provide all functionality: create, retrieve, 
update, delete (see the &quot;ws&quot; element for more info). 
otherwise, an error will be generated when those corresponding
CRUD methods are utilized from the generated DAO


</pre></td>
    </tr>
  </table>

 <hr />  <a href="#top" style="float:right">Top</a>
  <h3 id="element_global-views">global-views</h3>
  <pre>The &quot;global-views&quot; element contains one or more &#039;view&#039; configurations that may 
be used throughout the model in entity and attribute configurations. For 
example, a global view may be created for displaying links that may then be 
referenced in any link type attributes. it also may define default view for 
attributes based on the type


</pre>
  <h4>Used In</h4>
  <ul>
    <li><a href="#element_entity-model">entity-model</a></li>
  </ul>

  <h4>Sub Elements</h4>
  <table border="1">
    <tr>
      <th>Sub Element</th>
      <th>Required?</th>
      <th>More than one?</th>
    </tr>
    <tr>
      <td><pre><a href="#element_default-view">default-view</a></pre></td>
      <td>No</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td><pre><a href="#element_view">view</a></pre></td>
      <td>Yes</td>
      <td>Yes</td>
    </tr>
  </table>

  <h4>Attributes</h4>
  <p>This element does not have any attributes</p>

 <hr />  <a href="#top" style="float:right">Top</a>
  <h3 id="element_aop">aop</h3>
  <pre>The &quot;aop&quot; element is used to apply cross-cutting concerns to classes derived 
from this entity-model. these are secondary requirements that will be 
dynamically attached to the class source files. for more an introduction to AOP 
programming, do a google search for &quot;AOP Introduction&quot;. For our purposes, the 
aop terms you will need to understand are as follows:

advice:       the code to attach to the joinpoints as well as when that should 
              occur (either before the method starts, or after it ends)
              
aspect:       the combination of a pointcut and advice. as aspect will result in 
              code modification at build time
              
introduction: an additional include, attribute or method that should be added to 
              a class
              
pointcut:     a set of join points where advice should be applied

</pre>
  <h4>Used In</h4>
  <ul>
    <li><a href="#element_entity">entity</a></li>
  </ul>

  <h4>Sub Elements</h4>
  <table border="1">
    <tr>
      <th>Sub Element</th>
      <th>Required?</th>
      <th>More than one?</th>
    </tr>
    <tr>
      <td><pre><a href="#element_advice">advice</a></pre></td>
      <td>No</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td><pre><a href="#element_aspect">aspect</a></pre></td>
      <td>No</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td><pre><a href="#element_introduction">introduction</a></pre></td>
      <td>No</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td><pre><a href="#element_pointcut">pointcut</a></pre></td>
      <td>No</td>
      <td>Yes</td>
    </tr>
  </table>

  <h4>Attributes</h4>
  <p>This element does not have any attributes</p>

 <hr />  <a href="#top" style="float:right">Top</a>
  <h3 id="element_advice">advice</h3>
  <pre>The &quot;advice&quot; element defines cross-cutting code. this is code that is applied as
an aspect to a method in a class that is derived from this entity model. advice 
may be applied to multiple such methods. the body of this element is the code 
that should be applied. this code may perform such activities as logging, 
validation, additional logic, etc. It has full access to the parameters to that 
method invocation as well as the object instance variables and any other data 
and/or code accessible within the current running php process. the code may 
additionally pre-maturely exit the method using return.</pre>
  <h4>Used In</h4>
  <ul>
    <li><a href="#element_aop">aop</a></li>
  </ul>

  <h4>Sub Elements</h4>
  <table border="1">
    <tr>
      <th>Sub Element</th>
      <th>Required?</th>
      <th>More than one?</th>
    </tr>
    <tr>
      <td><pre>#PCDATA</pre></td>
      <td>Yes</td>
      <td>No</td>
    </tr>
  </table>

  <h4>Attributes</h4>
  <table border="1">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default Value</th>
      <th>Required?</th>
      <th>Comment</th>
    </tr>
    <tr id="element_advice_key">
      <th><pre>key</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>the unique idnetifier for this advice. used to reference it in
an aspect
</pre></td>
    </tr>
    <tr id="element_advice_when">
      <th><pre>when</pre></th>
      <td><pre>(before | after)</pre></td>
      <td><pre>"before"</pre></td>
      <td>No</td>
      <td><pre>when the advice should be applied. &#039;before&#039; signifies that it
will be attached before any other code in that method, while 
&#039;after&#039; signifies that it will be attached after all the other 
code in that method has been executed (before the return of 
course).

</pre></td>
    </tr>
  </table>

 <hr />  <a href="#top" style="float:right">Top</a>
  <h3 id="element_aspect">aspect</h3>
  <pre>The &quot;aspect&quot; element is the glue between advice and pointcuts. it defines the 
code to be attached (advice) as well as the location(s) where that code should 
be attached (pointcut). the advice and pointcut may either be defined in this 
element (if never will never be used in another aspect) or in external 
referenced advice and pointcut elements</pre>
  <h4>Used In</h4>
  <ul>
    <li><a href="#element_aop">aop</a></li>
  </ul>

  <h4>Sub Elements</h4>
  <table border="1">
    <tr>
      <th>Sub Element</th>
      <th>Required?</th>
      <th>More than one?</th>
    </tr>
    <tr>
      <td><pre>#PCDATA</pre></td>
      <td>Yes</td>
      <td>No</td>
    </tr>
  </table>

  <h4>Attributes</h4>
  <table border="1">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default Value</th>
      <th>Required?</th>
      <th>Comment</th>
    </tr>
    <tr id="element_aspect_key">
      <th><pre>key</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>the unique identifier for this aspect
 </pre></td>
    </tr>
    <tr id="element_aspect_advice">
      <th><pre>advice</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>reference to the advice definition to apply in this aspect. if
the advice will only be used once in this aspect, then the 
value of this element can be used to specify that advice
</pre></td>
    </tr>
    <tr id="element_aspect_comment">
      <th><pre>comment</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>an optional aspect comment. this will be inserted above the
code resulting from this aspect
</pre></td>
    </tr>
    <tr id="element_aspect_pointcut">
      <th><pre>pointcut</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>reference to the pointcut definition to apply in this aspect.
if the pointcut will only be used once in this aspect, then 
the value of this attribute may be the joinpoints for the 
pointcut
</pre></td>
    </tr>
    <tr id="element_aspect_when">
      <th><pre>when</pre></th>
      <td><pre>(before | after)</pre></td>
      <td><pre>"before"</pre></td>
      <td>No</td>
      <td><pre>if &#039;advice&#039; is not a reference, this attribute can be specified
otherwise it is taken from the referenced advice

</pre></td>
    </tr>
  </table>

 <hr />  <a href="#top" style="float:right">Top</a>
  <h3 id="element_introduction">introduction</h3>
  <pre>The &quot;introduction&quot; element defines an additional include, attribute or method 
that should be attached to a class. for method introductions, the body of this 
element should define the method body code</pre>
  <h4>Used In</h4>
  <ul>
    <li><a href="#element_aop">aop</a></li>
  </ul>

  <h4>Sub Elements</h4>
  <table border="1">
    <tr>
      <th>Sub Element</th>
      <th>Required?</th>
      <th>More than one?</th>
    </tr>
    <tr>
      <td><pre>#PCDATA</pre></td>
      <td>Yes</td>
      <td>No</td>
    </tr>
  </table>

  <h4>Attributes</h4>
  <table border="1">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default Value</th>
      <th>Required?</th>
      <th>Comment</th>
    </tr>
    <tr id="element_introduction_key">
      <th><pre>key</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>the unique identifier for this introduction
</pre></td>
    </tr>
    <tr id="element_introduction_class">
      <th><pre>class</pre></th>
      <td><pre>(dao | vo)</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>the entity class that this introduction applies to. this is
either the dao (data access object) or vo (value object)
</pre></td>
    </tr>
    <tr id="element_introduction_type">
      <th><pre>type</pre></th>
      <td><pre>(attribute | constant | include | method)</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>the type of introduction this is. an introduction can be
either an additional php include, class attribute or class 
method
</pre></td>
    </tr>
    <tr id="element_introduction_value">
      <th><pre>value</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>the value of the introduction. this attribute assumes
different meanings based on the type. for attributes, this is 
the name of the attribute (no $ needed) + an optional default 
value (i.e. name or name=&quot;Jason&quot;). for includes, this is 
the path to the source file to include (relative or fixed). 
for methods, this is the method signature (name and 
parameters - i.e. myNewMethod($param1)) - $ are required for 
parameters. to return by reference, simply prefix the method 
name with $. for constants, the value will be the name of the 
constant, followed by an equals sign and the value for that 
constant (strings should be enclosed in quotes)

</pre></td>
    </tr>
  </table>

 <hr />  <a href="#top" style="float:right">Top</a>
  <h3 id="element_pointcut">pointcut</h3>
  <pre>The &quot;pointcut&quot; element defines a set of join points where advice should be 
applied. it is referenced in aspects.</pre>
  <h4>Used In</h4>
  <ul>
    <li><a href="#element_aop">aop</a></li>
  </ul>

  <h4>Sub Elements</h4>
  <p>This element does not have any sub-elements</p>

  <h4>Attributes</h4>
  <table border="1">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default Value</th>
      <th>Required?</th>
      <th>Comment</th>
    </tr>
    <tr id="element_pointcut_key">
      <th><pre>key</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>the unique identifier for this aspect
</pre></td>
    </tr>
    <tr id="element_pointcut_joinpoints">
      <th><pre>joinpoints</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>space separated list of method names. each value may be either
the full method name (minus parens and param definition), or 
a ereg expression representing 1 or more method names. 
these values may optionally be prefixed with the class type 
identifier (dao|vo) - for example, &quot;setName&quot; would 
reference the method setName in any entity class while 
&quot;vo.setName&quot; would only reference the method setName in the 
value object for this entity. joinpoints may also be 
references to methods attached to a class by means of an 
introduction

</pre></td>
    </tr>
  </table>

 <hr />  <a href="#top" style="float:right">Top</a>
  <h3 id="element_attribute">attribute</h3>
  <pre>The &quot;attribute&quot; element describes a single attribute in an entity. attributes 
can have any type of associative relationship to the entity such as 1..1, 1..*, 
0..* etc. Relational attributes reference other entities. This element also 
describes validation constraints and o/r mapping details.</pre>
  <h4>Used In</h4>
  <ul>
    <li><a href="#element_entity">entity</a></li>
  </ul>

  <h4>Sub Elements</h4>
  <table border="1">
    <tr>
      <th>Sub Element</th>
      <th>Required?</th>
      <th>More than one?</th>
    </tr>
    <tr>
      <td><pre><a href="#element_attr-mapping">attr-mapping</a></pre></td>
      <td>No</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td><pre><a href="#element_msg">msg</a></pre></td>
      <td>No</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td><pre><a href="#element_thumbnail">thumbnail</a></pre></td>
      <td>No</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td><pre><a href="#element_var">var</a></pre></td>
      <td>No</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td><pre><a href="#element_view">view</a></pre></td>
      <td>No</td>
      <td>Yes</td>
    </tr>
  </table>

  <h4>Attributes</h4>
  <table border="1">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default Value</th>
      <th>Required?</th>
      <th>Comment</th>
    </tr>
    <tr id="element_attribute_key">
      <th><pre>key</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>the name of the attribute. this will translate to the name of
the attribute in the generated VO (preceded by _) as well as 
to the name of the generated getter/setter methods in the 
generated VO. Attribute names should utilize the Camel Case 
naming convention under which the first name character is 
lower case and each new word in the name is capitalized:
e.g. thisIsMyVariable
</pre></td>
    </tr>
    <tr id="element_attribute_aggregate">
      <th><pre>aggregate</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>whether or not the attributes of an entity type attribute
should be aggregated into the enclosing entity. if this 
attribute is also mapped (using &quot;mapped&quot; or nested 
&quot;attr-mapping&quot;), then only those attributes included in the 
mapping will be aggregated. the aggregated attributes may be 
prefixed (see &quot;aggregate-prefix&quot;) and will be treated 
as equals in terms of functionality within the class. this 
functionality includes the get/set/add/remove methods as well 
as supporting methods. nested aggregate attributes are not 
supported. when using this feature in your entity model, be 
sure to avoid duplicate attribute names which will result in 
syntax errors in the generated classes. aggregate attributes 
will not be included in xml rendering in the immediate entity.
you will also not be able to render these attribute directly 
using the enclosing entity&#039;s renderAttribute method. 
additionally, the parseString method does not support 
immediate mapping of these attributes. this option is not 
available when the enclosing entity uses a ws-db
  </pre></td>
    </tr>
    <tr id="element_attribute_aggregate-prefix">
      <th><pre>aggregate-prefix</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>an optional prefix value for aggregated attributes. when
applied, the first letter of the aggregate attributes will 
be converted to uppercase automatically in order to preserve 
the hobble-case standard within the generated classes. this 
option is not available when the enclosing entity uses a ws-db
</pre></td>
    </tr>
    <tr id="element_attribute_api-resource">
      <th><pre>api-resource</pre></th>
      <td><pre>Resource</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>key in the application SRA_ResourceBundle that contains a string
 that should be used in the generated api documentation for 
 this entity. If this attribute utilizes the &quot;options&quot; 
 validator your app SRA_ResourceBundle should also include a 
 string for the key: entity-model.multiple_options_separated_by_a_space
 (SRA_ENTITY_MODELER_MULTIPLE_OPTIONS_API_RESOURCE constant in 
 the SRA_EntityModeler class) which is included in the api comments 
 for that attribute identifying that multiple options will be 
 stored in the database, or xml as space separated values
 </pre></td>
    </tr>
    <tr id="element_attribute_cardinality">
      <th><pre>cardinality</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>defines relational attribute constraints defining the upper
and lower bounds of the # of attributes of this type that an 
entity may have. For example: 0..* signifies zero or more 
(no upper bound) attributes of this type. attributes with an 
upper bound greater than 1 will be arrays of the corresponding 
&#039;type&#039;. if the upper bound is greater than 1, the &#039;table&#039; 
must be different from the entity table unless the attribute 
is of a scalar type. for the latter, either an external or the 
entity table may be used to store the attribute. if the entity 
table is used, each value in the scalar array will be stored 
in the column representing this attribute separated by the 
delimiter |#|. the column data type will be text regardless of 
the scalar attribute type in this case. if a &quot;max-length&quot; 
constraint is set for this attribute, be sure that length is 
sufficient to store all of the values + the delimiter values. 
if not specified, the column data type will be text with a 
max-length of 255. if the upper bound is &gt; 1 and the same 
table/entity is re-used within the same enclosing entity, a 
&quot;constraint&quot; MUST be set for each such attribute to 
distinguish between the attributes when storing to the 
database
</pre></td>
    </tr>
    <tr id="element_attribute_cardinality-delimiter">
      <th><pre>cardinality-delimiter</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>No API comments</pre></td>
    </tr>
    <tr id="element_attribute_cardinality-err-resource">
      <th><pre>cardinality-err-resource</pre></th>
      <td><pre>Resource</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>key in the application SRA_ResourceBundle that contains a
                  string that should be used for error messages due to cardinality 
                  upper or lower bound violations. only necessary when the 
                  upper bound cardinality is greater than 1. if not specified, 
                  the enclosing entity-model sys-err-resource will be used
                  </pre></td>
    </tr>
    <tr id="element_attribute_cardinality-unique">
      <th><pre>cardinality-unique</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"1"</pre></td>
      <td>No</td>
      <td><pre>if value determines whether or not duplicate values may
                  exist for this attribute. this attribute only applies when 
                  cardinality is used and the attribute a scalar type. the 
                  default is true, meaning all values must be unique
                  </pre></td>
    </tr>
    <tr id="element_attribute_circular-ref">
      <th><pre>circular-ref</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>if this attribute references another entity type, and the
reference is circular (meaning both entities have attributes 
that refer to each other), then one of those attributes MUST 
set this flag to TRUE. If this is not done, the circular 
reference will cause a repeating recursive loop to occur when 
the VO::renderXml method is invoked for one of those entities.
because of this, the circular flagged attribute will not be 
included in the rendered xml nor dtd description for that 
entity
</pre></td>
    </tr>
    <tr id="element_attribute_column">
      <th><pre>column</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>the name of the database table column where this attribute
can be referenced. if &quot;column&quot; is not defined, and 
&quot;skip-persistence&quot; is not true, the column name will be 
auto-set based on the entity-model camel-case-ddl setting. 
There are 3 possible table locations where this column can be 
stored: the primary entity table, a separate non-entity table, 
or a foreign entity table. the first 2 apply to any attribute, 
while the 3rd applies only to entity type attributes 
(where &quot;type&quot; is set):

 1) If &quot;table&quot; is specified, it will be assumed that this 
    column exists in that table
 2) If &quot;table&quot; is not specified:
    a) If &quot;type&quot; is not set: It will be assumed that this 
       column exists in the primary entity table
    b) If &quot;type&quot; is set: If &quot;table-pk-column&quot; is not 
       specified, it will be assumed that this column exists 
       in the primary entity table, otherwise it will be 
       assumed that this column exists in the referenced 
       entity&#039;s primary table under the name &quot;table-pk-column&quot;
       
this option is not available when the enclosing entity uses a 
ws-db
</pre></td>
    </tr>
    <tr id="element_attribute_column-type">
      <th><pre>column-type</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>an optional more specific column data type definition for
                  storage of this attribute in a database table column. by 
                  default, the column-type will be chosen based on &quot;type&quot; where 
                  the scalar types are defined as follows:
SRA_DATA_TYPE_BLOB: blob with optional maxFileSize constraint 
 applied if specified. standard blob 
 otherwise (limited to 65535 bytes in 
 mysql)
        
SRA_DATA_TYPE_BOOLEAN: boolean or enumeration of 
       &#039;[bool-false]&#039;,&#039;[bool-true]&#039; 
       if a boolean data type is not 
       provided by the database (see 
       sierra-config dtd for more 
       information)
        
SRA_DATA_TYPE_DATE: timestamp

SRA_DATA_TYPE_FLOAT: double

SRA_DATA_TYPE_INT: integer

SRA_DATA_TYPE_STRING: varchar of max-length size if max-length 
    specified, text or blob otherwise
    
                  However, if you are using ddl-path or sync-schema you may 
                  desire to use a more optimal column type. if this is the case 
                  that column type may be specified using this attribute
                  
                  this option is not available when the enclosing entity uses a 
                  ws-db
                  </pre></td>
    </tr>
    <tr id="element_attribute_constraint">
      <th><pre>constraint</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>an sql constraint to apply when referencing attributes stored
in external tables (i.e. ACTIVE=1). ONLY single quotes should 
be used for strings. Multiple constraints can be specified, 
each separated by a comma. if this attribute is an entity, and 
a constraint is applied, then each constraint column MUST be a 
column in that entity&#039;s primary table that also pertains to 
an attribute belonging to that entity. this option is not 
available when the enclosing entity uses a ws-db
 </pre></td>
    </tr>
    <tr id="element_attribute_date-format">
      <th><pre>date-format</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>if this attribute is a date/time, this attr can be used to
provide alternate date formatting string for this attribute 
when the &quot;toString&quot; method is invoked or when the getter is 
invoked with the $format parameter === TRUE or 1. the default 
format when that method is invoked is the app-config 
&quot;date-format&quot; for time types or &quot;date-only-format&quot; for dates
</pre></td>
    </tr>
    <tr id="element_attribute_default">
      <th><pre>default</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>The default value for this attribute. This may be PHP code that
generates that value, or a scalar value. if this value is not 
PHP code, it will also be used as the default value for the 
database column this attribute corresponds to when ddl is 
auto-generated. It is not PHP code if it does not contain &#039;::&#039; 
and it does not contain &#039;-&gt;&#039; and it does not start with &#039;$&#039;
</pre></td>
    </tr>
    <tr id="element_attribute_depends">
      <th><pre>depends</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>space separated list of attribute validation constraints to
apply on this attribute. these values will correspond with one 
of the SRA_AttributeValidator::{method} names. if this attribute 
is a scalar data type, the following constraints will result 
in column type constraints being automatically applied if the 
database used supports them:
 max: value is &lt;= a specific value (using &quot;CHECK ([column] &lt;= [max])&quot; if supported)
 
 maxLength: the length specification for varchar data types
 
 min: value is &gt;= a specific value (using &quot;CHECK ([column] &gt;= [min])&quot; if supported)
 
 range: value is in a numeric range (using &quot;CHECK ([column] BETWEEN [min] and [max])&quot; if supported)
 
 required: YES - not null, NO - default is null (if &quot;default&quot; value not specified)
 </pre></td>
    </tr>
    <tr id="element_attribute_dtd-name">
      <th><pre>dtd-name</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>used to explicitely state the dtd element name to use for this
attribute. the default dtd name for attributes is a combination 
of the enclosing entity name followed by the attribute name. 
In some cases this may create a naming conflict with another 
entity in which case you will need to specify an explicit 
dtd-name for that attribute in order to avoid the conflict 
(no 2 elements within a given dtd can have the same name)
</pre></td>
    </tr>
    <tr id="element_attribute_file-icon-attr">
      <th><pre>file-icon-attr</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>if this attribute is a file (is-file=&quot;1&quot;) and you wish to
use a separate entity attribute to store the path to the icon 
to use to represent that file, this value should be the name 
of the attribute to use to maintain that path. if used, 
&quot;file-icon-dir&quot; MUST be specified at the attribute or higher 
level. icons are automatically determined based on the file 
mime-type and the icons stored in &quot;file-icon-dir&quot;. if an icon 
cannot be determined for a given file, the attribute will be 
set to NULL. this attribute may be used only with file 
attributes without cardinality. the value stored in the 
referenced attribute will be the absolute path to the 
representative icon
</pre></td>
    </tr>
    <tr id="element_attribute_file-icon-dir">
      <th><pre>file-icon-dir</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>the absolute or app relative path to to the directory
containing all of the possible icons. this directory should 
contain icons using the same naming convention that is used 
for linux themes (KDE/Gnome). In fact, you may simply download 
a free theme and use the files contained in the &quot;mimetypes&quot; 
folder for a given icon size as this directory
</pre></td>
    </tr>
    <tr id="element_attribute_file-index-attr">
      <th><pre>file-index-attr</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>if this attribute is a file (is-file=&quot;1&quot;) and you wish to
maintain a searchable text index for this file using another 
attribute, this value should be the name of the attribute to 
use to maintain that index. when used, IF the file is a 
text parsable format, the text will be extracted from it and 
stored to this attribute. the column for that attribute may 
in turn use a FULLTEXT index (mysql) in that database and be 
used for search purposes. For more information on text 
parsable file formats, and setting up custom parsers, see the 
api for SRA_FileAttribute::toText. this attribute may be used 
only with file attributes without cardinality
</pre></td>
    </tr>
    <tr id="element_attribute_file-size-attr">
      <th><pre>file-size-attr</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>if this attribute is a file (is-file=&quot;1&quot;) and you wish to
store the size (in bytes) of that file in a separate entity 
attribute, this should be the name of that attribute
</pre></td>
    </tr>
    <tr id="element_attribute_file-size-kb-attr">
      <th><pre>file-size-kb-attr</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>if this attribute is a file (is-file=&quot;1&quot;) and you wish to
store the size (in kilobytes) of that file in a separate 
entity attribute, this should be the name of that attribute
</pre></td>
    </tr>
    <tr id="element_attribute_file-size-mb-attr">
      <th><pre>file-size-mb-attr</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>if this attribute is a file (is-file=&quot;1&quot;) and you wish to
store the size (in megabytes) of that file in a separate 
entity attribute, this should be the name of that attribute
</pre></td>
    </tr>
    <tr id="element_attribute_file-uri-attr">
      <th><pre>file-uri-attr</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>if this attribute is a file (is-file=&quot;1&quot;) and you wish to
store the uri to that file in a separate entity attribute, 
this should be the name of that attribute. this feature may be 
desireable when files are stored in the database in order to 
increase query performance and reduce database load. this is 
because in order to get the uri, if the file is stored in the 
database, the full contents of that file be be pulled from the 
database. using file-uri-attr, you may lazy-load the file 
attribute, and simply use the uri to reference that file. this 
feature may be used for file type attributes with or without 
cardinality
</pre></td>
    </tr>
    <tr id="element_attribute_file-processor">
      <th><pre>file-processor</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>if this attribute is a file, this attribute may be provided to
specify a command line program that should be executed on that 
file when it is first uploaded (when the set method is invoked 
with a value from the $_FILES global array). the cli program 
execution path can include the imbedded variable {$file} which 
will be replaced with the absolute path to the uploaded file 
before it is persisted to the database or file system. for 
example, if the file is an image, and a dimensional 
restriction is to be imposed before the file is persisted (or 
even evaluated by the depends constraints), this attribute 
may look something like this (using the ImageMagick convert 
cli program):

&quot;/usr/bin/convert -sample 200x300 {$file} {$file}&quot;

where 200 is the maximum width and 300 is the maximum height 
(ImageMagick maintains the aspect ratio of the image when 
resizing) and the first {$file} is the input file (the temp 
file created by php) and the second is the output file which 
actually overwrites the original one. The location of the file 
MUST be the same as the original file when the file-processor 
concludes processing
</pre></td>
    </tr>
    <tr id="element_attribute_global-name">
      <th><pre>global-name</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>if this attribute is global accross multiple entities, this
attribute provides the global identifier for the attribute. 
global attributes can be merged using the generated value 
object &#039;mergeGlobals&#039; method which accepts an array of 
entities and merges all of the common globals in those 
entities. if the global-name will be the same as the name 
attribute, then use is-global instead
</pre></td>
    </tr>
    <tr id="element_attribute_indexed">
      <th><pre>indexed</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>whether or not this attribute should be individually indexed.
this is basically just a shortcut to adding an &quot;index&quot; element 
in the entity model solely for the attribute. the name that 
will be assigned to the index is &quot;[table name]_[column]_idx&quot;. 
consult your database vendor documentation for information on 
which data types can and cannot be indexed. this option is not 
available when the enclosing entity uses a ws-db
</pre></td>
    </tr>
    <tr id="element_attribute_is-file">
      <th><pre>is-file</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>whether or not this attribute is stored as a file. for more
information on file type attributes, see the &quot;entity&quot; element 
&quot;file*&quot; attributes documentation. if is-file is true and
</pre></td>
    </tr>
    <tr id="element_attribute_is-global">
      <th><pre>is-global</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>used in place of global-name when the name attribute should
also be the global-name. only attributes with a defined 
global-name or where is-global is true will be included in
the &#039;mergeGlobals&#039; operation
</pre></td>
    </tr>
    <tr id="element_attribute_json-view">
      <th><pre>json-view</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>an optional attribute view to use when outputing this
attribute to json
</pre></td>
    </tr>
    <tr id="element_attribute_lazy-load">
      <th><pre>lazy-load</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>whether or not this attribute should be loaded by default.
if true, then the attribute will only be retrieved when 
a corresponding &#039;get&#039; method is called for that attribute. 
this only applies to attributes that are Entities themselves 
or scalar value stored in tables other than the base entity 
table. This option MUST be used wherever circular references 
exist in your object model. The default value is TRUE for all 
attributes meeting the following conditions for any 
cardinality value:
  1) Stored in an external table
  2) Reference to an entity
  3) is-file is true and file-handling is db 
     (lazy-load-exclusive is set if the column exists in the 
     same table as the entity)
an attribute CANNOT be lazy loaded if it exists in the same 
database table as the entity. to enforce that behavior, use
&quot;lazy-load-exclusive&quot;. when used in conjunction with ws-db a 
separate web service call will be made the first time this 
attribute is accessed
  </pre></td>
    </tr>
    <tr id="element_attribute_lazy-load-exclusive">
      <th><pre>lazy-load-exclusive</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>by default all columns within a given table are loaded
                  simultaneously. thus, if multiple &quot;lazy-load&quot; columns exist in 
                  a table, all of them will be retrieved when any of them is. 
                  to avoid this behavior and require that an attribute be 
                  explicitely queried ONLY when it is needed, set this attribute 
                  to TRUE. has the same meaning as &quot;lazy-load&quot; when used in 
                  conjunction with ws-db
                  </pre></td>
    </tr>
    <tr id="element_attribute_mapped">
      <th><pre>mapped</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>used in place of nested &quot;attr-mapping&quot; elements when all of
the &quot;type&quot; attributes are mapped (fully mapped). primary key 
attributes will not be mapped. this option is not available 
when the enclosing entity uses a ws-db
</pre></td>
    </tr>
    <tr id="element_attribute_mapped-exclude">
      <th><pre>mapped-exclude</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>if &quot;mapped&quot; is true, this attribute may be specified
containing a space separated list of attribute names that 
should be excluded from the mapping. this option is not 
available when the enclosing entity uses a ws-db
</pre></td>
    </tr>
    <tr id="element_attribute_mapped-include">
      <th><pre>mapped-include</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>if &quot;mapped&quot; is true, this attribute may be specified
containing a space separated list of attribute names that 
should be included in the mapping (only these attributes will 
be included). this option is not available when the enclosing 
entity uses a ws-db
</pre></td>
    </tr>
    <tr id="element_attribute_mapped-postfix">
      <th><pre>mapped-postfix</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>same as &quot;mapped-prefix&quot; but added to the end of the column
name. this option is not available when the enclosing entity 
uses a ws-db
</pre></td>
    </tr>
    <tr id="element_attribute_mapped-prefix">
      <th><pre>mapped-prefix</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>if specified, this prefix will be added to each column name
of the referenced entity type. this is necessary if, for 
example, an entity contains two fully mapped attributes of the 
same type (otherwise duplicate column names would be used). 
This value will be proceed the enclosing entity 
&quot;column-prefix&quot;. this option is not available when the 
enclosing entity uses a ws-db
</pre></td>
    </tr>
    <tr id="element_attribute_mapped-resource-postfix">
      <th><pre>mapped-resource-postfix</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>same as &quot;mapped-resource-prefix&quot; but added to the end of
                  the resource name. this option is not available when the 
                  enclosing entity uses a ws-db
                  </pre></td>
    </tr>
    <tr id="element_attribute_mapped-resource-prefix">
      <th><pre>mapped-resource-prefix</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>if specified, this prefix will be added to each resource
                  identifier in a fully mapped attribute. this includes 
                  &quot;resource&quot; and &quot;resource-help&quot;. this option is not available 
                  when the enclosing entity uses a ws-db
                  </pre></td>
    </tr>
    <tr id="element_attribute_match-user-id">
      <th><pre>match-user-id</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>the name of the entity attribute that the user-id should match
in order for a user to be able to get/set this attribute. this 
value will be passed to the &quot;getAttribute&quot; method and the 
results compared. if the return value is an array, then the 
user will only be able to access the attribute if their user 
id exists in that array. in order to use this feature, the 
SRA_Authenticator::getUserId method must return a user id. use 
this configuration to restrict access to db stored files. this 
configuration can also be declared at the entity level in 
which case all attributes that do not explicitely define a 
&quot;match-user-id&quot; configuration will inherit that value. if a 
security violation is detected, the return value of the 
corresponding getter/setter will be aborted (getter returns 
null) and the activity will be logged
</pre></td>
    </tr>
    <tr id="element_attribute_max-length">
      <th><pre>max-length</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>this attribute is a shortcut to defining a &quot;maxLength&quot;
                  validation constraint and a maxLength var defining the maximum 
                  length for the attribute. If specified, the &quot;maxLength&quot; 
                  validation constraint will be added to the attribute and the 
                  value provided will be the maximum character length for that 
                  attribute
                  </pre></td>
    </tr>
    <tr id="element_attribute_min-length">
      <th><pre>min-length</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>this attribute is a shortcut to defining a &quot;minLength&quot;
                  validation constraint and a minLength var defining the minimum 
                  length for the attribute. If specified, the &quot;minLength&quot; 
                  validation constraint will be added to the attribute and the 
                  value provided will be the minimum character length for that 
                  attribute
                  </pre></td>
    </tr>
    <tr id="element_attribute_null-db-empty-str">
      <th><pre>null-db-empty-str</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>whether or not empty string (&#039;&#039;) should be used in place of
NULL for this attribute when database edits occur and the 
value of this attribute is NULL. this will also have the 
reverse effect of setting the attribute values to NULL 
whenever they are set to an emtpy string using the attribute 
set method. this option is not available when the enclosing 
entity uses a ws-db
</pre></td>
    </tr>
    <tr id="element_attribute_on-delete-cascade">
      <th><pre>on-delete-cascade</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>if this attribute references another entity, AND this entity
(the entity that this attribute belongs to) is deleted, AND 
the default behavior is to NOT delete the referenced entity. 
Instead, if this entity&#039;s primary key is stored in the 
referenced entity&#039;s table, that value will be set to NULL. If 
you desire that the referenced entity also be deleted when 
this entity is deleted, set this attribute to TRUE. If an 
attribute is not an entity, and it is contained in another 
table it will implicitely be DELETED when the entity is 
deleted. To avoid this, you MUST explicitely set this 
attribute to FALSE for that attribute. this option is not 
available when the enclosing entity uses a ws-db
</pre></td>
    </tr>
    <tr id="element_attribute_on-remove-delete">
      <th><pre>on-remove-delete</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>if this attribute is an entity, and should only exist within
the context of a single entity of the enclosing entity type, 
then setting this attribute to TRUE will result in that entity  
being deleted whenever it is disassociated from the entity. 
the default behavior is to either delete the link table entry 
(if the two entities use a link table), or set the id of the 
enclosing entity to NULL (or empty string if this attribute&#039;s 
null-db-empty-str is TRUE) in the referenced entity&#039;s table 
(if the referenced entity table contains the id of the 
enclosing entity). this option is not available when the 
enclosing entity uses a ws-db
</pre></td>
    </tr>
    <tr id="element_attribute_order-by">
      <th><pre>order-by</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>an optional &#039;ORDER BY&#039; sql value for attributes with greater
than one upper bound cardinality stored in an external table
This value will be the name of a column in the &#039;table&#039; 
specified upon which ordering should be based. Multiple 
column name may be specified separated by commas and 
optionally followed by &#039;ASC&#039; or &#039;DESC&#039;. this option is not 
available when the enclosing entity uses a ws-db
</pre></td>
    </tr>
    <tr id="element_attribute_read-only">
      <th><pre>read-only</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>determines that an attribute can only be read, but never set
</pre></td>
    </tr>
    <tr id="element_attribute_recursive-link">
      <th><pre>recursive-link</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>use this to creative a recursive link between this attribute
and another member of its enclosing entity. basically, the 
value for recursive-link should be the name of another 
attribute in the same entity that is an entity, or array of 
entities containing the same attribute. the result is that 
invoking &quot;get&quot; for this attribute will recursively return 
both the immediate values as well as the values of the 
recursive-link attributes all merged into a single array. this 
option is not available when the enclosing entity uses a ws-db
</pre></td>
    </tr>
    <tr id="element_attribute_render-displ-option">
      <th><pre>render-displ-option</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>if this attribute has options, this determines whether the
                  option label or actual attribute value should be output to 
                  json/xml rendering. by default this value is false.
                  </pre></td>
    </tr>
    <tr id="element_attribute_render-exclude">
      <th><pre>render-exclude</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>if this attribute is an entity, this attribute specifies a
space separate list of sub-attributes that should NOT be 
included when an object is rendered to json or xml using the 
toJson/toXml methods or the built-in xml/json entity views
</pre></td>
    </tr>
    <tr id="element_attribute_render-include">
      <th><pre>render-include</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>if this attribute is an entity, this attribute specifies a
space separate list of sub-attributes that should be included 
when an object is rendered to json or xml using the 
toJson/toXml methods or the built-in xml/json entity views. 
if specified, only those attributes will be included
</pre></td>
    </tr>
    <tr id="element_attribute_resource">
      <th><pre>resource</pre></th>
      <td><pre>Resource</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>key in the entity SRA_ResourceBundle that contains a string
 or name describing this attribute. this attribute may include 
 embedded attribute values using the following format:
   &quot;description.{$type-&gt;getSourceTypeId()}&quot; : resource will 
       be identified by &quot;description.&quot; followed by the return 
       value of calling the &#039;getSourceTypeId() method on the 
       &#039;type&#039; attribute of this entity. 
   &quot;description.{$name}&quot; : resource will be identified by 
       &quot;description.&quot; followed by the value of the &#039;name&#039; 
       attribute of this entity.
 If not specified, the following search order will be used to 
 determine the correct resource key:
   {attribute name}
   attribute.{attribute name}
   {enclosing entity name}.{attribute name}
   {enclosing entity resource}.{attribute name}
   text.{attribute name}
   {type}: if this attribute is an entity
 </pre></td>
    </tr>
    <tr id="element_attribute_resource-help">
      <th><pre>resource-help</pre></th>
      <td><pre>Resource</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>key in the application SRA_ResourceBundle that contains a string
 or name providing help for this attribute. this attribute may 
 include embedded attribute values using the following format:
   &quot;description.{$type-&gt;getSourceTypeId()}&quot; : resource will 
       be identified by &quot;description.&quot; followed by the return 
       value of calling the &#039;getSourceTypeId() method on the 
       &#039;type&#039; attribute of this entity. 
   &quot;description.{$name}&quot; : resource will be identified by 
       &quot;description.&quot; followed by the value of the &#039;name&#039; 
       attribute of this entity.
 If not specified, the following search order will be used to 
 determine the correct resource key:
   {attribute name}-help
   attribute.{attribute name}-help
   {enclosing entity name}.{attribute name}-help
   {enclosing entity resource}.{attribute name}-help
       </pre></td>
    </tr>
    <tr id="element_attribute_retrieve-function">
      <th><pre>retrieve-function</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>a database function to perform when this attribute is
retrieved. this option is not available when the enclosing 
entity uses a ws-db
</pre></td>
    </tr>
    <tr id="element_attribute_sequence">
      <th><pre>sequence</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>whether or not this attribute is generated automatically
by the database as an auto-incrementing sequence. if TRUE, the 
type will automatically be set to SRA_DATA_TYPE_INT. this 
option is not available when the enclosing entity uses a ws-db
</pre></td>
    </tr>
    <tr id="element_attribute_set-convert">
      <th><pre>set-convert</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>an optional name of a static method or function that should be
invoked with the attribute value as a parameter the return 
value of which will be used in place of the original value. 
for example, to have the alternate form attribute store a tag 
stripped value, this attribute would be &quot;strip_tags&quot; (a 
standard PHP function). Note: If this method is stored in a 
non-standard PHP source file, that file should be included in 
the entity using an aop &quot;introduction&quot;. multiple set convert 
values may be specified each separated by a space. static 
methods can be specified using the form ClassName::MethodName
the signature for a set-convert function/method should be 
method(mixed : Object) : mixed. Note: for attributes with 
cardinality, the set-convert methods will only be invoked 
by the &quot;add&quot; method using single values. the return value of 
each invocation will be captured by reference using &#039;&amp;&#039;
</pre></td>
    </tr>
    <tr id="element_attribute_set-function">
      <th><pre>set-function</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>a database function to perform when this attribute is set.
this option is not available when the enclosing entity uses a 
ws-db
</pre></td>
    </tr>
    <tr id="element_attribute_set-only">
      <th><pre>set-only</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>determines that an attribute can only be set, but never read
</pre></td>
    </tr>
    <tr id="element_attribute_skip-default-views">
      <th><pre>skip-default-views</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>set to TRUE if you do not want this attribute to inherit
                  matching default views for the model. more more info, see the 
                  documentation provided for the &quot;default-view&quot; element
                  </pre></td>
    </tr>
    <tr id="element_attribute_skip-include">
      <th><pre>skip-include</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>if this attribute is an entity &quot;type&quot;, and you do not want the
generated VO to automatically include the PHP value object 
source file for that type, set this attribute to true
</pre></td>
    </tr>
    <tr id="element_attribute_skip-persistence">
      <th><pre>skip-persistence</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>whether or not this attribute is persistent. only applicable
if the enclosing entity is persistent. non-persistent 
entities will not be included in the table definitions or 
queries for the enclosing entity
</pre></td>
    </tr>
    <tr id="element_attribute_skip-wsdl">
      <th><pre>skip-wsdl</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>whether or not to skip adding this attribute to the wsdl
generated by the web services gateway
</pre></td>
    </tr>
    <tr id="element_attribute_sync-attributes">
      <th><pre>sync-attributes</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>a space separated list of other entity attributes that should
be set whenever this attribute is set. never create circular 
sync references between attributes as this will cause an 
infinite loop condition. the syncronization will occur after 
any &quot;set-convert&quot; operations for this attribute. Note: for 
attributes with cardinality, the syncronization will occur 
only within the &quot;add&quot; and &quot;remove&quot; methods (not the &quot;set&quot; 
method)
</pre></td>
    </tr>
    <tr id="element_attribute_table">
      <th><pre>table</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>if the attribute is stored in another table, this
attribute defines the name of that table. the primary key for 
the enclosing entity should also exist in this table using the 
same column name, or an overrided value specified in 
&quot;table-pk-column&quot;. this option is not available when the 
enclosing entity uses a ws-db
</pre></td>
    </tr>
    <tr id="element_attribute_table-pk-column">
      <th><pre>table-pk-column</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>this attribute can be used in 2 ways:
 1) if &quot;table&quot; is specified and the enclosing entity primary 
    key column name is different in that table, then specify 
    the correct column name using this attribute.
 2) if &quot;type&quot; is specified, and the referenced type primary 
    table has the column containing a primary key reference 
    back to this entity, then this attribute specifies the name 
    of that column in the referenced entity primary table
 this option is not available when the enclosing entity uses a 
 ws-db
 </pre></td>
    </tr>
    <tr id="element_attribute_type">
      <th><pre>type</pre></th>
      <td><pre>CDATA</pre></td>
      <td><pre>"php::</pre></td>
      <td>No</td>
      <td><pre>the data type of this attribute. this may be the name of one
of the other entities, or a standard type as defined in the 
lib/SRA_Database TYPE constants. The default type is 
SRA_DATA_TYPE_STRING (String). Validation for this type is 
not performed by setters unless explicitely specified in the 
&quot;depends&quot; attribute. database mapping of an instance of an 
instance of a foreign entity to this entity is designated 
using the &quot;column&quot; and &quot;table-pk-column&quot; attributes (see 
comments above for more information)
</pre></td>
    </tr>
    <tr id="element_attribute_type-err-resource">
      <th><pre>type-err-resource</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>key in the application SRA_ResourceBundle that contains a string
 that should be used for error messages due to invalid type 
 errors. only necessary when the &#039;type&#039; references another 
 entity in this model. if not specified, the 
 enclosing entity-model sys-err-resource will be used
 </pre></td>
    </tr>
    <tr id="element_attribute_union-link">
      <th><pre>union-link</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>similiar to recursive-link, this value specifies another
attribute in the SAME entity whose values should be unioned 
with this attributes values when the GET method is invoked. 
this option is not available when the enclosing entity uses a 
ws-db
</pre></td>
    </tr>
    <tr id="element_attribute_xml-use-attribute">
      <th><pre>xml-use-attribute</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>this flag may be set for scalar attributes without cardinality
ONLY. when set, this entity attribute will be rendered as an 
xml attribute instead of a nested element (the default 
behavior) when the &#039;renderXml&#039; or &#039;render(&quot;xml&quot;)&#039; methods are 
invoked. this change will also be reflected in the 
auto-generated DTD (when applicable). the PHP htmlspecialchars 
method will be invoked on the value for this attribute when 
this flag is set and prior to inserting it into the xml
</pre></td>
    </tr>
    <tr id="element_attribute_xml-view">
      <th><pre>xml-view</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>an optional attribute view to use when outputing this
attribute to xml


</pre></td>
    </tr>
  </table>

 <hr />  <a href="#top" style="float:right">Top</a>
  <h3 id="element_validate">validate</h3>
  <pre>The &quot;validate&quot; element defines an entity validation sequence. these are 
different then attribute validators defined using &quot;depends&quot;. &quot;validate&quot; is used 
to specify sets of attributes that are required either as a whole (all required) 
or partially (at least one required)</pre>
  <h4>Used In</h4>
  <ul>
    <li><a href="#element_entity">entity</a></li>
  </ul>

  <h4>Sub Elements</h4>
  <p>This element does not have any sub-elements</p>

  <h4>Attributes</h4>
  <table border="1">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default Value</th>
      <th>Required?</th>
      <th>Comment</th>
    </tr>
    <tr id="element_validate_key">
      <th><pre>key</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>unique identifier for the entity validation sequence. this may
be used to identify this validation sequence when invoking the 
$entity-&gt;validate method
</pre></td>
    </tr>
    <tr id="element_validate_attrs">
      <th><pre>attrs</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>space separated list of names referencing the attributes or
member methods that should be included in this entity 
validation sequence. attributes that are included will be 
considered set if they are not equal (===) to NULL. this would 
include the values FALSE, 0, &#039;0&#039; and empty array. conditional 
inclusion can be applied by separating the conditional 
attribute/method from the attribute to include using an = 
(equal sign). the conditional attribute/method may optionally 
be preceded by the ! (NOT) operator. Multiple attributes may 
be specified following the equal sign separated by an &#039;^&#039; (AND 
validation) or an &#039;|&#039; (OR validation) but no spaces. For 
example:

  name : name attribute is required
  
  myCustomValidation : member method myCustomValidation() must 
return a value that evaluates to TRUE

  foreign=phoneNumber : require phone number if the &#039;foreign&#039; 
attribute evaluates to TRUE

  !isExtraLarge=neckSize : require neck size if the method 
isExtraLarge() does NOT return TRUE

  happy=smiling^dancing : requires both smiling and dancing if
the &#039;happy&#039; attribute evaluates to TRUE

  sad=crying|sobbing : require either crying or sobbing if the 
&#039;sad&#039; attribute evaluates to TRUE

there should be NO SPACES in a conditional expression
</pre></td>
    </tr>
    <tr id="element_validate_equal">
      <th><pre>equal</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>whether or not this validation constraint should additionally
validate that the attrs specified all have the same value. 
this may be useful for verifying validity of data input by 
requiring the user to enter that data twice (not applicable to 
conditional attr constraints)
</pre></td>
    </tr>
    <tr id="element_validate_eval-php-false">
      <th><pre>eval-php-false</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>by default attrs are considered not set when they evaluate to
NULL using the strict equality operator (===). set this flag 
to true to alter this behavior so that an attribute is 
considered not set when it evaluates to PHP FALSE. this 
includes NULL as well as FALSE, 0, &#039;0&#039;, and empty array
</pre></td>
    </tr>
    <tr id="element_validate_mandatory">
      <th><pre>mandatory</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>whether or not this is a mandatory validation sequence.
all mandatory validation sequences are triggered when the 
&quot;validate&quot; method is invoked without specifying a specific 
sequence. this invocation occurs always prior to an insert or 
update
</pre></td>
    </tr>
    <tr id="element_validate_not-equal">
      <th><pre>not-equal</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>has the opposite meaning of &quot;equal&quot;
</pre></td>
    </tr>
    <tr id="element_validate_require-all">
      <th><pre>require-all</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"1"</pre></td>
      <td>No</td>
      <td><pre>whether or not all attributes (non-conditional or conditional)
in the validation sequence are required (&#039;AND&#039;). the default 
is TRUE. Set this to &quot;0&quot; to specify that only 1 of the 
attributes is required
</pre></td>
    </tr>
    <tr id="element_validate_resource">
      <th><pre>resource</pre></th>
      <td><pre>Resource</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>key in the application SRA_ResourceBundle reference the string
that should be displayed when this validation sequence fails. 
this resource may contain the variable {$entity} which will be 
substituted with the entity label at runtime. additionally, 
each of the labels for the attributes will be set in the 
variables &quot;attrN&quot; where N is the order in which the attributes 
appear in &quot;attrs&quot; (above) starting with N=1

</pre></td>
    </tr>
  </table>

 <hr />  <a href="#top" style="float:right">Top</a>
  <h3 id="element_attr-mapping">attr-mapping</h3>
  <pre>The &quot;attr-mapping&quot; element defines a limited scope of which attributes of an 
entity type attribute will actually be used and persisted by the attribute that 
maps them. If specified, these mappings will define entirely which attributes of 
the entity will be persistable. Any attributes for which a attr-mapping is not 
specified will not be persisted</pre>
  <h4>Used In</h4>
  <ul>
    <li><a href="#element_attribute">attribute</a></li>
  </ul>

  <h4>Sub Elements</h4>
  <p>This element does not have any sub-elements</p>

  <h4>Attributes</h4>
  <table border="1">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default Value</th>
      <th>Required?</th>
      <th>Comment</th>
    </tr>
    <tr id="element_attr-mapping_key">
      <th><pre>key</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>the name of attribute. may include sub-attributes of the
mapped entity
</pre></td>
    </tr>
    <tr id="element_attr-mapping_column">
      <th><pre>column</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>optional name for the table column that this attribute will be
persisted to
</pre></td>
    </tr>
    <tr id="element_attr-mapping_resource">
      <th><pre>resource</pre></th>
      <td><pre>Resource</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>overrides the corresponding attribute&#039;s &quot;resource&quot;. must be a
fully valid resource identifier (resource searching will not 
be applied)
</pre></td>
    </tr>
    <tr id="element_attr-mapping_resource-help">
      <th><pre>resource-help</pre></th>
      <td><pre>Resource</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>overrides the corresponding attribute&#039;s &quot;resource-help&quot;. must
be a fully valid resource identifier (resource searching will 
not be applied)

</pre></td>
    </tr>
  </table>

 <hr />  <a href="#top" style="float:right">Top</a>
  <h3 id="element_thumbnail">thumbnail</h3>
  <pre>The &quot;thumbnail&quot; element is used in conjunction with file type attributes 
(where is-file is true) when the model should automatically attempt to generate
a thumbnail (or thumbnails) for that attribute and store those also as file 
type attributes using another member attribute in the same entity. for more 
information on this functionality, see the api for 
SRA_FileAttribute::toThumbnail. this attribute may be used only with file 
attributes without cardinality. the value stored in the referenced attribute 
will be a new SRA_FileAttribute instance representing the thumbnail. at least 
1 height or width (or both) MUST be specified for all thumbnails. if both height 
and width are specified, and &quot;preserve-aspect&quot; is not true, the aspect ratio of 
the image may be affected because that exact height/width will be used for the 
generated thumbnail. if only one, height or width is specified, or if both are 
specified and &quot;preserve-aspect&quot; is true, those values will be the max height
or width of the generated thumbnail while the other dimension will be 
proportional to the dimension that is used according to the image aspect ratio. 
thumbnails will be generated to png format by default. gif and jpeg are also 
supported formats and may be specified using the &quot;format&quot; attribute. if multiple 
thumbnails are created as a result of the thumbnail generation process (i.e. 
when file is pdf with multiple pages), the first page thumbnail will be used 
UNLESS the thumbnail attribute referenced has cardinality in which case ALL of 
the thumbnails will be set in the same order of the pages. thumbnails cannot be 
generated for file attributes with cardinality</pre>
  <h4>Used In</h4>
  <ul>
    <li><a href="#element_attribute">attribute</a></li>
  </ul>

  <h4>Sub Elements</h4>
  <p>This element does not have any sub-elements</p>

  <h4>Attributes</h4>
  <table border="1">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default Value</th>
      <th>Required?</th>
      <th>Comment</th>
    </tr>
    <tr id="element_thumbnail_key">
      <th><pre>key</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>the name of the entity attribute (in the same entity as the
enclosing attribute) that the thumbnail(s) should be saved to
</pre></td>
    </tr>
    <tr id="element_thumbnail_attr">
      <th><pre>attr</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>if the referenced attribute is an entity (versus a file), this
value should specified the name of the entity member attribute
that should be used to store the thumbnail image
</pre></td>
    </tr>
    <tr id="element_thumbnail_attr-page-num">
      <th><pre>attr-page-num</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>if the referenced attribute is an entity, and the file that
the thumbnails are generated for may include multiple page 
pdf or postscript documents, this value may be used to store 
the page number for each of the generated thumbnails. in order 
to use this feature, however, the cardinality relationship 
must be 0..* for the referenced attribute, otherwise, a 
thumbnail will only be generated for the first page in the 
document
</pre></td>
    </tr>
    <tr id="element_thumbnail_format">
      <th><pre>format</pre></th>
      <td><pre>(gif | jpg | png)</pre></td>
      <td><pre>"png"</pre></td>
      <td>No</td>
      <td><pre>the image format for the generated thumbnail(s)
 </pre></td>
    </tr>
    <tr id="element_thumbnail_include-types">
      <th><pre>include-types</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>space separated list of ereg regular expressions that should
 be used to match the mime-types that should be included in the 
 thumbnail generation. thumbnail(s) will not be generated for 
 any files that do not match these mime types
 </pre></td>
    </tr>
    <tr id="element_thumbnail_height">
      <th><pre>height</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>the maximum height of the generated thumbnail(s)
</pre></td>
    </tr>
    <tr id="element_thumbnail_preserve-aspect">
      <th><pre>preserve-aspect</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"1"</pre></td>
      <td>No</td>
      <td><pre>whether or not to preserve the aspect ratio of the original
source file. if true, the thumbnail dimensions will not 
exceed height or width. if false, the thumbnail dimensions 
will be exactly height and width. when true, both height and 
width should be specified
</pre></td>
    </tr>
    <tr id="element_thumbnail_skip-types">
      <th><pre>skip-types</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>space separated list of a ereg regular expressions that should
be used to skip the mime-types that should be not be included  
in the thumbnail generation. thumbnail(s) will only be 
generated for files that do not match these mime types
</pre></td>
    </tr>
    <tr id="element_thumbnail_width">
      <th><pre>width</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>the maximum width of the generated thumbnail(s)

</pre></td>
    </tr>
  </table>

 <hr />  <a href="#top" style="float:right">Top</a>
  <h3 id="element_default-view">default-view</h3>
  <pre>The &quot;default-view&quot; element is used to automatically associate a a view within 
&quot;global-views&quot; to all attributes of a given type. for example, if you wanted all 
&quot;string&quot; attributes to automatically use a global view named &quot;output&quot; which is 
simple a text label output, you could use this element instead of creating a 
&quot;view&quot; extends sub-element for each attribute. in this case you would first 
create a global-view named &quot;output-text&quot; and then create a &quot;default-view&quot; where 
id=&quot;output&quot;, type=&quot;string&quot; and view=&quot;output-text&quot;. you may restrict associations 
using the optional attributes, cardinality, and entities attributes. default 
views can be ignored or overriden in model attributes using the 
&quot;skip-default-views&quot; attribute or by creating a custom view using the same name.
default views apply ONLY to attributes. &quot;default-view&quot; elements can also be 
overriden at the entity level using by nesting them within the entity element</pre>
  <h4>Used In</h4>
  <ul>
    <li><a href="#element_entity">entity</a></li>
    <li><a href="#element_global-views">global-views</a></li>
  </ul>

  <h4>Sub Elements</h4>
  <p>This element does not have any sub-elements</p>

  <h4>Attributes</h4>
  <table border="1">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default Value</th>
      <th>Required?</th>
      <th>Comment</th>
    </tr>
    <tr id="element_default-view_id">
      <th><pre>id</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>the id for this view within the attributes they are associated
to. a &quot;default-view&quot; will be overriden if a matching attribute 
already has a view with this name. 
</pre></td>
    </tr>
    <tr id="element_default-view_attrs">
      <th><pre>attrs</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>optional space separated list of attribute names that should
or should not inherit this default view. precede this value 
with an exclamation mark &quot;!&quot; if the names are attributes 
that should NOT inherit this default view
</pre></td>
    </tr>
    <tr id="element_default-view_cardinality">
      <th><pre>cardinality</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>cardinality to match in order for this default view to be
inherited by an attribute. if not specified, the view will 
only be inherited by attributes that do not have cardianity
</pre></td>
    </tr>
    <tr id="element_default-view_depends">
      <th><pre>depends</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>space sepeated list of depends contraints that should be
matched or not matched in order for this default view to be 
inherited by an attribute. if not specified depends contraints 
will be ignored. if specified, all of the constraints 
specified must be used by the attribute (if not preceeded with 
&quot;!&quot;). preceed this value with an exclamation mark &quot;!&quot; if only 
attributes that do not use ANY of those contraints should 
inherit the default view
</pre></td>
    </tr>
    <tr id="element_default-view_entities">
      <th><pre>entities</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>optional space separated list of entity names that should
or should not inherit this default view. precede this value 
with and exclamation mark &quot;!&quot; if the names are entities that 
should NOT inherit this default view. if an entity does not 
inherit a default view, none of its&#039; attributes will either
</pre></td>
    </tr>
    <tr id="element_default-view_types">
      <th><pre>types</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>space separated list of the data types of the attributes that
should inherit this default view. only attributes of these 
types will inherit the view. the types may be scalar or entity
use &#039;*&#039; to specify all types
</pre></td>
    </tr>
    <tr id="element_default-view_view">
      <th><pre>view</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>the name (key) of the view within &quot;default-views&quot; that should
be inherited. 

</pre></td>
    </tr>
  </table>

 <hr />  <a href="#top" style="float:right">Top</a>
  <h3 id="element_view">view</h3>
  <pre>The &quot;view&quot; element defines a single entity/attribute view. These views are used 
to display the entities/attributes for viewing or editing. For example, one view 
may be defined to display in a read-only format, one in a form that a user can 
fill in, and one to display the entity data in a printable pdf format. views can 
be rendered utilizing the corresponding VO::render and VO::renderAttribute 
methods. The following template variables will automatically be set:
    entity: a reference to the entity instance/value
    attribute: a reference to the attribute instance/value
    [attribute|entity]Name: the name of the entity or attribute
    [attribute|entity]Label: the label for the entity or attribute
    attributeIndex: the current attribute index (where multiplicty is used)
    fieldName: the field name for an attribute view. this value may be 
               automatically prefixed or postfixed using SRA_EntityView::getGlobalFieldNamePrefix() 
               and SRA_EntityView::getGlobalFieldNamePostfix()
    params: SRA_Params object representing the params specified for the view
    attrs: an array of the names of the attributes that will be rendered as determined by the &quot;attrs&quot; value
    viewName: the name of the view being rendered
    
A view named &#039;xml&#039; (not case sensitive) is reserved for every entity. rendering 
that view will result in a pass-thru call to the VO::renderXml method.

A view may have 0..* nested param elements. the corresponding view templates 
used by the view may use these values in different ways. consult the documentation 
for those view templates for further information. 

One reserved param type is &#039;view-resources&#039; (SRA_ENTITY_MODELER_VIEW_RESOURCES_PARAM_TYPE)
which may be used to specify resource bundles that should be made available 
within an entity (attr views not supported) view. The &#039;id&#039; for these params will 
be the template variable through which that resource bundle reference may be 
accessed, and the value will be the path (app/framework relative, or fixed path) 
to the resource bundle. When rendered, the correct localized resource bundle 
will be selected and made available accordingly within the template. This 
feature applies also to the &#039;xml&#039; and &#039;json&#039; built-in views. When applied within 
an xml view (template=&quot;xml&quot;), each resource bundle will be included using the 
&quot;view-resources&quot; (&quot;ViewResources&quot; for camel-case dtds) element (directly below 
the root xml document element) where the &quot;id&quot; of that element will correspond 
with the &quot;id&quot; of the &quot;param&quot;, and each of these elements will contains 0..* 
nested &quot;view-resources-string&quot; (&quot;ViewResourcesString&quot; for camel-case dtds) for 
each string included in that resource bundle file (the &quot;id&quot; attribute of this 
element will be equal to the key and the value of that element will be the 
string value). When applied within a json view (template=&quot;json&quot;), an attribute 
named &quot;ViewResources&quot; will be automatically appended to the json serialized 
object. This attribute will be an associative array indexed by the resources 
&quot;id&quot;, where the value of each will also be an associative array of key/value 
pairs representing the strings included in the resource bundle.

Additionally, the view itself may utilize nested params of type &#039;formInitVals&#039; 
defining 0..* attribute values that should be added to the object initialization 
array when [VO]::newInstanceFromForm is invoked. the key in these params will be 
the attribute name, and the value will be either an explicit value or php code 
that will generate that value. the value will be postfixed with a ;. the view 
may also utilize nested params of type &#039;formInitValsRemove&#039; which will 
remove any initialization values if they are equal to the value specified in 
the param, or just set if a value is not specified.. the view may also utilize 
nested params of type &#039;formInitValsPre&#039; which are similiar to &#039;formInitVals&#039; but 
may be overwritten by $_POST/$_GET values for the corresponding attributes</pre>
  <h4>Used In</h4>
  <ul>
    <li><a href="#element_entity">entity</a></li>
    <li><a href="#element_global-views">global-views</a></li>
    <li><a href="#element_attribute">attribute</a></li>
  </ul>

  <h4>Sub Elements</h4>
  <table border="1">
    <tr>
      <th>Sub Element</th>
      <th>Required?</th>
      <th>More than one?</th>
    </tr>
    <tr>
      <td><pre><a href="#element_param">param</a></pre></td>
      <td>No</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td><pre><a href="#element_view-header">view-header</a></pre></td>
      <td>No</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td><pre><a href="#element_view-label">view-label</a></pre></td>
      <td>No</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td><pre><a href="#element_view-value">view-value</a></pre></td>
      <td>No</td>
      <td>Yes</td>
    </tr>
  </table>

  <h4>Attributes</h4>
  <table border="1">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default Value</th>
      <th>Required?</th>
      <th>Comment</th>
    </tr>
    <tr id="element_view_key">
      <th><pre>key</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>unique identifier for the view
</pre></td>
    </tr>
    <tr id="element_view_attrs">
      <th><pre>attrs</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>optionally defines which attributes should be displayed and
the order that they should be displayed in if 
&quot;render-attributes&quot; is true. If this attribute 
is specified, then only the attributes listed in it will be 
displayed. attribute names should be space separated. this 
option only applies when the view is for an entity, or an 
entity attribute referencing another entity. if not specified 
and &quot;render-attributes&quot; is true, all of the entity&#039;s 
attributes will be rendered in the order they appear in the 
entity descriptor. Optionally, this may be a PHP code segment, 
that will return an array of attribute names. In order to use 
this functionality, the &quot;attrs&quot; value must be prefixed with:
&quot;code:&quot;
</pre></td>
    </tr>
    <tr id="element_view_cardinality-attr">
      <th><pre>cardinality-attr</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>used for attribute views only where a cardinality property is
defined for that attribute. in that scenario, this attribute 
specifies which entity attribute specifies the # of attributes 
of that type that should referenced to the attribute. if the 
actual # of instances exceeds that #, the view will 
automatically ignore the extra instances. if not enough 
instances currently exist, new instances will be created. 
</pre></td>
    </tr>
    <tr id="element_view_default">
      <th><pre>default</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>whether or not this is the default view. only one view can be
designated as default within the enclosing entity or attribute 
element. if no view is designated as default, the first view 
defined will automatically be assigned as the default 
(default view is displayed when corresponding &#039;render&#039; method 
is called without a view identfier). views within &quot;global-views&quot; 
may extend other global views
</pre></td>
    </tr>
    <tr id="element_view_extends">
      <th><pre>extends</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>a reference to the key of another view configuration that this
view should inherit from. any common settings between this and 
the corresponding referenced view will be overriden by the 
settings specified for this view. the referenced view may be 
any &quot;view&quot; defined in the xml at a higher hierarchical level. 
for example, if this view is for any attribute, it may extend 
any views within the enclosing entity, OR any of the 
&quot;global-views&quot; defined for the entity-model. entity views can 
extend both other views in the same entity as well as global 
views. multiple views can be extended and will be processed 
in the order defined
</pre></td>
    </tr>
    <tr id="element_view_field-name">
      <th><pre>field-name</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>an alternate field name to use for attribute views. if
specified, this name will be used instead of the attribute 
name. this will break automatic form instantiation using 
newInstanceFromForm
</pre></td>
    </tr>
    <tr id="element_view_forward-view">
      <th><pre>forward-view</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>if this view forwards this view to nested attributes/entities,
the foward-view may be specified to identify the view that 
should be rendered when this forwarding occurs. otherwise, the 
same view id used by this view will be rendered
</pre></td>
    </tr>
    <tr id="element_view_id-constraint">
      <th><pre>id-constraint</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>specifies the php code that will provide the list of ids for
the entities that should be displayed. applies only when the 
view is assigned to an attribute, and that attribute has 
upper bound cardinality &gt; 1, and that attribute represents an 
entity. if a value in this constraint is the string &#039;NEW&#039;, a 
new instance of the corresponding entity will be instantiated 
and displayed
</pre></td>
    </tr>
    <tr id="element_view_iterate">
      <th><pre>iterate</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>if the view is for an attribute, and the attribute is an
array, then the default behavior is to display the &quot;template&quot; 
once for the entire array. setting iterate to &quot;1&quot; will result 
in the view being rendered once for value in the array
</pre></td>
    </tr>
    <tr id="element_view_lookup-processor">
      <th><pre>lookup-processor</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>relative or fixed path to a class that extends lib/model/SRA_LookupProcessor
 If a SRA_LookupProcessor is specified, that class must implement 
 the static method SRA_LookupProcessor::lookup as described in the 
 SRA_LookupProcessor api. This method will return an array of 
 entities of the type that encloses this view. SRA_LookupProcessors 
 can ONLY be used for entity views, and not for attributes. 
 If a SRA_LookupProcessor is defined, this view will become 
 statically accessible via the {entity}::render($viewId) method 
 and the entire view definition will be processed once for each 
 entity instance returned by the SRA_LookupProcessor. the view 
 &quot;params&quot; will be passed into the SRA_LookupProcessor::lookup 
 method along with the entity name. Examples:
   &quot;MyLookupProcessor&quot;: SRA_LookupProcessor subclass is stored in 
   the standard lib directory for the app
   
   &quot;lib/processors/MyLookupProcessor&quot;: SRA_LookupProcessor subclass is 
   stored in the sub-directory &quot;processors&quot; beneath the standard 
   lib directory for the app
   
   &quot;lib/model/SRA_ListLookupProcessor&quot;: a powerful lookup processor 
   located in SRA_DIR/lib/model/ that can be utilized to display 
   lists of entities in any format including the ability to 
   segment the view into multiple pages.
 
 the following &quot;lp-*&quot; attributes are only applicable when a 
 &quot;lookup-processor&quot; has been defined. if both tpl and html/msg 
 are specified, the template will be displayed first
 </pre></td>
    </tr>
    <tr id="element_view_lp-no-results-msg">
      <th><pre>lp-no-results-msg</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>a message (resource key) to display if the lookup processor returns no entities
 </pre></td>
    </tr>
    <tr id="element_view_lp-no-results-tpl">
      <th><pre>lp-no-results-tpl</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>a template to display if the lookup processor returns no entities
 </pre></td>
    </tr>
    <tr id="element_view_mime-type">
      <th><pre>mime-type</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>if specified, a &quot;Content-type&quot; header will be output with
the mime-type specified. Mime-type can also be specified using 
the &quot;view-header&quot; sub-elements
</pre></td>
    </tr>
    <tr id="element_view_multiplicty-attr">
      <th><pre>multiplicty-attr</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>No API comments</pre></td>
    </tr>
    <tr id="element_view_post">
      <th><pre>post</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>html to render last (after the post-template if specified)
 </pre></td>
    </tr>
    <tr id="element_view_post-template">
      <th><pre>post-template</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>the last smarty template to be displayed for the entity. may
perform view functions such as setting up a footer. this 
template will only be displayed once even if the multiplicty 
is greater than 1 for an attribute view that utilized the 
multiplicty option
</pre></td>
    </tr>
    <tr id="element_view_pre">
      <th><pre>pre</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>html to render first (before the pre-template if specified)
 </pre></td>
    </tr>
    <tr id="element_view_pre-template">
      <th><pre>pre-template</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>the first smarty template to be displayed for the entity. may
perform view functions such as setting up a header. this 
template will only be displayed once even if the multiplicty 
is greater than 1 for an attribute view that utilized the 
multiplicty option
</pre></td>
    </tr>
    <tr id="element_view_render-attributes">
      <th><pre>render-attributes</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>whether or not the entity&#039;s or attribute&#039;s sub-attributes
should be rendered. if TRUE, they will be rendered after the 
&quot;template&quot; and before the &quot;post-template&quot;. this option only 
applies for entity views, or an attribute that references 
another entity. if the latter is the case, then 1 of 3 
scenarios apply:
  1) if &quot;attrs&quot; has been specified, then each of 
  those attributes will be rendered using the entity&#039;s 
  &quot;renderAttribute&quot; method
  2) if &quot;attrs&quot; has not been specified, and the 
  referenced entity has a view with the same identifier, the 
  entity&#039;s &quot;render&quot; method will be invoked for that view. 
  &quot;skip-attributes&quot; may also be specified in this scenario
  3) if &quot;render-attributes&quot; is FALSE, then no attribute 
  rendering will be performed. However, the &quot;template&quot; will 
  be displayed with the &quot;attribute&quot; value set to the instance 
  of the entity or entitites
</pre></td>
    </tr>
    <tr id="element_view_skip-attributes">
      <th><pre>skip-attributes</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>space separated list of attributes that should not be rendered
when &quot;render-attributes&quot; is true
</pre></td>
    </tr>
    <tr id="element_view_template">
      <th><pre>template</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>the primary smarty template utilized to render the entity or
attribute. Some standard templates are provided in 
SRA_DIR/www/tpl/views. They include documentation 
pertaining to relevant &quot;param&quot;s for customization of the 
template. In many cases these standard templates will suffice, 
however, if you require extensive customization to your view, 
you will need to create a custom view template. 

if &#039;template&#039; is the value &quot;xml&quot;, then an xml representation 
of the entity will be the initial output (can be used to feed 
view-processors with xml formatted output). this will also 
result in the attributes &#039;iterate&#039;, &#039;post-template&#039;, 
&#039;pre-template&#039; and &#039;render-attributes&#039; to be 
ignored. However, &#039;attrs&#039; and &#039;skip-attributes&#039; CAN be used to 
limit the xml data that is output for the entity. the &#039;xml&#039; 
template cannot be used for attribute views.
</pre></td>
    </tr>
    <tr id="element_view_view-processors">
      <th><pre>view-processors</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>references view-processors (using the &quot;view-processor&quot;
&quot;key&quot; attribute) that should be invoked on the output of this 
view. these will be executed in the order specified 
where the input to the first will be the output from the &quot;view&quot; 
template, and the input to the 2nd will be the output from the 
first and so on. all template outputs (including post-template) 
will be buffered and input to the first view-processor

</pre></td>
    </tr>
  </table>

 <hr />  <a href="#top" style="float:right">Top</a>
  <h3 id="element_view-header">view-header</h3>
  <pre>The &quot;view-header&quot; is a single http header output that should precede the output 
from a &quot;view&quot; (for more information see &#039;header&#039; function documentation in the 
PHP manual)</pre>
  <h4>Used In</h4>
  <ul>
    <li><a href="#element_view">view</a></li>
  </ul>

  <h4>Sub Elements</h4>
  <p>This element does not have any sub-elements</p>

  <h4>Attributes</h4>
  <table border="1">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default Value</th>
      <th>Required?</th>
      <th>Comment</th>
    </tr>
    <tr id="element_view-header_key">
      <th><pre>key</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>the header string to be output. This may include the following
imbedded strings

{$attr[_subAttr]}  - if specified, the corresponding attribute 
  value will be substituted (if this value 
  is an object, it will be substituted in a 
  serialized form)
  
{LENGTH} - will be substituted with the size in bytes of the 
           buffered output. Can ONLY be used in conjunction 
           with a view-processor, otherwise output is not 
           buffered, so no length will be available
</pre></td>
    </tr>
    <tr id="element_view-header_replace">
      <th><pre>replace</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"1"</pre></td>
      <td>No</td>
      <td><pre>indicates whether the header should replace a previous similar
header, or add a second header of the same type. By default 
it will replace, but if you specify &quot;0&quot; for this attribute you 
can force multiple headers of the same type
</pre></td>
    </tr>
    <tr id="element_view-header_response-code">
      <th><pre>response-code</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>force the HTTP response code to the specified value

</pre></td>
    </tr>
  </table>

 <hr />  <a href="#top" style="float:right">Top</a>
  <h3 id="element_view-label">view-label</h3>
  <pre>A &quot;view-label&quot; is used override the default label for an entity/attribute within 
a view.</pre>
  <h4>Used In</h4>
  <ul>
    <li><a href="#element_view">view</a></li>
  </ul>

  <h4>Sub Elements</h4>
  <p>This element does not have any sub-elements</p>

  <h4>Attributes</h4>
  <table border="1">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default Value</th>
      <th>Required?</th>
      <th>Comment</th>
    </tr>
    <tr id="element_view-label_key">
      <th><pre>key</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>the name of the attribute that this label overrides. to
override the entity label (if the view is for an entity), this 
value should be the name of the entity
</pre></td>
    </tr>
    <tr id="element_view-label_label">
      <th><pre>label</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>the label that should be used. this may be a value in the
app&#039;s properties file

</pre></td>
    </tr>
  </table>

 <hr />  <a href="#top" style="float:right">Top</a>
  <h3 id="element_view-value">view-value</h3>
  <pre>A &quot;view-value&quot; is used override the default value for an attribute</pre>
  <h4>Used In</h4>
  <ul>
    <li><a href="#element_view">view</a></li>
  </ul>

  <h4>Sub Elements</h4>
  <p>This element does not have any sub-elements</p>

  <h4>Attributes</h4>
  <table border="1">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default Value</th>
      <th>Required?</th>
      <th>Comment</th>
    </tr>
    <tr id="element_view-value_key">
      <th><pre>key</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>the name of the attribute that this value overrides
</pre></td>
    </tr>
    <tr id="element_view-value_value">
      <th><pre>value</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>the value that should be used

</pre></td>
    </tr>
  </table>

 <hr />  <a href="#top" style="float:right">Top</a>
  <h3 id="element_view-processor">view-processor</h3>
  <pre>The &quot;view-processor&quot; element allows the output of a &quot;view&quot; template or another 
&quot;view-processor&quot; to be used as input to a command line program. This is useful 
in that it allows additional processing to take place on the view output such as 
xsl-fo processing for example</pre>
  <h4>Used In</h4>
  <ul>
    <li><a href="#element_entity-model">entity-model</a></li>
  </ul>

  <h4>Sub Elements</h4>
  <p>This element does not have any sub-elements</p>

  <h4>Attributes</h4>
  <table border="1">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default Value</th>
      <th>Required?</th>
      <th>Comment</th>
    </tr>
    <tr id="element_view-processor_key">
      <th><pre>key</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>unique identifier for this view processor
</pre></td>
    </tr>
    <tr id="element_view-processor_args">
      <th><pre>args</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>input arguments that should be passed into the command line
program. the following variables can be specified in this 
attribute:

{$outputFile}       if specified the output of the &quot;view&quot; or 
  of the previous &quot;view-processor&quot; will be 
  serialized to a file and the path 
  to that file will be substituted with 
  every occurrence of this variable in the 
  args attribute. this file will be 
  automatically deleted upon completion of 
  the processing
  
{$randomFile[N]}    if specified, a random empty file will be 
  created and the path to that file will be 
  substituted with every occurrence of this 
  variable in the args attribute. the [N] is 
  optional to differential between different 
  random files. these files will be 
  automatically deleted upon completion of 
  the processing. [N] may be a value between 
  1 and 10 only. Each different random file 
  will only be created once and shared 
  between all viewProcessor instances in the 
  process
  
{$attr[_subAttr]}   if specified, the corresponding entity or 
  entity attribute will be substituted for 
  every occurrence of this variable in the 
  args attribute. If this is an object, it 
  will be specified in a serialized form 
  unless a &quot;toString&quot; method exists, in 
  which case the results from that method 
  call will be used
  
{LENGTH}            will be substituted with the size in bytes 
  of the buffered output prior to execution 
  of this processor
  
{$param}            the id of a view parameter. the value of
  that parameter will be substituted
  
{SRA_DIR}           the path to the framework

{APP_DIR}           the path to the application
  </pre></td>
    </tr>
    <tr id="element_view-processor_input-view">
      <th><pre>input-view</pre></th>
      <td><pre>(1 | 0)</pre></td>
      <td><pre>"1"</pre></td>
      <td>No</td>
      <td><pre>whether or not the output of the &quot;view&quot; or preceding
&quot;view-processor&quot; will be input directly to the STDIN for this 
program. if the program requires input as a file, then use 
the {$outputFile} in the args attribute as defined above
</pre></td>
    </tr>
    <tr id="element_view-processor_output-file-path">
      <th><pre>output-file-path</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>the path to the output file. this attribute may contain
the {$randomFile[N]}, {LENGTH}, or {$attr[_subAttr]} variables 
which will be converted to their corresponding values as 
defined above. If this attribute is not specified, then the 
output will be retrieved from the STDOUT for the program
</pre></td>
    </tr>
    <tr id="element_view-processor_path">
      <th><pre>path</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>the path to the command line utility that should be run
 </pre></td>
    </tr>
    <tr id="element_view-processor_post-process-cmd">
      <th><pre>post-process-cmd</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>a command or commands (separated by ;) to be executed
after running the command line program. any of the &quot;args&quot;
variables ({$outputFile}, {$randomFile[N]}, {LENGTH}, or
{$attr[_subAttr]}) may also be specified in this attribute
</pre></td>
    </tr>
    <tr id="element_view-processor_pre-process-cmd">
      <th><pre>pre-process-cmd</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>a command or commands (separated by ;) to be executed
prior to running the command line program. any of the &quot;args&quot;
variables ({$outputFile}, {$randomFile[N]}, {LENGTH}, or 
{$attr[_subAttr]}) may also be specified in this attribute

</pre></td>
    </tr>
  </table>

 <hr />  <a href="#top" style="float:right">Top</a>
  <h3 id="element_index">index</h3>
  <pre>The &quot;index&quot; element defines a single index to add to the generated ddl for this 
entity model. indexes should be used to optimize database queries. for example, 
if you know you will query frequently on a particular non-primary key column, 
then by adding an index for that table/column the performance of those queries 
will be significantly improved. indexes should only be added if &quot;ddl-path&quot; is 
defined or &quot;sync-schema&quot; is TRUE in the enclosing &quot;entity-model&quot; element. the 
sql that is generated for each defined index will be of the form:
CREATE INDEX [name] ON [table] ([columns]) [postfix]</pre>
  <h4>Used In</h4>
  <ul>
    <li><a href="#element_entity-model">entity-model</a></li>
  </ul>

  <h4>Sub Elements</h4>
  <p>This element does not have any sub-elements</p>

  <h4>Attributes</h4>
  <table border="1">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default Value</th>
      <th>Required?</th>
      <th>Comment</th>
    </tr>
    <tr id="element_index_key">
      <th><pre>key</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>the unique name for this index
 </pre></td>
    </tr>
    <tr id="element_index_columns">
      <th><pre>columns</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>the columns included in this index. database vendor specific
definitions can be applied if supported. this attribute is 
required
</pre></td>
    </tr>
    <tr id="element_index_modifier">
      <th><pre>modifier</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>an optional index modifier (for mysql: [UNIQUE|FULLTEXT|SPATIAL])
if specified, this value will be inserted after &quot;CREATE&quot; and 
before &quot;INDEX&quot; in the generated sql for this index. database 
vendor specific modifiers may be used if supported
</pre></td>
    </tr>
    <tr id="element_index_postfix">
      <th><pre>postfix</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>any additional sql to append to the CREATE INDEX statement
 </pre></td>
    </tr>
    <tr id="element_index_table">
      <th><pre>table</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>the table to apply this index to

</pre></td>
    </tr>
  </table>

 <hr />  <a href="#top" style="float:right">Top</a>
  <h3 id="element_ws">ws</h3>
  <pre>The &quot;ws&quot; element is used to define a single entity specific web service exposed 
through the &quot;ws-gateway-uri&quot; defined for this entity model. this element 
specifies how an entity may be accessed and manipulated via a ajax/rest/soap 
web service request. this includes security implications as well as access 
control. web services can only be exposed if &quot;ws-gateway-uri&quot; has been defined 
in the enclosing entity-model. ONLY those web services specified in the 
entity-model for a given entity can be accessed. if this service contains 
multiple constraint groups, they will be joined using the AND connective. web 
services may allow users to CREATE, DELETE, RETRIEVE and UPDATE entities of the 
enclosing type. By default only the retrieve functionality is enabled. at least 
1 of the CRUD functional flags MUST be enabled. for information on how to invoke 
a web service review the documentation provided in sra-ws-gateway.php</pre>
  <h4>Used In</h4>
  <ul>
    <li><a href="#element_entity">entity</a></li>
  </ul>

  <h4>Sub Elements</h4>
  <table border="1">
    <tr>
      <th>Sub Element</th>
      <th>Required?</th>
      <th>More than one?</th>
    </tr>
    <tr>
      <td><pre><a href="#element_ws-constraint-group">ws-constraint-group</a></pre></td>
      <td>No</td>
      <td>Yes</td>
    </tr>
  </table>

  <h4>Attributes</h4>
  <table border="1">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default Value</th>
      <th>Required?</th>
      <th>Comment</th>
    </tr>
    <tr id="element_ws_key">
      <th><pre>key</pre></th>
      <td><pre>ID</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>the web service name. this MUST be unique within the entire entity
model, or combination of entity models for a given application 
instance otherwise the gateway will be unable to determine how to 
route service requests
</pre></td>
    </tr>
    <tr id="element_ws_api">
      <th><pre>api</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>the resource key to use for api documentation for this service. it
is used by the sra-ws-gateway.php for automatic generation of 
service api/wsdl documentation. if not specified, the 
documentation will be auto-generated
</pre></td>
    </tr>
    <tr id="element_ws_authenticate">
      <th><pre>authenticate</pre></th>
      <td><pre>(0 | 1)</pre></td>
      <td><pre>"1"</pre></td>
      <td>No</td>
      <td><pre>whether or not to authenticate clients invoking this service (an
authenticator must be configured for the the sra-ws-gateway.php 
script). if false, authentication will be bypassed even if it has 
been specified for the script
</pre></td>
    </tr>
    <tr id="element_ws_create">
      <th><pre>create</pre></th>
      <td><pre>(0 | 1)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>can a user use this service to CREATE a new instance of this
entity. creating an entity will be subject to the same constraints 
specified for the service. equality attribute constraints 
(operator 1) will implicitely be SET to the entity instance IF 
auto-set is true, and the remaining constraints validated. if the 
service utilizes any constraint groups using the &quot;or&quot; connective, 
then if a matching non-attribute constraint is evaluated to TRUE 
first, no change will be made to the entity instance, otherwise, 
if the first attribute constraint will be evaluated (where an 
equality constraint will result in that value being set). for 
example, if a constraint group specifies that the &quot;name&quot; attribute 
must be &quot;Tom&quot; or &quot;Tim&quot; and the attr value specified for name in 
the request is &quot;Jim&quot;, that name will be changed to &quot;Tom&quot;. however, 
if the request &quot;name&quot; value is &quot;Tom&quot; or &quot;Tim&quot; it will not be 
changed. If that same constraint group had an initial constraint 
specifying that a global variable $uid == 1 and that constraint 
matched, then the validation will short-circuit and the name would 
not be changed regardless of the value for it specified in the 
request. if any constraint group fails to validate the new entity 
object, &quot;ws-status&quot; will be 
SRA_WS_REQUEST_STATUS_INVALID_PERMISSIONS. if a user attempts to 
create an entity when that function is not enabled &quot;ws-status&quot; 
will be SRA_WS_REQUEST_STATUS_NOT_ALLOWED
</pre></td>
    </tr>
    <tr id="element_ws_delete">
      <th><pre>delete</pre></th>
      <td><pre>(0 | 1)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>can the user use this service to DELETE an existing instance of
this entity? in order to be able to delete the entity instance, 
the user MUST be able to access it first. if the user does not 
have access to the entity &quot;ws-status&quot; will be 
SRA_WS_REQUEST_STATUS_INVALID_PERMISSIONS. if a user attempts to 
delete an entity when that function is not enabled &quot;ws-status&quot; 
will be SRA_WS_REQUEST_STATUS_NOT_ALLOWED
</pre></td>
    </tr>
    <tr id="element_ws_exclude-attrs">
      <th><pre>exclude-attrs</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>space or comma separated list of the names of attributes that
should be excluded from the output of this service for a 
particular entity instance. these will be passed in the form of 
&quot;skipAttributes&quot; parameters to the &quot;render&quot;, &quot;toJson&quot; or &quot;toXml&quot; 
methods depending on the output type of this service. all allowed 
attributes not included in this list will be included in the 
output. if exclude-attrs are specified and attributes are set as 
part of a create or update service request that exist in 
exclude-attrs, &quot;ws-status&quot; will be 
SRA_WS_REQUEST_STATUS_INVALID_ATTRS. This attribute may include 
sub-attribute filters using &#039;_&#039;. the value &quot;_pk_&quot; will be 
automatically substituted with the name of the primary key 
attribute
</pre></td>
    </tr>
    <tr id="element_ws_format">
      <th><pre>format</pre></th>
      <td><pre>(json | xml | raw)</pre></td>
      <td><pre>"json"</pre></td>
      <td>No</td>
      <td><pre>the default response format to use for this service: either
&quot;json&quot;, &quot;xml&quot; or &quot;raw&quot; formats are supported. however, &quot;raw&quot; is 
only allowed if a &quot;view&quot; is specified for this service
</pre></td>
    </tr>
    <tr id="element_ws_format-fixed">
      <th><pre>format-fixed</pre></th>
      <td><pre>(0 | 1)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>whether or not &quot;format&quot; is fixed, meaning the service client
cannot specify a different format using the &quot;ws-format&quot; request 
parameter
</pre></td>
    </tr>
    <tr id="element_ws_hidden">
      <th><pre>hidden</pre></th>
      <td><pre>(0 | 1)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>hidden services are services that can be utilized but are not
included in the auto-generated api documentation/wsdl
</pre></td>
    </tr>
    <tr id="element_ws_hidden-method">
      <th><pre>hidden-method</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>an optional path to a static method that should be invoked to
determine whether or not this service is hidden IF &#039;hidden&#039; is  
false (specified in the same format as the ws-global identifier 
when type is &#039;method&#039;). this method should return a boolean value, 
TRUE to hide, FALSE to display
</pre></td>
    </tr>
    <tr id="element_ws_include-attrs">
      <th><pre>include-attrs</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>space or comma separated list of the names of attributes that
should be included in the output of this service for a particular 
entity instance. these will be passed in the form of 
&quot;includeAttributes&quot; parameters to the &quot;render&quot;, &quot;toJson&quot; or 
&quot;toXml&quot; methods depending on the output type of this service. ONLY 
the allowed attributes included in this list will be included in 
the output. if include-attrs are specified and attributes are set 
as part of a create or update service request that do not exist in 
include-attrs, &quot;ws-status&quot; will be 
SRA_WS_REQUEST_STATUS_INVALID_ATTRS. This attribute may include 
sub-attribute filters using &#039;_&#039;. the value &quot;_pk_&quot; will be 
automatically substituted with the name of the primary key 
attribute. in addition to attribute names, method names may also 
be specified
</pre></td>
    </tr>
    <tr id="element_ws_ip-authenticator">
      <th><pre>ip-authenticator</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>an optional fixed or app relative path to a PHP source file
              containing an ip address authentication method to be invoked (with 
              or without the &quot;.php&quot; file extension) followed by &quot;::&quot; and the 
              method name. i.e. &quot;dir/WebServiceIpAuthenticator::authenticate&quot; 
              where &quot;WebServiceIpAuthenticator.php&quot; exists in the directory 
              [app]/lib/dir/. the file search path will be [app]/lib, [app], 
              [sierra], /. this method should have the following signature: 
              ($ip) : boolean and return TRUE if the IP is allowed, FALSE if it 
              is not. if a service is invoked from an invalid IP, the ws-status 
              SRA_WS_REQUEST_STATUS_IP_NOT_ALLOWED will be returned
</pre></td>
    </tr>
    <tr id="element_ws_limit">
      <th><pre>limit</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>the default sql limit for this web service output (the maximum
# of instances that meet the service call constraints to return). 
if not specified, all applicable instances will be returned, 
however large that may be - applies only when the &quot;retrieve&quot; flag 
is set
</pre></td>
    </tr>
    <tr id="element_ws_limit-fixed">
      <th><pre>limit-fixed</pre></th>
      <td><pre>(0 | 1)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>whether or not &quot;limit&quot; is fixed, meaning the client cannot
increase it using the &quot;ws-limit&quot; request parameter. if true, 
&quot;limit&quot; will be the default &quot;ws-limit&quot; unless &quot;ws-limit&quot; is 
specified by the client AND is less than &quot;limit&quot;
</pre></td>
    </tr>
    <tr id="element_ws_meta-format">
      <th><pre>meta-format</pre></th>
      <td><pre>(json | xml | none)</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>the default response metadata format. metadata includes such data
as the &quot;ws-time&quot;, &quot;ws-limit&quot;, &quot;ws-status&quot;, etc. for more 
information regarding metadata, see the documentation provided in 
sra-ws-gateway.php. metadata for a ws request can be represented 
using json or xml. additionally, if &quot;none&quot;, the metadata will not 
be included in the response output. if not specified, the default 
format will be the same as &quot;format&quot; (or the &quot;ws-format&quot; specified 
by the client) unless &quot;format&quot; is &quot;raw&quot; in which case the default 
&quot;meta-format&quot; will be &quot;none&quot;
</pre></td>
    </tr>
    <tr id="element_ws_meta-format-fixed">
      <th><pre>meta-format-fixed</pre></th>
      <td><pre>(0 | 1)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>whether or not &quot;meta-format&quot; is fixed, meaning the service
              client cannot specify a different format using the 
              &quot;ws-meta-format&quot; request parameter
              </pre></td>
    </tr>
    <tr id="element_ws_rest">
      <th><pre>rest</pre></th>
      <td><pre>(0 | 1)</pre></td>
      <td><pre>"1"</pre></td>
      <td>No</td>
      <td><pre>whether or not to enable this service via rest
 </pre></td>
    </tr>
    <tr id="element_ws_retrieve">
      <th><pre>retrieve</pre></th>
      <td><pre>(0 | 1)</pre></td>
      <td><pre>"1"</pre></td>
      <td>No</td>
      <td><pre>can this web service be used to retrieve entities (subject to the
service constraints). unlike &#039;create&#039;, &#039;delete&#039; and &#039;update&#039; the 
default value for this attribute is true
</pre></td>
    </tr>
    <tr id="element_ws_soap">
      <th><pre>soap</pre></th>
      <td><pre>(0 | 1)</pre></td>
      <td><pre>"1"</pre></td>
      <td>No</td>
      <td><pre>whether or not to enable this service via soap
 </pre></td>
    </tr>
    <tr id="element_ws_sub-entities">
      <th><pre>sub-entities</pre></th>
      <td><pre>(0 | 1)</pre></td>
      <td><pre>"1"</pre></td>
      <td>No</td>
      <td><pre>whether or not to set the &#039;insertSubEntities&#039;/&#039;updateSubEntities&#039;
 flags to TRUE (for CREATE and UPDATE invocations only). when true, 
 the &#039;validateSubEntities&#039; validation method will also be invoked 
 and any error messages resulting from it will be returned. by 
 default this attribute is true
 </pre></td>
    </tr>
    <tr id="element_ws_update">
      <th><pre>update</pre></th>
      <td><pre>(0 | 1)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>can the user use this service to UPDATE an existing instance of
this entity? the same rules apply to updating an entity as they do 
for creating an entity (see comments for &quot;create&quot; attribute above)
if a user attempts to update an entity when that function is not 
enabled &quot;ws-status&quot; will be SRA_WS_REQUEST_STATUS_NOT_ALLOWED
</pre></td>
    </tr>
    <tr id="element_ws_validators">
      <th><pre>validators</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>space or comma separated list of additional validation methods
that should be invoked when an update or create request is invoked
</pre></td>
    </tr>
    <tr id="element_ws_view">
      <th><pre>view</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>an optional entity view to use as the service response output
</pre></td>
    </tr>
    <tr id="element_ws_view-json">
      <th><pre>view-json</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>an optional entity view to use as the service response output when
the &quot;ws-format&quot; requested is json (or if &quot;format&quot; is &quot;json&quot; and 
&quot;format-fixed&quot; is true). if not specified, and &quot;view&quot; is specified 
and the requested response format is &quot;json&quot;, then the output of 
&quot;view&quot; will automatically be serialized to json format
</pre></td>
    </tr>
    <tr id="element_ws_view-xml">
      <th><pre>view-xml</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>an optional entity view to use as the service response output when
the &quot;ws-format&quot; requested is xml (or if &quot;format&quot; is &quot;xml&quot; and 
&quot;format-fixed&quot; is true). if not specified, and &quot;view&quot; is specified 
the response format &quot;xml&quot; will NOT be allowed


</pre></td>
    </tr>
  </table>

 <hr />  <a href="#top" style="float:right">Top</a>
  <h3 id="element_ws-constraint-group">ws-constraint-group</h3>
  <pre>The &quot;ws-constraint-group&quot; element is used to specify 1 or more ws-constraint 
sub-elements that will be evaluated as a whole based on the &quot;connective&quot; 
specified for the group (either conjunction or disjunction). the evaluation 
includes short-circuiting for conjunction join types (and)</pre>
  <h4>Used In</h4>
  <ul>
    <li><a href="#element_ws">ws</a></li>
  </ul>

  <h4>Sub Elements</h4>
  <table border="1">
    <tr>
      <th>Sub Element</th>
      <th>Required?</th>
      <th>More than one?</th>
    </tr>
    <tr>
      <td><pre><a href="#element_ws-constraint">ws-constraint</a></pre></td>
      <td>No</td>
      <td>Yes</td>
    </tr>
  </table>

  <h4>Attributes</h4>
  <table border="1">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default Value</th>
      <th>Required?</th>
      <th>Comment</th>
    </tr>
    <tr id="element_ws-constraint-group_connective">
      <th><pre>connective</pre></th>
      <td><pre>(and | or)</pre></td>
      <td><pre>"and"</pre></td>
      <td>No</td>
      <td><pre>whether the connective between constraints of this group should be
conjunctively or disjunctively joined


</pre></td>
    </tr>
  </table>

 <hr />  <a href="#top" style="float:right">Top</a>
  <h3 id="element_ws-constraint">ws-constraint</h3>
  <pre>The &quot;ws-constraint&quot; element is used to add implicit security or filter related 
constraint to an web service. the &quot;ws-gateway-uri&quot; may be secured through 
the sierra-php app authentication, however, past that, without any service 
constraints for a given entity web service (&quot;ws&quot;), an authenticated user (or 
non-authenticated user if the &quot;ws-gateway-uri&quot; script is not secured) may 
utilize that service. if constraints overlap between the request and the ws 
definition, the definition constraints will override those in the request</pre>
  <h4>Used In</h4>
  <ul>
    <li><a href="#element_ws-constraint-group">ws-constraint-group</a></li>
  </ul>

  <h4>Sub Elements</h4>
  <p>This element does not have any sub-elements</p>

  <h4>Attributes</h4>
  <table border="1">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default Value</th>
      <th>Required?</th>
      <th>Comment</th>
    </tr>
    <tr id="element_ws-constraint_attr">
      <th><pre>attr</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>the constraint attribute identifier (see attr-type for more info).
if attr-type is specified, and the attr desired is part of an 
entity within that type, then the key and attribute can be 
separated by a &#039;_&#039;. for example, if the attr-type was &quot;global&quot; and 
there existed an User object within the globals indexed under the 
key &quot;user&quot;, and the actual attr desired was the &quot;uid&quot; attribute of 
that object, the key would be &quot;user_uid&quot;. the &quot;uid&quot; portion will 
then be passed to the &quot;getAttribute&quot; method of the global $user 
object instance
</pre></td>
    </tr>
    <tr id="element_ws-constraint_attr-type">
      <th><pre>attr-type</pre></th>
      <td><pre>(attr | constant | get | getAttr | global | post | session)</pre></td>
      <td><pre>"attr"</pre></td>
      <td>No</td>
      <td><pre>defines where the attribute to be constrained exists. only entity
instances that exist where this constraint is true will be 
included in the service output. following is a definition of the 
applicable types:

 attr:    attr is the name of an attribute/sub attribute
 constant:attr is the name of a php constant (or other php code)
 get:     attr is the name of a value in the get headers
 getAttr: attr is a &#039;getAttribute&#039; value for the entity. used only 
          for &#039;retrieve&#039; service. when used limit/offset should 
          not be used when using the service
 global:  attr is the name of a php global variable
 post:    attr is the name of a value in the post headers
 session: attr is the name of a session variable
</pre></td>
    </tr>
    <tr id="element_ws-constraint_auto-set">
      <th><pre>auto-set</pre></th>
      <td><pre>(0 | 1)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>whether or not this attribute should be automatically set for
create and update requests. this only applies if operation 
contains the equality bit (1) for this constraint value
</pre></td>
    </tr>
    <tr id="element_ws-constraint_operator">
      <th><pre>operator</pre></th>
      <td><pre>CDATA</pre></td>
      <td><pre>"1"</pre></td>
      <td>No</td>
      <td><pre>a bitmask containing one or more of the following operator
values. these define how &quot;attr&quot; and &quot;value&quot; should be compared:
 
 EQUALITY CONSTRAINTS
 1:    attr and value must be equal
 2:    attr is greater than value
 4:    attr is less than value
 
 STRING CONSTRAINTS (only 1 constraint allowed if used)
 8:    attr starts with value
 16:   attr ends with value
 32:   attr is a sub-string of value (full text search)
 
 SORTING CONSTRAINTS
 64:   sort the results by attr in ascending order
 128:  sort the results by attr in descending order
 
 NEGATE BIT
 256:  negate the results of any of the above operator constraints
</pre></td>
    </tr>
    <tr id="element_ws-constraint_value">
      <th><pre>value</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>the constraint value (or value identifier if value-type is
specified). if value-type is specified, and the value desired is 
part of an entity within that type, then the key and attribute 
can be separated by a &#039;_&#039;. for example, if the value-type was 
&quot;global&quot; and there existed an User object within the globals 
indexed under the key &quot;user&quot;, and the actual value desired was the 
&quot;uid&quot; attribute of that object, the value would be &quot;user_uid&quot;. the 
&quot;uid&quot; portion will then be passed to the &quot;getAttribute&quot; method of 
the global $user object instance. if the value is an array then 
the constraint will be applied for each array value using the 
enclosing constraint group connective
</pre></td>
    </tr>
    <tr id="element_ws-constraint_value-type">
      <th><pre>value-type</pre></th>
      <td><pre>(constant | get | global | post | session)</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>if the value for this constraint is not provided explicitely in
the &quot;value&quot; attribute above (the default behavior), then this 
attribute defines where the value exists. must be one of the 
following values:
 
 constant:value is the name of a php constant (or other php code)
 get:     value is the name of a value in the get headers
 global:  value is the name of a php global variable
 post:    value is the name of a value in the post headers
 session: value is the name of a session variable


</pre></td>
    </tr>
  </table>

 <hr />  <a href="#top" style="float:right">Top</a>
  <h3 id="element_ws-global">ws-global</h3>
  <pre>the &quot;ws-global&quot; element is used to define a web service that will be exposed 
using the &quot;ws-gateway-uri&quot; for this entity model. unlike &quot;ws&quot;, &quot;ws-global&quot; 
services are less structured and not entity specific. this element contains 0..* 
nested &quot;ws-param&quot; elements (see documentation provided below). the use of these 
nested elements varies as does the output depending on the service &quot;type&quot;. for 
information on how to invoke a web service review the documentation provided in 
sra-ws-gateway.php

TYPE DEPENDENT I/O:

method:
 ws-param:
 *        all params will be passed to the method in the form of an associative 
          array where the key is the param key and the value is the param value
          
 RESULTS OUTPUT
 the return value will be whatever value is returned by the method serialized 
 according to the &quot;format&quot; specified. method return values can be null, scalar, 
 an object, map or an array. for the latter three, the results will be an 
 associative array according to the object properties/values or array 
 keys/values. if the method invocation returns an SRA_Error object, &quot;ws-status&quot; 
 will be SRA_WS_REQUEST_STATUS_FAILED. If the return value is an array and 
 contains the key SRA_WS_RESULT_COUNT_KEY, that value will be returned as 
 the &#039;ws-count&#039; meta value in the results (and removed from the return value).
 NOTE: if &quot;format&quot; is &quot;xml&quot;, the method output must be an object or array of 
 objects that have a &quot;renderXml&quot; method or the &quot;ws-status&quot; will be 
 SRA_WS_REQUEST_STATUS_FAILED
 
 Note: api and wsdl documentation for this service type will be retrieved using 
       the SRA_Util::parsePhpSource method. using this documentation format, you 
       may specify the type of api documentation to use for the method 
       method parameters. additionally, the method api documentation will be 
       used to document this service is &quot;api&quot; is not specified

sql:  
 ws-param:
 *        dynamic sql params. the &quot;key&quot; value for these params can be nested in 
          the sql statement beginning and ending with a &quot;#&quot; symbol and will be 
          replaced at runtime with the appropriate value
 RESULTS OUTPUT
 SELECT queries:                 json: an array of associative arrays each 
                                 representing one row of the results where the 
                                 key in the associative array is the column name 
                                 (or alias) assigned in the sql query 
                                 (serialized according to the &quot;output&quot; type 
                                 specified
                                 xml: &lt;query-results&gt;
                                        &lt;row key=&quot;[row num]&quot;&gt;
                                          &lt;col key=&quot;[col name]&quot;&gt;&lt;![CDATA[[col value]]]&gt;&lt;/col&gt;
                                        &lt;/row&gt;
                                      &lt;/query-results&gt;
                                 raw: NOT SUPPORTED
 DELETE, INSERT, UPDATE queries: empty - &quot;ws-count&quot; will be the # of rows 
                                 affected by the query
 
rb: 
 ws-param:
 keys       the names of the resource bundle values to return (separated by 
            spaces). if not specified, all strings in the identified bundle will 
            be returned
 search     search string. the search is not case sensitive
 beginsWith begins with search string. the search is not case sensitive
 endsWith   ends with search string. the search is not case sensitive
 
 RESULTS OUTPUT
 json: an associative array of the resource bundle strings (names/values)
 xml:  &lt;resource-bundle path=&quot;[identifier attr value]&quot;&gt;
         &lt;string key=&quot;[resource name]&quot;&gt;&lt;![CDATA[[resource value]]]&gt;&lt;/string&gt;
       &lt;/resource-bundle&gt;
 raw: NOT SUPPORTED</pre>
  <h4>Used In</h4>
  <ul>
    <li><a href="#element_entity-model">entity-model</a></li>
  </ul>

  <h4>Sub Elements</h4>
  <table border="1">
    <tr>
      <th>Sub Element</th>
      <th>Required?</th>
      <th>More than one?</th>
    </tr>
    <tr>
      <td><pre><a href="#element_ws-param">ws-param</a></pre></td>
      <td>No</td>
      <td>Yes</td>
    </tr>
  </table>

  <h4>Attributes</h4>
  <table border="1">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default Value</th>
      <th>Required?</th>
      <th>Comment</th>
    </tr>
    <tr id="element_ws-global_key">
      <th><pre>key</pre></th>
      <td><pre>ID</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>the global service name. this MUST be unique within the entire
entity model, or combination of entity models for a given 
application instance
</pre></td>
    </tr>
    <tr id="element_ws-global_api">
      <th><pre>api</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>the resource key to use for api documentation for this service. it
is used by the sra-ws-gateway.php for automatic generation of 
service api/wsdl documentation. if not specified, the 
documentation will be auto-generated
</pre></td>
    </tr>
    <tr id="element_ws-global_authenticate">
      <th><pre>authenticate</pre></th>
      <td><pre>(0 | 1)</pre></td>
      <td><pre>"1"</pre></td>
      <td>No</td>
      <td><pre>whether or not to authenticate clients invoking this service (an
authenticator must be configured for the the sra-ws-gateway.php 
script). if false, authentication will be bypassed even if it has 
been specified for the script
</pre></td>
    </tr>
    <tr id="element_ws-global_format">
      <th><pre>format</pre></th>
      <td><pre>(json | xml | raw)</pre></td>
      <td><pre>"json"</pre></td>
      <td>No</td>
      <td><pre>the default response format to use for this service: either
&quot;json&quot;, &quot;xml&quot; or &quot;raw&quot; formats are supported. however, &quot;raw&quot; is 
only allowed for method type services
</pre></td>
    </tr>
    <tr id="element_ws-global_format-fixed">
      <th><pre>format-fixed</pre></th>
      <td><pre>(0 | 1)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>whether or not &quot;format&quot; is fixed, meaning the service client
cannot specify a different format using the &quot;ws-format&quot; request 
parameter
</pre></td>
    </tr>
    <tr id="element_ws-global_hidden">
      <th><pre>hidden</pre></th>
      <td><pre>(0 | 1)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>hidden services are services that can be utilized but are not
included in the auto-generated api documentation/wsdl
</pre></td>
    </tr>
    <tr id="element_ws-global_hidden-method">
      <th><pre>hidden-method</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>an optional path to a static method that should be invoked to
determine whether or not this service is hidden IF &#039;hidden&#039; is  
false (specified in the same format as the ws-global identifier 
when type is &#039;method&#039;). this method should return a boolean value, 
TRUE to hide, FALSE to display
</pre></td>
    </tr>
    <tr id="element_ws-global_identifier">
      <th><pre>identifier</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>the identifier for this service. the value for this attribute will
vary depending on the service type:
 method: the fixed or app relative path to the PHP source file 
         containing the method to be invoked (with or without the
         &quot;.php&quot; file extension) followed by &quot;::&quot; and the method 
         name. i.e. &quot;dir/MyClass::myMethod&quot; where &quot;MyClass.php&quot; 
         exists in the file [app]/lib/dir/MyClass.php. the file 
         search path will be [app]/lib, [app], [sierra], /. this 
         method should have the following signature: 
         ($params, $limit, $offset) where $params is an 
         associative array
 sql:    the base sql query. this query may contain dynamic 
         parameters utilizing the nested ws-param 
         elements
 rb:     the relative or full path to the resource bundle
 </pre></td>
    </tr>
    <tr id="element_ws-global_introspect-api">
      <th><pre>introspect-api</pre></th>
      <td><pre>(0 | 1)</pre></td>
      <td><pre>"1"</pre></td>
      <td>No</td>
      <td><pre>whether or not to introspect the class for api documentation if
              this is a method type service. this documentation will be used 
              then in the auto generation of api documentation. for more 
              information, see the documentation provided in 
              SRA_Util::parsePhpSource regarding how to document source files. 
              Both method and param comments will be used. Additionally, the 
              limit/offset request input documentation will only be displayed IF 
              those are defined as the latter 2 parameters for that method (must 
              use the param names: $limit and $offset). Additionally, the api 
              comments for those parameters will be used as the comments for 
              the request api documentation
              </pre></td>
    </tr>
    <tr id="element_ws-global_ip-authenticator">
      <th><pre>ip-authenticator</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>an optional fixed or app relative path to a PHP source file
              containing an ip address authentication method to be invoked (with 
              or without the &quot;.php&quot; file extension) followed by &quot;::&quot; and the 
              method name. i.e. &quot;dir/WebServiceIpAuthenticator::authenticate&quot; 
              where &quot;WebServiceIpAuthenticator.php&quot; exists in the directory 
              [app]/lib/dir/. the file search path will be [app]/lib, [app], 
              [sierra], /. this method should have the following signature: 
              ($ip) : boolean and return TRUE if the IP is allowed, FALSE if it 
              is not. if a service is invoked from an invalid IP, the ws-status 
              SRA_WS_REQUEST_STATUS_IP_NOT_ALLOWED will be returned
               </pre></td>
    </tr>
    <tr id="element_ws-global_limit">
      <th><pre>limit</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>the default sql limit for this service output. if not specified,
no limit will be applied to the sql query (applies only to sql 
type services). if specified for a resource bundle request, a 
maximum of this number of strings will be returned. this value (if 
specified) will be passed as the 2nd parameter to method type 
global services
</pre></td>
    </tr>
    <tr id="element_ws-global_limit-fixed">
      <th><pre>limit-fixed</pre></th>
      <td><pre>(0 | 1)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>whether or not &quot;limit&quot; is fixed, meaning the client cannot
increase it using the &quot;ws-limit&quot; request parameter. if true, 
&quot;limit&quot; will be the default &quot;ws-limit&quot; unless &quot;ws-limit&quot; is 
specified by the client AND is less than &quot;limit&quot;
</pre></td>
    </tr>
    <tr id="element_ws-global_meta-format">
      <th><pre>meta-format</pre></th>
      <td><pre>(json | xml | none)</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>the default response metadata format. metadata includes such data
as the &quot;ws-time&quot;, &quot;ws-limit&quot;, &quot;ws-status&quot;, etc. for more 
information regarding metadata, see the documentation provided in 
sra-ws-gateway.php. metadata for a ws request can be represented 
using json or xml. additionally, if &quot;none&quot;, the metadata will not 
be included in the response output. if not specified, the default 
format will be the same as &quot;format&quot; (or the &quot;ws-format&quot; specified 
by the client) unless &quot;format&quot; is &quot;raw&quot; in which case the default 
&quot;meta-format&quot; will be &quot;none&quot;
</pre></td>
    </tr>
    <tr id="element_ws-global_meta-format-fixed">
      <th><pre>meta-format-fixed</pre></th>
      <td><pre>(0 | 1)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>whether or not &quot;meta-format&quot; is fixed, meaning the service
              client cannot specify a different format using the 
              &quot;ws-meta-format&quot; request parameter
              </pre></td>
    </tr>
    <tr id="element_ws-global_rest">
      <th><pre>rest</pre></th>
      <td><pre>(0 | 1)</pre></td>
      <td><pre>"1"</pre></td>
      <td>No</td>
      <td><pre>whether or not to enable this service via rest
</pre></td>
    </tr>
    <tr id="element_ws-global_soap">
      <th><pre>soap</pre></th>
      <td><pre>(0 | 1)</pre></td>
      <td><pre>"1"</pre></td>
      <td>No</td>
      <td><pre>whether or not to enable this service via soap
</pre></td>
    </tr>
    <tr id="element_ws-global_type">
      <th><pre>type</pre></th>
      <td><pre>(method | rb | sql)</pre></td>
      <td><pre>"method"</pre></td>
      <td>No</td>
      <td><pre>the service type. must be one of the following:
  method: exposes a static class method
  sql:    exposes an sql query execution
  rb:     exposes the strings specified in a resource bundle

</pre></td>
    </tr>
  </table>

 <hr />  <a href="#top" style="float:right">Top</a>
  <h3 id="element_ws-param">ws-param</h3>
  <pre>The &quot;ws-param&quot; element is used to provide a generic means to specifying runtime 
parameters for a global web service (&quot;ws-global&quot;). the value should be imbedded 
between the open and close tags of this element (use &lt;![CDATA[]]&gt; to avoid 
having escape special characters) or specified as the &quot;value&quot; attribute</pre>
  <h4>Used In</h4>
  <ul>
    <li><a href="#element_ws-global">ws-global</a></li>
  </ul>

  <h4>Sub Elements</h4>
  <table border="1">
    <tr>
      <th>Sub Element</th>
      <th>Required?</th>
      <th>More than one?</th>
    </tr>
    <tr>
      <td><pre>#PCDATA</pre></td>
      <td>Yes</td>
      <td>No</td>
    </tr>
  </table>

  <h4>Attributes</h4>
  <table border="1">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default Value</th>
      <th>Required?</th>
      <th>Comment</th>
    </tr>
    <tr id="element_ws-param_key">
      <th><pre>key</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>the name of the parameter. must be unique within the enclosing
element
   </pre></td>
    </tr>
    <tr id="element_ws-param_allow-override">
      <th><pre>allow-override</pre></th>
      <td><pre>(0 | 1)</pre></td>
      <td><pre>"0"</pre></td>
      <td>No</td>
      <td><pre>whether or not this parameter can be overriden by the request. if
false, and this same parameter is specified in a ws request, the 
request parameter will be ignored
</pre></td>
    </tr>
    <tr id="element_ws-param_value">
      <th><pre>value</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>if the value is simple, it may be imbedded using a value
attribute instead of between the open and close tags
</pre></td>
    </tr>
    <tr id="element_ws-param_value-type">
      <th><pre>value-type</pre></th>
      <td><pre>(get | global | post | session | file)</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>the value type (see usage documentation for ws-constraint
value-type above). an additional value type &quot;file&quot; is also 
supported meaning that &quot;value&quot; is the name of an uploaded file
(present in the $_FILES super global)

</pre></td>
    </tr>
  </table>

 <hr />  <a href="#top" style="float:right">Top</a>
  <h3 id="element_msg">msg</h3>
  <pre>The &quot;msg&quot; element defines a key/value pair that will be used when &#039;depends&#039; 
validation errors occur</pre>
  <h4>Used In</h4>
  <ul>
    <li><a href="#element_entity-model">entity-model</a></li>
    <li><a href="#element_entity">entity</a></li>
    <li><a href="#element_attribute">attribute</a></li>
  </ul>

  <h4>Sub Elements</h4>
  <p>This element does not have any sub-elements</p>

  <h4>Attributes</h4>
  <table border="1">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default Value</th>
      <th>Required?</th>
      <th>Comment</th>
    </tr>
    <tr id="element_msg_key">
      <th><pre>key</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>the name of the &#039;depends&#039; validation constraint. automatic
                  data types validation constraints &quot;boolean&quot;, &quot;date&quot;, &quot;integer&quot; 
                  and &quot;numeric&quot; can be specified individually, by their 
                  corresponding names, or globally using the key &quot;type&quot; (SRA_ATTRIBUTE_TYPE_MSG_KEY).
                  However, the global message &quot;type&quot; will only be used if the 
                  validation constraint is implicitily assigned (i.e. an 
                  explicit depends=&quot;(boolean|date|integer|numeric)&quot; is not 
                  used in the entity model xml in which case those constraints 
                  will automatically be assigned to attributes of those types)
</pre></td>
    </tr>
    <tr id="element_msg_resource">
      <th><pre>resource</pre></th>
      <td><pre>Resource</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>key in the application SRA_ResourceBundle reference the string
that should be displayed when the validation error is 
triggered for an attribute. this resource may contain the 
string may contain the variable {$attr} which will be substituted 
for the attribute label at runtime whever the message is 
utilized

</pre></td>
    </tr>
  </table>

 <hr />  <a href="#top" style="float:right">Top</a>
  <h3 id="element_param">param</h3>
  <pre>The &quot;param&quot; element defines a generic key/value pair. when used in a &quot;view&quot;, 
these params will be passed into the corresponding templates encapsulated as a 
SRA_Params object</pre>
  <h4>Used In</h4>
  <ul>
    <li><a href="#element_view">view</a></li>
  </ul>

  <h4>Sub Elements</h4>
  <p>This element does not have any sub-elements</p>

  <h4>Attributes</h4>
  <table border="1">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default Value</th>
      <th>Required?</th>
      <th>Comment</th>
    </tr>
    <tr id="element_param_id">
      <th><pre>id</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>the param name
</pre></td>
    </tr>
    <tr id="element_param_type">
      <th><pre>type</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>the param type
</pre></td>
    </tr>
    <tr id="element_param_value">
      <th><pre>value</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>No</td>
      <td><pre>the param value. the value {SRA_DIR} will be substituted for
the path to the framework (i.e. /var/www/sierra) and the value 
{APP_DIR} will be substituted with the path to the application
(i.e. /var/www/sierra/app/sraos). These value may be nested 
within this attribute (i.e. &quot;{APP_DIR}/etc/style.xsl&quot;)

</pre></td>
    </tr>
  </table>

 <hr />  <a href="#top" style="float:right">Top</a>
  <h3 id="element_var">var</h3>
  <pre>The &quot;var&quot; element defines a key/value pair that will be passed into 
SRA_AttributeValidator::{method} for &#039;depends&#039; validation contraints (the second 
parameter of all SRA_AttributeValidator methods accepts an associative array of 
key/value pairs). this array will also be passed into the 
SRA_ResourceBundle::getString method when retrieving the &#039;msg&#039; specified for that 
error.</pre>
  <h4>Used In</h4>
  <ul>
    <li><a href="#element_attribute">attribute</a></li>
  </ul>

  <h4>Sub Elements</h4>
  <p>This element does not have any sub-elements</p>

  <h4>Attributes</h4>
  <table border="1">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default Value</th>
      <th>Required?</th>
      <th>Comment</th>
    </tr>
    <tr id="element_var_key">
      <th><pre>key</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>the name of the &#039;depends&#039; validation constraint
</pre></td>
    </tr>
    <tr id="element_var_value">
      <th><pre>value</pre></th>
      <td><pre>CDATA</pre></td>
      <td>None</td>
      <td>Yes</td>
      <td><pre>key in the application SRA_ResourceBundle reference the string
that should be displayed when the validation error is 
triggered for an attribute

</pre></td>
    </tr>
  </table>

  
  </form>
</body>
</html>