<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>util.SRA_File - sierra-php v1.1.3</title>
<script type="text/javascript">
<!--
var _qsAbortNext = false;
var _tipsIdx = 0;
var _tipIds;

function clearQsTips() {
  document.getElementById('quicksearch_tips').innerHTML = '';
}
function hideQsTips() {
  setTimeout("document.getElementById('quicksearch_tips').style.display = 'none'", 100);
}
function showQsTips() {
  document.getElementById('quicksearch_tips').style.display = '';
}
function qsTipsVisible() {
  return document.getElementById('quicksearch_tips').style.display != 'none';
}
function updateQsTips(evt) {
  if (qsTipsVisible() && evt && (evt.keyCode == 40 || evt.keyCode == 38 || evt.keyCode == 13)) {
    switch(evt.keyCode) {
      // up
      case 38:
      // down
      case 40:
        if (_tipsIdx >= 0) document.getElementById(_tipIds[_tipsIdx]).style.backgroundColor = '';
        evt.keyCode == 38 ? _tipsIdx-- : _tipsIdx++;
        if (_tipsIdx > _tipIds.length) _tipsIdx = 0;
        if (_tipsIdx < 0) _tipsIdx = _tipIds.length - 1;
        if (_tipsIdx >= 0) document.getElementById(_tipIds[_tipsIdx]).style.backgroundColor = '#ddd';
        break;
      // enter
      case 13:
        if (_tipsIdx >= 0 && _tipIds[_tipsIdx]) {
          document.location.replace('#' + _tipIds[_tipsIdx].substr(3));
        }
        break;
    }
    return;
  }
  
  _tipsIdx = -1;
  _tipIds = [];
  var str = document.getElementById('quicksearch').value.toLowerCase();
  var matches = {}
  var match = false;
  
  if (str) {
  // check constants
  if ("sra_file_mime_type_file".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_FILE_MIME_TYPE_FILE'] = "SRA_FILE_MIME_TYPE_FILE";
  }
  if ("sra_file_debug".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_FILE_DEBUG'] = "SRA_FILE_DEBUG";
  }
  if ("sra_file_cache_dir".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_FILE_CACHE_DIR'] = "SRA_FILE_CACHE_DIR";
  }


  // check methods
  if ("copy".indexOf(str) != -1) {
    match = true;
    matches['qs_method_copy'] = "copy";
  }
  if ("findinpath".indexOf(str) != -1) {
    match = true;
    matches['qs_method_findInPath'] = "findInPath";
  }
  if ("move".indexOf(str) != -1) {
    match = true;
    matches['qs_method_move'] = "move";
  }
  if ("rename".indexOf(str) != -1) {
    match = true;
    matches['qs_method_rename'] = "rename";
  }
  if ("_mkdir".indexOf(str) != -1) {
    match = true;
    matches['qs_method__mkdir'] = "_mkdir";
  }
  if ("mkdir".indexOf(str) != -1) {
    match = true;
    matches['qs_method_mkdir'] = "mkdir";
  }
  if ("chgrp".indexOf(str) != -1) {
    match = true;
    matches['qs_method_chgrp'] = "chgrp";
  }
  if ("chown".indexOf(str) != -1) {
    match = true;
    matches['qs_method_chown'] = "chown";
  }
  if ("chmod".indexOf(str) != -1) {
    match = true;
    matches['qs_method_chmod'] = "chmod";
  }
  if ("unlink".indexOf(str) != -1) {
    match = true;
    matches['qs_method_unlink'] = "unlink";
  }
  if ("symlink".indexOf(str) != -1) {
    match = true;
    matches['qs_method_symlink'] = "symlink";
  }
  if ("touch".indexOf(str) != -1) {
    match = true;
    matches['qs_method_touch'] = "touch";
  }
  if ("dirlist".indexOf(str) != -1) {
    match = true;
    matches['qs_method_dirlist'] = "dirlist";
  }
  if ("_rmdir".indexOf(str) != -1) {
    match = true;
    matches['qs_method__rmdir'] = "_rmdir";
  }
  if ("rmdir".indexOf(str) != -1) {
    match = true;
    matches['qs_method_rmdir'] = "rmdir";
  }
  if ("umask".indexOf(str) != -1) {
    match = true;
    matches['qs_method_umask'] = "umask";
  }
  if ("read".indexOf(str) != -1) {
    match = true;
    matches['qs_method_read'] = "read";
  }
  if ("_write".indexOf(str) != -1) {
    match = true;
    matches['qs_method__write'] = "_write";
  }
  if ("write".indexOf(str) != -1) {
    match = true;
    matches['qs_method_write'] = "write";
  }
  if ("filemtime".indexOf(str) != -1) {
    match = true;
    matches['qs_method_fileMTime'] = "fileMTime";
  }
  if ("comparemtimes".indexOf(str) != -1) {
    match = true;
    matches['qs_method_compareMTimes'] = "compareMTimes";
  }
  if ("parseinifile".indexOf(str) != -1) {
    match = true;
    matches['qs_method_parseIniFile'] = "parseIniFile";
  }
  if ("getfilelist".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getFileList'] = "getFileList";
  }
  if ("createrandomfile".indexOf(str) != -1) {
    match = true;
    matches['qs_method_createRandomFile'] = "createRandomFile";
  }
  if ("deleterandomfiles".indexOf(str) != -1) {
    match = true;
    matches['qs_method_deleteRandomFiles'] = "deleteRandomFiles";
  }
  if ("tostring".indexOf(str) != -1) {
    match = true;
    matches['qs_method_toString'] = "toString";
  }
  if ("getmimetype".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getMimeType'] = "getMimeType";
  }
  if ("getarchivetype".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getArchiveType'] = "getArchiveType";
  }
  if ("uncompress".indexOf(str) != -1) {
    match = true;
    matches['qs_method_uncompress'] = "uncompress";
  }
  if ("compress".indexOf(str) != -1) {
    match = true;
    matches['qs_method_compress'] = "compress";
  }
  if ("findfile".indexOf(str) != -1) {
    match = true;
    matches['qs_method_findFile'] = "findFile";
  }
  if ("getcontents".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getContents'] = "getContents";
  }
  if ("appendtofile".indexOf(str) != -1) {
    match = true;
    matches['qs_method_appendToFile'] = "appendToFile";
  }
  if ("parseini".indexOf(str) != -1) {
    match = true;
    matches['qs_method_parseIni'] = "parseIni";
  }
  if ("arraytofile".indexOf(str) != -1) {
    match = true;
    matches['qs_method_arrayToFile'] = "arrayToFile";
  }
  if ("filetoarray".indexOf(str) != -1) {
    match = true;
    matches['qs_method_fileToArray'] = "fileToArray";
  }
  if ("serialize".indexOf(str) != -1) {
    match = true;
    matches['qs_method_serialize'] = "serialize";
  }
  if ("unserialize".indexOf(str) != -1) {
    match = true;
    matches['qs_method_unserialize'] = "unserialize";
  }
  if ("propertiesarraytofile".indexOf(str) != -1) {
    match = true;
    matches['qs_method_propertiesArrayToFile'] = "propertiesArrayToFile";
  }
  if ("propertiesfiletoarray".indexOf(str) != -1) {
    match = true;
    matches['qs_method_propertiesFileToArray'] = "propertiesFileToArray";
  }
  if ("cvstoarray".indexOf(str) != -1) {
    match = true;
    matches['qs_method_cvsToArray'] = "cvsToArray";
  }
  if ("findfirstmatchingpath".indexOf(str) != -1) {
    match = true;
    matches['qs_method_findFirstMatchingPath'] = "findFirstMatchingPath";
  }
  if ("mergedfilescached".indexOf(str) != -1) {
    match = true;
    matches['qs_method_mergedFilesCached'] = "mergedFilesCached";
  }
  if ("rendermergedfiles".indexOf(str) != -1) {
    match = true;
    matches['qs_method_renderMergedFiles'] = "renderMergedFiles";
  }
  if ("getrelativepath".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getRelativePath'] = "getRelativePath";
  }
  if ("getsysrelativepath".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getSysRelativePath'] = "getSysRelativePath";
  }
  if ("getfilesize".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getFileSize'] = "getFileSize";
  }
  if ("getfilesizestring".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getFileSizeString'] = "getFileSizeString";
  }
  if ("getuid".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getUid'] = "getUid";
  }
  if ("getowner".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getOwner'] = "getOwner";
  }
  if ("getgid".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getGid'] = "getGid";
  }
  if ("getgroupowner".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getGroupOwner'] = "getGroupOwner";
  }
  if ("getpermissions".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getPermissions'] = "getPermissions";
  }
  if ("base64decode".indexOf(str) != -1) {
    match = true;
    matches['qs_method_base64Decode'] = "base64Decode";
  }

  // check classes
  if ("sra_workflow".indexOf(str) != -1) {
    match = true;
    matches['qs_class_SRA_Workflow'] = "SRA_Workflow";
  }
  if ("sra_workflowconstraint".indexOf(str) != -1) {
    match = true;
    matches['qs_class_SRA_WorkflowConstraint'] = "SRA_WorkflowConstraint";
  }
  if ("sra_workflowconstraintgroup".indexOf(str) != -1) {
    match = true;
    matches['qs_class_SRA_WorkflowConstraintGroup'] = "SRA_WorkflowConstraintGroup";
  }
  if ("sra_workflowdecision".indexOf(str) != -1) {
    match = true;
    matches['qs_class_SRA_WorkflowDecision'] = "SRA_WorkflowDecision";
  }
  if ("sra_workflowmanager".indexOf(str) != -1) {
    match = true;
    matches['qs_class_SRA_WorkflowManager'] = "SRA_WorkflowManager";
  }
  if ("sra_workflowstep".indexOf(str) != -1) {
    match = true;
    matches['qs_class_SRA_WorkflowStep'] = "SRA_WorkflowStep";
  }
  if ("sra_workflowtask".indexOf(str) != -1) {
    match = true;
    matches['qs_class_SRA_WorkflowTask'] = "SRA_WorkflowTask";
  }


  // check dtds
  if ("workflow.dtd".indexOf(str) != -1) {
    match = true;
    matches['qs_dtd_workflow.dtd'] = "workflow.dtd";
  }

  // check packages
  if ("etc".indexOf(str) != -1) {
    match = true;
    matches['qs_package_etc'] = "etc";
  }
  if ("etc.l10n".indexOf(str) != -1) {
    match = true;
    matches['qs_package_etc.l10n'] = "etc.l10n";
  }
  if ("auth".indexOf(str) != -1) {
    match = true;
    matches['qs_package_auth'] = "auth";
  }
  if ("core".indexOf(str) != -1) {
    match = true;
    matches['qs_package_core'] = "core";
  }
  if ("model".indexOf(str) != -1) {
    match = true;
    matches['qs_package_model'] = "model";
  }
  if ("sql".indexOf(str) != -1) {
    match = true;
    matches['qs_package_sql'] = "sql";
  }
  if ("test".indexOf(str) != -1) {
    match = true;
    matches['qs_package_test'] = "test";
  }
  if ("util".indexOf(str) != -1) {
    match = true;
    matches['qs_package_util'] = "util";
  }
  if ("util.installer".indexOf(str) != -1) {
    match = true;
    matches['qs_package_util.installer'] = "util.installer";
  }
  if ("util.l10n".indexOf(str) != -1) {
    match = true;
    matches['qs_package_util.l10n'] = "util.l10n";
  }
  if ("workflow".indexOf(str) != -1) {
    match = true;
    matches['qs_package_workflow'] = "workflow";
  }


  }
  
  if (match) {
    var html = '';
    for(var i in matches) {
      _tipIds.push(i);
      html += '<div id="' + i + '" style="background-color: white; cursor: pointer;" onclick="document.location.replace(\'#\' + this.id.substr(3))">' + matches[i] + '</div>\n';
    }
    document.getElementById('quicksearch_tips').innerHTML = html;
    showQsTips();
  }
  else {
    hideQsTips();
  }
}
-->
</script></head>
<body id="class" onload="document.getElementById('quicksearch').onkeyup = updateQsTips; document.getElementById('quicksearch').focus()">
  <h1 id="top">class SRA_File</h1>
<p>&nbsp;&nbsp;&nbsp;&nbsp;package <a href="../packages/util.html" target="contentFrame">util</a></p>  <hr />
  <form onsubmit="return false">
  
  <div style="float:right">
    <b><label for="quicksearch">Quick Search:</label></b><br />
    <input id="quicksearch" type="text" onfocus="clearQsTips()" onblur="hideQsTips()" autocomplete="off" onclick="this.select()" /><br />
    <div id="quicksearch_tips" style="border: 1px solid #333; position:absolute; display:none"></div>
  </div>
  
  <pre>class SRA_File</pre>
  
  <h2>Class Information</h2>
  <ul>
    <li><a href="#comments">Class Comments</a></li>
    <li><a href="#constants">Constants</a></li>
    <li><a href="#constant_details">Constant Details</a></li>
    <li><a href="#methods">Methods</a></li>
    <li><a href="#method_details">Method Details</a></li>
    <li><a href="#other">Other</a></li>
  </ul>
  
  <h2 id="comments">Comment</h2>
  <pre> SRA_File Class. This class encapsulates the basic file system function. It
  wraps the functions suppressing normal PHP error reporting and insteads uses
  SRA_Error.
 
  Note: For debugging turn track_errors on in the php.ini. The error messages
  from this class will then be clearer because $php_errormsg is passed as part
  of the message.
 
  Current Methods:
  copy($src, $dest)
  rename($src, $dest)
  _mkdir($pathname, $mode)
  mkdir($path, $mode=0777, $parents=TRUE)
  chmod($pathname, $mode)
  unlink($file)
  symlink($target, $link)
  touch($file)
  _rmdir($dir)
  rmdir($dir, $children=FALSE)
  umask($mode)
  read($file, &amp;$rBuffer)
  _write($file, &amp;$rBuffer)
  write($file, &amp;$rBuffer, $parents=TRUE, $mode=0777)
  fileMTime($file)
  compareMTimes($file1, $file2)
  parseIniFile($pathname, $processSections=FALSE)
 
</pre>
  
  <h2 id="constants">Class Constants</h2>
  <table border="1" width="100%">
    <tr>
      <td><pre>public String </pre></td>
      <td>
        <pre><a href="#constant_SRA_FILE_MIME_TYPE_FILE">SRA_FILE_MIME_TYPE_FILE</a></pre>
<pre> Specifies the mime type file to use. This must be specified in order to use the getMimeType method
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public boolean </pre></td>
      <td>
        <pre><a href="#constant_SRA_FILE_DEBUG">SRA_FILE_DEBUG</a></pre>
<pre> Specifies whether or not the SRA_File class should operate in debug mode (outputs what it is doing to
  the active console window).
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public String </pre></td>
      <td>
        <pre><a href="#constant_SRA_FILE_CACHE_DIR">SRA_FILE_CACHE_DIR</a></pre>
<pre> The location where the cache csv arrays should be stored.
 
</pre>      </td>
    </tr>
  </table>
  

  <h2 id="methods">Class Methods</h2>
  <table border="1" width="100%">
    <tr>
      <td><pre>void</pre></td>
      <td>
        <pre><a href="#method_copy">copy</a>(string $src, string $dest, boolean $recursive=FALSE)</pre>
<pre> used to copy a file from one location to another
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string</pre></td>
      <td>
        <pre><a href="#method_findInPath">findInPath</a>(string $bin, mixed $addlPathDirs=NULL)</pre>
<pre> looks for the program $bin in the $PATH environment variable. returns the
  absolute path to the program. returns NULL if $bin does not exist in the
  path
</pre>      </td>
    </tr>
    <tr>
      <td><pre>void</pre></td>
      <td>
        <pre><a href="#method_move">move</a>(string $src, string $dest)</pre>
<pre> move a file
</pre>      </td>
    </tr>
    <tr>
      <td><pre>TRUE on success. Err object on failure.</pre></td>
      <td>
        <pre><a href="#method_rename">rename</a>($src, $dest)</pre>
<pre> Rename a file or directory. Hint: Use absolute paths if possible to avoid
  confustion of where src and dest are located.
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>private. TRUE on success. Err object on failure.</pre></td>
      <td>
        <pre><a href="#method__mkdir">_mkdir</a>($pathname, $mode)</pre>
<pre> Create (make) a directory.
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public TRUE on success. Err object on failure.</pre></td>
      <td>
        <pre><a href="#method_mkdir">mkdir</a>($path, $mode=0777, $parents=TRUE)</pre>
<pre> This method makes one directory or recursively make directories in path.
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>boolean</pre></td>
      <td>
        <pre><a href="#method_chgrp">chgrp</a>(string $file, string $group, boolean $recursive=FALSE)</pre>
<pre> changes the group ownership of $file to $group
</pre>      </td>
    </tr>
    <tr>
      <td><pre>boolean</pre></td>
      <td>
        <pre><a href="#method_chown">chown</a>(string $file, string $user, boolean $recursive=FALSE)</pre>
<pre> changes the ownership of $file to $user
</pre>      </td>
    </tr>
    <tr>
      <td><pre>boolean</pre></td>
      <td>
        <pre><a href="#method_chmod">chmod</a>(string $file, int $mode, boolean $recursive=FALSE)</pre>
<pre> change the permissions of a file or directory
</pre>      </td>
    </tr>
    <tr>
      <td><pre>boolean</pre></td>
      <td>
        <pre><a href="#method_unlink">unlink</a>(string $file)</pre>
<pre> Delete a file or files. returns TRUE on success, FALSE otherwise (when
  $files is an array, FALSE will be returned if ANY of the files in that
  array could not be deleted)
</pre>      </td>
    </tr>
    <tr>
      <td><pre>TRUE on success. Err object on failure.</pre></td>
      <td>
        <pre><a href="#method_symlink">symlink</a>($target, $link)</pre>
<pre> Symbolically link a file to another name. Currently symlink is not
  implemented on Windows.
  Don&#039;t use if the application is to be portable.
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>TRUE on success. Err object on failure.</pre></td>
      <td>
        <pre><a href="#method_touch">touch</a>($file, $time=FALSE)</pre>
<pre> Set the modification and access time on a file to the present time.
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>array on success. Err object on failure</pre></td>
      <td>
        <pre><a href="#method_dirlist">dirlist</a>($dir)</pre>
<pre> Returns all file listings in a directory. This includes . and ..
  Errors can occur if $dir is not a directory, or if the directory cannot be opened (read permissions, file handles, etc)
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>TRUE on success. Err object on failure.</pre></td>
      <td>
        <pre><a href="#method__rmdir">_rmdir</a>($dir)</pre>
<pre> Delete an empty directory.
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>TRUE on success. Err object on failure.</pre></td>
      <td>
        <pre><a href="#method_rmdir">rmdir</a>($dir, $children=FALSE)</pre>
<pre> Delete an empty directory OR a directory and all of its contents.
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>TRUE on success. Err object on failure.</pre></td>
      <td>
        <pre><a href="#method_umask">umask</a>($mode)</pre>
<pre> Set the umask for file and directory creation.
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>TRUE on success. Err object on failure.</pre></td>
      <td>
        <pre><a href="#method_read">read</a>($file, $rBuffer)</pre>
<pre> Reads a file and stores the data in the variable passed by reference.
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>TRUE on success. Err object on failure.</pre></td>
      <td>
        <pre><a href="#method__write">_write</a>($file, $rBuffer)</pre>
<pre> _write the passed buffer to filename. Overwrites existing file if any.
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>TRUE on success. Err object on failure.</pre></td>
      <td>
        <pre><a href="#method_write">write</a>($file, $rBuffer, $parents=true, $mode=0777)</pre>
<pre> Write() writes a file and makes directories in path if they don&#039;t
  exist. additionally, this method handle synchronization issues using a
  temp lock file. it will wait up to 30 seconds before generating an error
  object when the file is locked at the time this method is invoked
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>Int. Unix timestamp on success. Err object on failure.</pre></td>
      <td>
        <pre><a href="#method_fileMTime">fileMTime</a>($file)</pre>
<pre> Get the modified time for a file.
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>Int. 	1 if file1 is newer. -1 if file2 is newer. 0 if files have the same time. Err object on failure. </pre></td>
      <td>
        <pre><a href="#method_compareMTimes">compareMTimes</a>($file1, $file2)</pre>
<pre> Compare the modified time of two files.
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>Associative array of values on success. Err object on failure.</pre></td>
      <td>
        <pre><a href="#method_parseIniFile">parseIniFile</a>($pathname, $processSections=FALSE)</pre>
<pre> Proccess an ini file returning an array of values.
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string[]</pre></td>
      <td>
        <pre><a href="#method_getFileList">getFileList</a>($path, string $pattern='*', boolean $recursive=FALSE, int $type=1)</pre>
<pre> returns an array of paths to files names that meet the specified criteria
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string</pre></td>
      <td>
        <pre><a href="#method_createRandomFile">createRandomFile</a>(string $dir=NULL, string $pre='', string $post='', string $base='', boolean $delete=FALSE, boolean $mkdir=FALSE)</pre>
<pre> creates a temp file prefixed by $pre and postfixed by $post in $dir with
  the contents $base. if $base is a path to a local or remote file the
  SRA_File::copy method will be used to copy it into the created file and the
  created file extension will be the same as the original file. the absolute
  path to the random file created will be returned
</pre>      </td>
    </tr>
    <tr>
      <td><pre>void</pre></td>
      <td>
        <pre><a href="#method_deleteRandomFiles">deleteRandomFiles</a>(string $file=NULL)</pre>
<pre> deletes any random files created using SRA_File::createRandomFile when
  $delete is TRUE
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string</pre></td>
      <td>
        <pre>&amp;<a href="#method_toString">toString</a>(string $file, int $err=SRA_ERROR_PROBLEM)</pre>
<pre> this method converts a file to a string. it returns an SRA_Error object if
  it is unable to find or open the file
</pre>      </td>
    </tr>
    <tr>
      <td><pre>String</pre></td>
      <td>
        <pre><a href="#method_getMimeType">getMimeType</a>($file)</pre>
<pre> This method attempts to lookup the mime type for the file provided (based on the file extension)
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string</pre></td>
      <td>
        <pre><a href="#method_getArchiveType">getArchiveType</a>(string $archive)</pre>
<pre> returns the archive type identifier for the $archive specified
</pre>      </td>
    </tr>
    <tr>
      <td><pre>boolean</pre></td>
      <td>
        <pre><a href="#method_uncompress">uncompress</a>(string $archive, string $dest=NULL, boolean $delete=FALSE, string $archiveType=NULL)</pre>
<pre> uncompresses an archive
</pre>      </td>
    </tr>
    <tr>
      <td><pre>mixed</pre></td>
      <td>
        <pre><a href="#method_compress">compress</a>(string $file, string $archiveType=SRA_FILE_ARCHIVE_TYPE_TAR_GZ, string $archive=NULL, string $directory=NULL)</pre>
<pre> this method creates a compressed archive of $file. it returns the name of
  the of the compressed archive on success, FALSE otherwise
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string</pre></td>
      <td>
        <pre><a href="#method_findFile">findFile</a>(string $file, array $dirs)</pre>
<pre> looks for $file in $dirs and returns the absolute path if it is found or
  NULL if it is not
</pre>      </td>
    </tr>
    <tr>
      <td><pre>String</pre></td>
      <td>
        <pre>&amp;<a href="#method_getContents">getContents</a>($fp, $options)</pre>
<pre> This method returns the contents of a file as a string limited by the parameters specified.
  It returns false if there are no more blocks in the file that meet the criteria.
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>String - false if not found</pre></td>
      <td>
        <pre><a href="#method_appendToFile">appendToFile</a>($fileName, $data, $header=false, $chownUser=false)</pre>
<pre> This method is used to append a data to a file. It is useful for such things as
  writing to data files such as csv files. If the file does not exist it is created.
  This is a static method of the SRA_File class. All data appened to the file will be
  followed by a newline.
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static String[]: An associative array containing the data</pre></td>
      <td>
        <pre><a href="#method_parseIni">parseIni</a>($fileName, $processSections=false)</pre>
<pre> Load in the ini file specified in filename, and return
  the settings in an associative array. By setting the
  last $processSections parameter to true, you get a
  multidimensional array, with the section names and
  settings included. The default for processSections is
  false.
 
  This functions should replace php native parseIni_file which has too
  many shortcomings as of v 4.2.2.
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>private static boolean</pre></td>
      <td>
        <pre><a href="#method_arrayToFile">arrayToFile</a>($fileName, $arrayName, $array, $append=false)</pre>
<pre> This method converts an array to a file.
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public void</pre></td>
      <td>
        <pre>&amp;<a href="#method_fileToArray">fileToArray</a>($file)</pre>
<pre> Converts a file to an array. Similiar to the &#039;file&#039; function but also
  strips out ending newlines
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static String</pre></td>
      <td>
        <pre><a href="#method_serialize">serialize</a>($object, $file=false)</pre>
<pre> Serializes an object to a file. Returns an SRA_Error object if any occur.
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static Object</pre></td>
      <td>
        <pre>&amp;<a href="#method_unserialize">unserialize</a>($file, $deleteFile=false)</pre>
<pre> Unserializes an object from a file. Returns an SRA_Error object if any occur.
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static String[]</pre></td>
      <td>
        <pre>&amp;<a href="#method_propertiesArrayToFile">propertiesArrayToFile</a>($file, $data)</pre>
<pre> This method performs the reverse of the propertiesFileToArray method. It writes an
  associative properties file array to a properties file.
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static String[]</pre></td>
      <td>
        <pre>&amp;<a href="#method_propertiesFileToArray">propertiesFileToArray</a>($file, $keyCase, $languageCode='', boolean $cache=TRUE)</pre>
<pre> This method converts a properties file to an associative array. It also performs
  caching of this data to temp files in the {SRA_DIR}/tmp/l10n directory.
  The property or key may also include imbedded php code through use of the
  php:: {code} ::php convention. The code itself should be a simple statement that
  returns a value. This value will be inserted into the key or property in the
  location in which they exist (multiple code segments may exist in various locations
  of a key or property).
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>private a two dimensional array representation of the csv file or FALSE  if the there is a problem with the file
</pre></td>
      <td>
        <pre>&amp;<a href="#method_cvsToArray">cvsToArray</a>(String $file, mixed $indexCol=NULL, boolean $cache=TRUE, char $stringDelim='"')</pre>
<pre> Used to convert a CSV file into a two dimensional array
  {@see SRA_Util#arrayToCsv(String[][], boolean)}
  This method maintains a cache
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static String or FALSE</pre></td>
      <td>
        <pre><a href="#method_findFirstMatchingPath">findFirstMatchingPath</a>($baseDirs, string $dir=FALSE, string $file=FALSE, string $prefix='', string $postfix='')</pre>
<pre> returns the first matching path using the following search algorithm
  	1) $baseDir1/$prefix[/$dir]/$postfix[/$file] (if both $prefix and $postfix specified)
  	2) $baseDir1/$prefix[/$dir][/$file] (if $prefix specified)
  	3) $baseDir1[/$dir]/$postfix[/$file] (if $postfix specified)
  	4) $baseDir1[/$dir][/$file] (if exists)
 	... $baseDirN ...
 	4N + 1) FALSE
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static boolean</pre></td>
      <td>
        <pre><a href="#method_mergedFilesCached">mergedFilesCached</a>(mixed $files, int $obfuscate=FALSE, $removeWhiteSpace)</pre>
<pre> returns TRUE if an invocation to SRA_File::renderMergedFiles will result
  in cached output
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static void</pre></td>
      <td>
        <pre><a href="#method_renderMergedFiles">renderMergedFiles</a>(mixed $files, int $obfuscate=FALSE, boolean $removeWhiteSpace=FALSE, boolean $processPhp=TRUE, string $search=NULL, string $replace=NULL)</pre>
<pre> this method merges multiple static or dynamic files and outputs their
  contents. to increase performance, the $files are cached into a single
  temporary file first and the contents of that file are output. the
  temporary file is re-written automatically whenever any of the $files are
  subsequently modified
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static String or FALSE</pre></td>
      <td>
        <pre><a href="#method_getRelativePath">getRelativePath</a>(string $dir=FALSE, string $file=FALSE, string $prefix='', string $postfix='')</pre>
<pre> returns the full path for a app relative directory based on $dir
  using the following search order:
  	1) app directory/$prefix[/$dir]/$postfix[/$file] (if both $prefix and $postfix specified)
  	2) app directory/$prefix[/$dir][/$file] (if $prefix specified)
  	3) app directory[/$dir]/$postfix[/$file] (if $postfix specified)
  	4) app directory[/$dir][/$file] (if exists)
  	5) SRA_File::getSysRelativePath($dir, $file, $prefix, $postfix) (otherwise)
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static String or FALSE</pre></td>
      <td>
        <pre><a href="#method_getSysRelativePath">getSysRelativePath</a>(string $dir=FALSE, string $file=FALSE, string $prefix='', string $postfix='')</pre>
<pre> returns the full path for the system relative directory based on $dir
  using the following search order:
  	1) SRA_DIR/$prefix/$dir/$postfix[/$file] (if both $prefix and $postfix specified)
  	2) SRA_DIR/$prefix/$dir[/$file] (if $prefix specified)
  	3) SRA_DIR/$dir/$postfix[/$file] (if $postfix specified)
  	4) SRA_DIR/$dir[/$file] (if exists)
  	5) [$dir][/$file] (fixed path - if exists)
 	6) FALSE (otherwise)
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>int</pre></td>
      <td>
        <pre><a href="#method_getFileSize">getFileSize</a>(string $file, boolean $useLs=FALSE)</pre>
<pre> returns the size of $file in bytes
</pre>      </td>
    </tr>
    <tr>
      <td><pre>void</pre></td>
      <td>
        <pre><a href="#method_getFileSizeString">getFileSizeString</a>($file, $useLs=FALSE, $decimals=2)</pre>
      </td>
    </tr>
    <tr>
      <td><pre>int</pre></td>
      <td>
        <pre><a href="#method_getUid">getUid</a>(string $file)</pre>
<pre> returns the uid of the owner of $file. this function works even if stat
  does not
</pre>      </td>
    </tr>
    <tr>
      <td><pre>int</pre></td>
      <td>
        <pre><a href="#method_getOwner">getOwner</a>(string $file)</pre>
<pre> returns the name of the user that owns $file. this function works even if stat
  does not
</pre>      </td>
    </tr>
    <tr>
      <td><pre>int</pre></td>
      <td>
        <pre><a href="#method_getGid">getGid</a>(string $file)</pre>
<pre> returns the gid of the group owner of $file. this function works even if stat
  does not
</pre>      </td>
    </tr>
    <tr>
      <td><pre>int</pre></td>
      <td>
        <pre><a href="#method_getGroupOwner">getGroupOwner</a>(string $file)</pre>
<pre> returns the name of the group that owns $file. this function works even if stat
  does not
</pre>      </td>
    </tr>
    <tr>
      <td><pre>mixed</pre></td>
      <td>
        <pre><a href="#method_getPermissions">getPermissions</a>(string $file, boolean $octal=FALSE)</pre>
<pre> returns the octal permissions of $file (i.e. 775 or 664). this function
  works even if stat does not
</pre>      </td>
    </tr>
    <tr>
      <td><pre>mixed</pre></td>
      <td>
        <pre>&amp;<a href="#method_base64Decode">base64Decode</a>(string $encoded, string $output=NULL)</pre>
<pre> used the linux base64 command (if present) to decode $encoded. this
  function was created to avoid some unknown problems with the php
  base64_decode function
</pre>      </td>
    </tr>
  </table>

  <h2 id="constant_details">Constant Details</h2>
  <a href="#top" style="float:right">Top</a>
  <h3 id="constant_SRA_FILE_MIME_TYPE_FILE">SRA_FILE_MIME_TYPE_FILE</h3>
  <pre>public String <b>SRA_FILE_MIME_TYPE_FILE</b> = "/etc/mime.types"</pre>
  <pre> Specifies the mime type file to use. This must be specified in order to use the getMimeType method
</pre>
 <hr />  <h3 id="constant_SRA_FILE_DEBUG">SRA_FILE_DEBUG</h3>
  <pre>public boolean <b>SRA_FILE_DEBUG</b> = false</pre>
  <pre> Specifies whether or not the SRA_File class should operate in debug mode (outputs what it is doing to
  the active console window).
</pre>
 <hr />  <h3 id="constant_SRA_FILE_CACHE_DIR">SRA_FILE_CACHE_DIR</h3>
  <pre>public String <b>SRA_FILE_CACHE_DIR</b> = SRA_DIR . "/tmp"</pre>
  <pre> The location where the cache csv arrays should be stored.
 
</pre>


  <h2 id="method_details">Method Details</h2>
  <a href="#top" style="float:right">Top</a>
  <h3 id="method_copy">copy</h3>
  <pre>void function <b>copy</b>(string $src, string $dest, boolean $recursive=FALSE)</pre>
  <pre> used to copy a file from one location to another
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>src</td>
      <td>string</td>
      <td><pre>source path and name file to copy. this file may be  remote (http, https, ftp), and if it is, it will be downloaded using wget
  (wget must be installed)</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>dest</td>
      <td>string</td>
      <td><pre>destination directory or directory + file name. if  $dest is a directory, the name of the file in $dest will be the same name
  as $src. if the $dest directory does not exist, it will be created</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>recursive</td>
      <td>boolean</td>
      <td><pre>whether or not the copy should be recursive. does  not apply to remote $src files</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_findInPath">findInPath</h3>
  <pre>string function <b>findInPath</b>(string $bin, mixed $addlPathDirs=NULL)</pre>
  <pre> looks for the program $bin in the $PATH environment variable. returns the
  absolute path to the program. returns NULL if $bin does not exist in the
  path
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>bin</td>
      <td>string</td>
      <td><pre>g $bin the name of the program to look for</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>addlPathDirs</td>
      <td>mixed</td>
      <td><pre>an optional array of additional directories to  consider in the path search. this value can also be a single path or
  multiple paths represented as a single string each separated by :</pre></td>
      <td>NULL</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_move">move</h3>
  <pre>void function <b>move</b>(string $src, string $dest)</pre>
  <pre> move a file
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>src</td>
      <td>string</td>
      <td><pre>source path and name file to copy</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>dest</td>
      <td>string</td>
      <td><pre>destination path and name of new file</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_rename">rename</h3>
  <pre>TRUE on success. Err object on failure. function <b>rename</b>($src, $dest)</pre>
  <pre> Rename a file or directory. Hint: Use absolute paths if possible to avoid
  confustion of where src and dest are located.
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>src</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>dest</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
  <p>author = Charlie Killian, charlie@tizac.com</p>
 <hr />  <h3 id="method__mkdir">_mkdir</h3>
  <pre>private. TRUE on success. Err object on failure. function <b>_mkdir</b>($pathname, $mode)</pre>
  <pre> Create (make) a directory.
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>pathname</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>mode</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
  <p>author = Charlie Killian, charlie@tizac.com</p>
 <hr />  <h3 id="method_mkdir">mkdir</h3>
  <pre>public TRUE on success. Err object on failure. function <b>mkdir</b>($path, $mode=0777, $parents=TRUE)</pre>
  <pre> This method makes one directory or recursively make directories in path.
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>path</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>mode</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>0777</td>
      <td>No</td>
    </tr>
    <tr>
      <td>parents</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>TRUE</td>
      <td>No</td>
    </tr>
  </table>
  <p>author = Charlie Killian, charlie@tizac.com</p>
 <hr />  <h3 id="method_chgrp">chgrp</h3>
  <pre>boolean function <b>chgrp</b>(string $file, string $group, boolean $recursive=FALSE)</pre>
  <pre> changes the group ownership of $file to $group
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>file</td>
      <td>string</td>
      <td><pre>the file to change the group ownership of</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>group</td>
      <td>string</td>
      <td><pre>the name of the group to change group ownership to</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>recursive</td>
      <td>boolean</td>
      <td><pre>whether or not to change the group permissions  recursively if $file is a directory</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_chown">chown</h3>
  <pre>boolean function <b>chown</b>(string $file, string $user, boolean $recursive=FALSE)</pre>
  <pre> changes the ownership of $file to $user
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>file</td>
      <td>string</td>
      <td><pre>the file to change the ownership of</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>user</td>
      <td>string</td>
      <td><pre>the name of the user to change ownership to</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>recursive</td>
      <td>boolean</td>
      <td><pre>whether or not to change the permissions  recursively if $file is a directory</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_chmod">chmod</h3>
  <pre>boolean function <b>chmod</b>(string $file, int $mode, boolean $recursive=FALSE)</pre>
  <pre> change the permissions of a file or directory
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>file</td>
      <td>string</td>
      <td><pre>the file to change the permissions for</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>mode</td>
      <td>int</td>
      <td><pre>the new mode (permissions) for $file. if using octal add  leading 0: i.e. 0777</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>recursive</td>
      <td>boolean</td>
      <td><pre>whether or not to change the file permissions  recursively if $file is a directory</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_unlink">unlink</h3>
  <pre>boolean function <b>unlink</b>(string $file)</pre>
  <pre> Delete a file or files. returns TRUE on success, FALSE otherwise (when
  $files is an array, FALSE will be returned if ANY of the files in that
  array could not be deleted)
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>file</td>
      <td>string</td>
      <td><pre>path and/or name of file to delete. if this is an  array, all of the files in the array will be deleted.</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_symlink">symlink</h3>
  <pre>TRUE on success. Err object on failure. function <b>symlink</b>($target, $link)</pre>
  <pre> Symbolically link a file to another name. Currently symlink is not
  implemented on Windows.
  Don&#039;t use if the application is to be portable.
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>target</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>link</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
  <p>author = Charlie Killian, charlie@tizac.com</p>
 <hr />  <h3 id="method_touch">touch</h3>
  <pre>TRUE on success. Err object on failure. function <b>touch</b>($file, $time=FALSE)</pre>
  <pre> Set the modification and access time on a file to the present time.
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>file</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>time</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
  </table>
  <p>author = Charlie Killian, charlie@tizac.com</p>
 <hr />  <h3 id="method_dirlist">dirlist</h3>
  <pre>array on success. Err object on failure function <b>dirlist</b>($dir)</pre>
  <pre> Returns all file listings in a directory. This includes . and ..
  Errors can occur if $dir is not a directory, or if the directory cannot be opened (read permissions, file handles, etc)
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>dir</td>
      <td>Not Specified</td>
      <td><pre>String. Full path of the directory to get a listing for</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
  <p>author = Matthew Barlocker <mbarlocker@soleranetworks.com></p>
 <hr />  <h3 id="method__rmdir">_rmdir</h3>
  <pre>TRUE on success. Err object on failure. function <b>_rmdir</b>($dir)</pre>
  <pre> Delete an empty directory.
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>dir</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
  <p>author = Charlie Killian, charlie@tizac.com</p>
 <hr />  <h3 id="method_rmdir">rmdir</h3>
  <pre>TRUE on success. Err object on failure. function <b>rmdir</b>($dir, $children=FALSE)</pre>
  <pre> Delete an empty directory OR a directory and all of its contents.
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>dir</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>children</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
  </table>
  <p>author = Charlie Killian, charlie@tizac.com</p>
 <hr />  <h3 id="method_umask">umask</h3>
  <pre>TRUE on success. Err object on failure. function <b>umask</b>($mode)</pre>
  <pre> Set the umask for file and directory creation.
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>mode</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
  <p>author = Charlie Killian, charlie@tizac.com</p>
 <hr />  <h3 id="method_read">read</h3>
  <pre>TRUE on success. Err object on failure. function <b>read</b>($file, $rBuffer)</pre>
  <pre> Reads a file and stores the data in the variable passed by reference.
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>file</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>rBuffer</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
  </table>
  <p>author = Charlie Killian, charlie@tizac.com</p>
 <hr />  <h3 id="method__write">_write</h3>
  <pre>TRUE on success. Err object on failure. function <b>_write</b>($file, $rBuffer)</pre>
  <pre> _write the passed buffer to filename. Overwrites existing file if any.
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>file</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>rBuffer</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
  </table>
  <p>author = Charlie Killian, charlie@tizac.com</p>
 <hr />  <h3 id="method_write">write</h3>
  <pre>TRUE on success. Err object on failure. function <b>write</b>($file, $rBuffer, $parents=true, $mode=0777)</pre>
  <pre> Write() writes a file and makes directories in path if they don&#039;t
  exist. additionally, this method handle synchronization issues using a
  temp lock file. it will wait up to 30 seconds before generating an error
  object when the file is locked at the time this method is invoked
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>file</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>rBuffer</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>parents</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>true</td>
      <td>No</td>
    </tr>
    <tr>
      <td>mode</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>0777</td>
      <td>No</td>
    </tr>
  </table>
  <p>author = Charlie Killian, charlie@tizac.com</p>
 <hr />  <h3 id="method_fileMTime">fileMTime</h3>
  <pre>Int. Unix timestamp on success. Err object on failure. function <b>fileMTime</b>($file)</pre>
  <pre> Get the modified time for a file.
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>file</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
  <p>author = Charlie Killian, charlie@tizac.com</p>
 <hr />  <h3 id="method_compareMTimes">compareMTimes</h3>
  <pre>Int. 	1 if file1 is newer. -1 if file2 is newer. 0 if files have the same time. Err object on failure.  function <b>compareMTimes</b>($file1, $file2)</pre>
  <pre> Compare the modified time of two files.
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>file1</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>file2</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
  <p>author = Charlie Killian, charlie@tizac.com</p>
 <hr />  <h3 id="method_parseIniFile">parseIniFile</h3>
  <pre>Associative array of values on success. Err object on failure. function <b>parseIniFile</b>($pathname, $processSections=FALSE)</pre>
  <pre> Proccess an ini file returning an array of values.
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>pathname</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>processSections</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
  </table>
  <p>author = Charlie Killian, charlie@tizac.com</p>
 <hr />  <h3 id="method_getFileList">getFileList</h3>
  <pre>string[] function <b>getFileList</b>($path, string $pattern='*', boolean $recursive=FALSE, int $type=1)</pre>
  <pre> returns an array of paths to files names that meet the specified criteria
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>path</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>pattern</td>
      <td>string</td>
      <td><pre>regular expression pattern or exact name to match.  use &#039;*&#039; to match all. default is &#039;*&#039;</pre></td>
      <td>'*'</td>
      <td>No</td>
    </tr>
    <tr>
      <td>recursive</td>
      <td>boolean</td>
      <td><pre>whether or not the search should descend into  child directories</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
    <tr>
      <td>type</td>
      <td>int</td>
      <td><pre>bitmask identifying the file types to return where 1 is  files and 2 is directories (3=both files and directories). default is 1</pre></td>
      <td>1</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_createRandomFile">createRandomFile</h3>
  <pre>string function <b>createRandomFile</b>(string $dir=NULL, string $pre='', string $post='', string $base='', boolean $delete=FALSE, boolean $mkdir=FALSE)</pre>
  <pre> creates a temp file prefixed by $pre and postfixed by $post in $dir with
  the contents $base. if $base is a path to a local or remote file the
  SRA_File::copy method will be used to copy it into the created file and the
  created file extension will be the same as the original file. the absolute
  path to the random file created will be returned
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>dir</td>
      <td>string</td>
      <td><pre>the directory where the file should be created. if not  specified, the SRA_Controller::getAppTmpDir will be used</pre></td>
      <td>NULL</td>
      <td>No</td>
    </tr>
    <tr>
      <td>pre</td>
      <td>string</td>
      <td><pre>a string to add to the beginning of the file. this  attribute is optional. The default is &#039;&#039;</pre></td>
      <td>''</td>
      <td>No</td>
    </tr>
    <tr>
      <td>post</td>
      <td>string</td>
      <td><pre>a string to add to the end of the file. this attribute  is optional. The default is &#039;&#039;.</pre></td>
      <td>''</td>
      <td>No</td>
    </tr>
    <tr>
      <td>base</td>
      <td>string</td>
      <td><pre>optional file contents or path to an existing file to  copy into the newly created random file</pre></td>
      <td>''</td>
      <td>No</td>
    </tr>
    <tr>
      <td>delete</td>
      <td>boolean</td>
      <td><pre>whether or not to delete this file automatically  upon termination of the current php process</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
    <tr>
      <td>mkdir</td>
      <td>boolean</td>
      <td><pre>whether or not the file should be created as a  directory</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_deleteRandomFiles">deleteRandomFiles</h3>
  <pre>void function <b>deleteRandomFiles</b>(string $file=NULL)</pre>
  <pre> deletes any random files created using SRA_File::createRandomFile when
  $delete is TRUE
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>file</td>
      <td>string</td>
      <td><pre>the file to delete, if NULL, the files will be deleted</pre></td>
      <td>NULL</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_toString">toString</h3>
  <pre>string function &amp;<b>toString</b>(string $file, int $err=SRA_ERROR_PROBLEM)</pre>
  <pre> this method converts a file to a string. it returns an SRA_Error object if
  it is unable to find or open the file
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>file</td>
      <td>string</td>
      <td><pre>the absolute or relative path to the file</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>err</td>
      <td>int</td>
      <td><pre>the level of the error that should be thrown if the file  cannot be found or opened. this value will correspond to one of the
  SRA_Error class error level constants. By default this value is
  SRA_ERROR_PROBLEM</pre></td>
      <td>SRA_ERROR_PROBLEM</td>
      <td>No</td>
    </tr>
  </table>
  <p>author = Jason Read <jason@idir.org></p>
 <hr />  <h3 id="method_getMimeType">getMimeType</h3>
  <pre>String function <b>getMimeType</b>($file)</pre>
  <pre> This method attempts to lookup the mime type for the file provided (based on the file extension)
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>file</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
  <p>author = Jason Read <jason@idir.org></p>
 <hr />  <h3 id="method_getArchiveType">getArchiveType</h3>
  <pre>string function <b>getArchiveType</b>(string $archive)</pre>
  <pre> returns the archive type identifier for the $archive specified
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>archive</td>
      <td>string</td>
      <td><pre>the name of the archive</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_uncompress">uncompress</h3>
  <pre>boolean function <b>uncompress</b>(string $archive, string $dest=NULL, boolean $delete=FALSE, string $archiveType=NULL)</pre>
  <pre> uncompresses an archive
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>archive</td>
      <td>string</td>
      <td><pre>the name of the archive to uncompress</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>dest</td>
      <td>string</td>
      <td><pre>the destination path where $archive should be  uncompressed into. if not specified, the archive will be uncompressed into
  the parent directory of $archive</pre></td>
      <td>NULL</td>
      <td>No</td>
    </tr>
    <tr>
      <td>delete</td>
      <td>boolean</td>
      <td><pre>whether or not $archive should be deleted after it  is uncompressed</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
    <tr>
      <td>archiveType</td>
      <td>string</td>
      <td><pre>the archive type (if $archive does not end with  one of the SRA_FILE_ARCHIVE_TYPE_* file extensions</pre></td>
      <td>NULL</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_compress">compress</h3>
  <pre>mixed function <b>compress</b>(string $file, string $archiveType=SRA_FILE_ARCHIVE_TYPE_TAR_GZ, string $archive=NULL, string $directory=NULL)</pre>
  <pre> this method creates a compressed archive of $file. it returns the name of
  the of the compressed archive on success, FALSE otherwise
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>file</td>
      <td>string</td>
      <td><pre>the path to the file or directory to compress</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>archiveType</td>
      <td>string</td>
      <td><pre>the archive type to create. should be one of  the SRA_FILE_ARCHIVE_TYPE_* constants</pre></td>
      <td>SRA_FILE_ARCHIVE_TYPE_TAR_GZ</td>
      <td>No</td>
    </tr>
    <tr>
      <td>archive</td>
      <td>string</td>
      <td><pre>the name of the archive to create. if not specified  the archive name will be the name $file plus the correct file extension
  based on the $archiveType specified and placed in the same directory as
  $file</pre></td>
      <td>NULL</td>
      <td>No</td>
    </tr>
    <tr>
      <td>directory</td>
      <td>string</td>
      <td><pre>is $file is a directory, this parameter may be  used to specify the starting directory for the archive. if not specified,
  the archive will start at the root directory (&#039;/&#039;)</pre></td>
      <td>NULL</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_findFile">findFile</h3>
  <pre>string function <b>findFile</b>(string $file, array $dirs)</pre>
  <pre> looks for $file in $dirs and returns the absolute path if it is found or
  NULL if it is not
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>file</td>
      <td>string</td>
      <td><pre>the name of the file to look for</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>dirs</td>
      <td>array</td>
      <td><pre>the array of directories to look in</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_getContents">getContents</h3>
  <pre>String function &amp;<b>getContents</b>($fp, $options)</pre>
  <pre> This method returns the contents of a file as a string limited by the parameters specified.
  It returns false if there are no more blocks in the file that meet the criteria.
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>fp</td>
      <td>Not Specified</td>
      <td><pre>- A reference to the file pointer for the file.</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>options</td>
      <td>Not Specified</td>
      <td><pre>- A reference to a key based options array. The possible values for options are as follows:  			&#039;start_string&#039; =&gt; 	String that should appear at the start of a block of text to be parsed. This value will be
 								converted to an array if it contains a &quot;&amp;&quot;. In this case, all values in the array must exist in the line.
 								If this value contains a &#039;:&#039;, the end string criteria will be converted to an array of arrays each containing
  								one set of strings that must be present for the end to have been found.
  			&#039;start_line_num&#039; =&gt; String that should appear at the start of a block of text to be parsed.
 					   			This option is overriden if &#039;start_string&#039; is specified.
  			&#039;end_string&#039; =&gt; 	String that should appear at the end of a block of text to be parsed
 				   				(either this text or an EOF should exist). This value will be
 								converted to an array if it contains a &quot;&amp;&quot;. In this case, all values in the array must exist in the line.
 								If this value contains a &#039;:&#039;, the end string criteria will be converted to an array of arrays each containing
  								one set of strings that must be present for the end to have been found.
  			&#039;header_lines&#039; =&gt; 	The # of lines that make up the file header. These lines will be ignored.
 								This value is only taken into consideration when at BOF.
  			&#039;line_count&#039; =&gt; 	The # of lines to be returned. This option is overriden if &#039;end_string&#039; is specified.
  			&#039;min_line_count&#039; =&gt; This option specifies the minimum # of lines that should exist in a text block.</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
  </table>
  <p>author = Jason Read <jason@idir.org></p>
 <hr />  <h3 id="method_appendToFile">appendToFile</h3>
  <pre>String - false if not found function <b>appendToFile</b>($fileName, $data, $header=false, $chownUser=false)</pre>
  <pre> This method is used to append a data to a file. It is useful for such things as
  writing to data files such as csv files. If the file does not exist it is created.
  This is a static method of the SRA_File class. All data appened to the file will be
  followed by a newline.
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>fileName</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>data</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>header</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>false</td>
      <td>No</td>
    </tr>
    <tr>
      <td>chownUser</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>false</td>
      <td>No</td>
    </tr>
  </table>
  <p>author = Jason Read <jason@idir.org></p>
 <hr />  <h3 id="method_parseIni">parseIni</h3>
  <pre>public static String[]: An associative array containing the data function <b>parseIni</b>($fileName, $processSections=false)</pre>
  <pre> Load in the ini file specified in filename, and return
  the settings in an associative array. By setting the
  last $processSections parameter to true, you get a
  multidimensional array, with the section names and
  settings included. The default for processSections is
  false.
 
  This functions should replace php native parseIni_file which has too
  many shortcomings as of v 4.2.2.
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>fileName</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>processSections</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>false</td>
      <td>No</td>
    </tr>
  </table>
  <p>author = Array</p>
 <hr />  <h3 id="method_arrayToFile">arrayToFile</h3>
  <pre>private static boolean function <b>arrayToFile</b>($fileName, $arrayName, $array, $append=false)</pre>
  <pre> This method converts an array to a file.
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>fileName</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>arrayName</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>array</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>append</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>false</td>
      <td>No</td>
    </tr>
  </table>
  <p>author = Jason Read <jason@idir.org></p>
 <hr />  <h3 id="method_fileToArray">fileToArray</h3>
  <pre>public void function &amp;<b>fileToArray</b>($file)</pre>
  <pre> Converts a file to an array. Similiar to the &#039;file&#039; function but also
  strips out ending newlines
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>file</td>
      <td>Not Specified</td>
      <td><pre>: String - the path to the file to convert</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_serialize">serialize</h3>
  <pre>public static String function <b>serialize</b>($object, $file=false)</pre>
  <pre> Serializes an object to a file. Returns an SRA_Error object if any occur.
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>object</td>
      <td>Not Specified</td>
      <td><pre>: String - The object to serialize. An SRA_Error will be  			returned if this parameter is a scalar value.</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>file</td>
      <td>Not Specified</td>
      <td><pre>: String - The file to serialize the object to. If this  			parameter is not specified, a random file will be created and
  			the name of that file returned.</pre></td>
      <td>false</td>
      <td>No</td>
    </tr>
  </table>
  <p>author = Jason Read <jason@idir.org></p>
 <hr />  <h3 id="method_unserialize">unserialize</h3>
  <pre>public static Object function &amp;<b>unserialize</b>($file, $deleteFile=false)</pre>
  <pre> Unserializes an object from a file. Returns an SRA_Error object if any occur.
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>file</td>
      <td>Not Specified</td>
      <td><pre>: String - The name of the file to unserialize.</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>deleteFile</td>
      <td>Not Specified</td>
      <td><pre>: boolean - Whether or not the serialization file should 			be deleted if the object is unserialized successfully.</pre></td>
      <td>false</td>
      <td>No</td>
    </tr>
  </table>
  <p>author = Jason Read <jason@idir.org></p>
 <hr />  <h3 id="method_propertiesArrayToFile">propertiesArrayToFile</h3>
  <pre>public static String[] function &amp;<b>propertiesArrayToFile</b>($file, $data)</pre>
  <pre> This method performs the reverse of the propertiesFileToArray method. It writes an
  associative properties file array to a properties file.
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>file</td>
      <td>Not Specified</td>
      <td><pre>: String -  The file to write to. Any existing data will be overwritten.</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>data</td>
      <td>Not Specified</td>
      <td><pre>: String[] - An associative array of properties to write.</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
  </table>
  <p>author = Jason Read <jason@idir.org></p>
 <hr />  <h3 id="method_propertiesFileToArray">propertiesFileToArray</h3>
  <pre>public static String[] function &amp;<b>propertiesFileToArray</b>($file, $keyCase, $languageCode='', boolean $cache=TRUE)</pre>
  <pre> This method converts a properties file to an associative array. It also performs
  caching of this data to temp files in the {SRA_DIR}/tmp/l10n directory.
  The property or key may also include imbedded php code through use of the
  php:: {code} ::php convention. The code itself should be a simple statement that
  returns a value. This value will be inserted into the key or property in the
  location in which they exist (multiple code segments may exist in various locations
  of a key or property).
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>file</td>
      <td>Not Specified</td>
      <td><pre>: String - The file to convert. if this value is a string (and  not a file), it will be written to a temporary file, converted to a
  properties array, and returned</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>keyCase</td>
      <td>Not Specified</td>
      <td><pre>: int - The key case to use. By default, this method will maintain  			the case used in the properties file (0). Optionally, you may specify -1
  			in this parameter for lowercase only keys, and 1 for uppercase only keys.</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>languageCode</td>
      <td>Not Specified</td>
      <td><pre>: String - The language code</pre></td>
      <td>''</td>
      <td>No</td>
    </tr>
    <tr>
      <td>cache</td>
      <td>boolean</td>
      <td><pre>whether or not to cache files</pre></td>
      <td>TRUE</td>
      <td>No</td>
    </tr>
  </table>
  <p>author = Jason Read <jason@idir.org></p>
 <hr />  <h3 id="method_cvsToArray">cvsToArray</h3>
  <pre>private a two dimensional array representation of the csv file or FALSE  if the there is a problem with the file
 function &amp;<b>cvsToArray</b>(String $file, mixed $indexCol=NULL, boolean $cache=TRUE, char $stringDelim='"')</pre>
  <pre> Used to convert a CSV file into a two dimensional array
  {@see SRA_Util#arrayToCsv(String[][], boolean)}
  This method maintains a cache
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>file</td>
      <td>String</td>
      <td><pre>- the name of the csv file to convert</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>indexCol</td>
      <td>mixed</td>
      <td><pre>- if the returned array should be indexed by one of  the column values, this parameter should identify the 0-based index of that
  column. thus, if duplicate values exist in the database for that column,
  only a single instance of it will be returned (the last instance). this
  parameter may also be an array where the row indexes will be a concatendated
  value consisting of all of the values specified in that array where a
  numeric value will be pulled from the row and a string will be inserted into
  the key as-is.</pre></td>
      <td>NULL</td>
      <td>No</td>
    </tr>
    <tr>
      <td>cache</td>
      <td>boolean</td>
      <td><pre>whether or not to cache the results</pre></td>
      <td>TRUE</td>
      <td>No</td>
    </tr>
    <tr>
      <td>stringDelim</td>
      <td>char</td>
      <td><pre>- the string delimiter. strings may contain this  delimiter value, but it should be preceded by \ or the same delimiter when
  this occurs</pre></td>
      <td>'"'</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_findFirstMatchingPath">findFirstMatchingPath</h3>
  <pre>public static String or FALSE function <b>findFirstMatchingPath</b>($baseDirs, string $dir=FALSE, string $file=FALSE, string $prefix='', string $postfix='')</pre>
  <pre> returns the first matching path using the following search algorithm
  	1) $baseDir1/$prefix[/$dir]/$postfix[/$file] (if both $prefix and $postfix specified)
  	2) $baseDir1/$prefix[/$dir][/$file] (if $prefix specified)
  	3) $baseDir1[/$dir]/$postfix[/$file] (if $postfix specified)
  	4) $baseDir1[/$dir][/$file] (if exists)
 	... $baseDirN ...
 	4N + 1) FALSE
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>baseDirs</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>dir</td>
      <td>string</td>
      <td><pre>- the directory name</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
    <tr>
      <td>file</td>
      <td>string</td>
      <td><pre>- an optional file to look for in the directory</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
    <tr>
      <td>prefix</td>
      <td>string</td>
      <td><pre>- a prefix to check in the app and SRA_DIR</pre></td>
      <td>''</td>
      <td>No</td>
    </tr>
    <tr>
      <td>postfix</td>
      <td>string</td>
      <td><pre>- a postfix to check in the app and SRA_DIR</pre></td>
      <td>''</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_mergedFilesCached">mergedFilesCached</h3>
  <pre>public static boolean function <b>mergedFilesCached</b>(mixed $files, int $obfuscate=FALSE, $removeWhiteSpace)</pre>
  <pre> returns TRUE if an invocation to SRA_File::renderMergedFiles will result
  in cached output
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>files</td>
      <td>mixed</td>
      <td><pre>either an array of file names or a space separated list  of file names. if any file in this value is not valid, an error will be
  logged, but the rendering will continue</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>obfuscate</td>
      <td>int</td>
      <td><pre>if the $files are javascript or css source code  files, whether or not those files should be obfuscated. obfuscation,
  removes all unnecessary comments and whitespace from the source files in
  order to reduce the file size. obfuscation depends on ext/phpJSO.php. use
  1 for javascript obfuscation and 2 for css obfuscation</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
    <tr>
      <td>removeWhiteSpace</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_renderMergedFiles">renderMergedFiles</h3>
  <pre>public static void function <b>renderMergedFiles</b>(mixed $files, int $obfuscate=FALSE, boolean $removeWhiteSpace=FALSE, boolean $processPhp=TRUE, string $search=NULL, string $replace=NULL)</pre>
  <pre> this method merges multiple static or dynamic files and outputs their
  contents. to increase performance, the $files are cached into a single
  temporary file first and the contents of that file are output. the
  temporary file is re-written automatically whenever any of the $files are
  subsequently modified
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>files</td>
      <td>mixed</td>
      <td><pre>either an array of file names or a space separated list  of file names. if any file in this value is not valid, an error will be
  logged, but the rendering will continue</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>obfuscate</td>
      <td>int</td>
      <td><pre>if the $files are javascript or css source code  files, whether or not those files should be obfuscated. obfuscation,
  removes all unnecessary comments and whitespace from the source files in
  order to reduce the file size. obfuscation depends on ext/phpJSO.php. use
  1 for javascript obfuscation and 2 for css obfuscation</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
    <tr>
      <td>removeWhiteSpace</td>
      <td>boolean</td>
      <td><pre>whether or not to remove whitespace from  the merged files</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
    <tr>
      <td>processPhp</td>
      <td>boolean</td>
      <td><pre>whether or not to process php files (files that  end with the SRA_SYS_PHP_EXTENSION extension)</pre></td>
      <td>TRUE</td>
      <td>No</td>
    </tr>
    <tr>
      <td>search</td>
      <td>string</td>
      <td><pre>an optional value to replace with $replace. this can  contain multiple values each separated by a pipe (|)</pre></td>
      <td>NULL</td>
      <td>No</td>
    </tr>
    <tr>
      <td>replace</td>
      <td>string</td>
      <td><pre>the value to replace $search with. this can contain  multiple values each separated by a pipe (|)</pre></td>
      <td>NULL</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_getRelativePath">getRelativePath</h3>
  <pre>public static String or FALSE function <b>getRelativePath</b>(string $dir=FALSE, string $file=FALSE, string $prefix='', string $postfix='')</pre>
  <pre> returns the full path for a app relative directory based on $dir
  using the following search order:
  	1) app directory/$prefix[/$dir]/$postfix[/$file] (if both $prefix and $postfix specified)
  	2) app directory/$prefix[/$dir][/$file] (if $prefix specified)
  	3) app directory[/$dir]/$postfix[/$file] (if $postfix specified)
  	4) app directory[/$dir][/$file] (if exists)
  	5) SRA_File::getSysRelativePath($dir, $file, $prefix, $postfix) (otherwise)
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>dir</td>
      <td>string</td>
      <td><pre>- the base directory name (optional)</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
    <tr>
      <td>file</td>
      <td>string</td>
      <td><pre>- an optional file to look for in the directory. either  $dir or $file should be specified or the app directory will always be
  returned</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
    <tr>
      <td>prefix</td>
      <td>string</td>
      <td><pre>- a prefix to check in the app and SRA_DIR</pre></td>
      <td>''</td>
      <td>No</td>
    </tr>
    <tr>
      <td>postfix</td>
      <td>string</td>
      <td><pre>- a postfix to check in the app and SRA_DIR</pre></td>
      <td>''</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_getSysRelativePath">getSysRelativePath</h3>
  <pre>public static String or FALSE function <b>getSysRelativePath</b>(string $dir=FALSE, string $file=FALSE, string $prefix='', string $postfix='')</pre>
  <pre> returns the full path for the system relative directory based on $dir
  using the following search order:
  	1) SRA_DIR/$prefix/$dir/$postfix[/$file] (if both $prefix and $postfix specified)
  	2) SRA_DIR/$prefix/$dir[/$file] (if $prefix specified)
  	3) SRA_DIR/$dir/$postfix[/$file] (if $postfix specified)
  	4) SRA_DIR/$dir[/$file] (if exists)
  	5) [$dir][/$file] (fixed path - if exists)
 	6) FALSE (otherwise)
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>dir</td>
      <td>string</td>
      <td><pre>- the directory name (optional)</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
    <tr>
      <td>file</td>
      <td>string</td>
      <td><pre>- an optional file to look for in the directory. either  $dir or $file should be specified or the SRA_DIR will always be returned</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
    <tr>
      <td>prefix</td>
      <td>string</td>
      <td><pre>- a prefix to check in the SRA_DIR</pre></td>
      <td>''</td>
      <td>No</td>
    </tr>
    <tr>
      <td>postfix</td>
      <td>string</td>
      <td><pre>- a postfix to check in the SRA_DIR</pre></td>
      <td>''</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_getFileSize">getFileSize</h3>
  <pre>int function <b>getFileSize</b>(string $file, boolean $useLs=FALSE)</pre>
  <pre> returns the size of $file in bytes
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>file</td>
      <td>string</td>
      <td><pre>the file to return the size of</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>useLs</td>
      <td>boolean</td>
      <td><pre>whether or not to use the ls command instead of the  built in filesize php function</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_getFileSizeString">getFileSizeString</h3>
  <pre>void function <b>getFileSizeString</b>($file, $useLs=FALSE, $decimals=2)</pre>
  <pre>No API comments</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>file</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>useLs</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
    <tr>
      <td>decimals</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>2</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_getUid">getUid</h3>
  <pre>int function <b>getUid</b>(string $file)</pre>
  <pre> returns the uid of the owner of $file. this function works even if stat
  does not
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>file</td>
      <td>string</td>
      <td><pre>the file to return the owner of</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_getOwner">getOwner</h3>
  <pre>int function <b>getOwner</b>(string $file)</pre>
  <pre> returns the name of the user that owns $file. this function works even if stat
  does not
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>file</td>
      <td>string</td>
      <td><pre>the file to return the owner of</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_getGid">getGid</h3>
  <pre>int function <b>getGid</b>(string $file)</pre>
  <pre> returns the gid of the group owner of $file. this function works even if stat
  does not
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>file</td>
      <td>string</td>
      <td><pre>the file to return the owner of</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_getGroupOwner">getGroupOwner</h3>
  <pre>int function <b>getGroupOwner</b>(string $file)</pre>
  <pre> returns the name of the group that owns $file. this function works even if stat
  does not
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>file</td>
      <td>string</td>
      <td><pre>the file to return the owner of</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_getPermissions">getPermissions</h3>
  <pre>mixed function <b>getPermissions</b>(string $file, boolean $octal=FALSE)</pre>
  <pre> returns the octal permissions of $file (i.e. 775 or 664). this function
  works even if stat does not
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>file</td>
      <td>string</td>
      <td><pre>the file to return the permissions for</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>octal</td>
      <td>boolean</td>
      <td><pre>if TRUE, the return value will be an octal. otherwise  it will be an int</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_base64Decode">base64Decode</h3>
  <pre>mixed function &amp;<b>base64Decode</b>(string $encoded, string $output=NULL)</pre>
  <pre> used the linux base64 command (if present) to decode $encoded. this
  function was created to avoid some unknown problems with the php
  base64_decode function
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>encoded</td>
      <td>string</td>
      <td><pre>the base64 encoded string to convert</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>output</td>
      <td>string</td>
      <td><pre>an optional file path that the encoded contents  should be written to. if specified, the return value will be NULL</pre></td>
      <td>NULL</td>
      <td>No</td>
    </tr>
  </table>
  
  <h2>Other Information</h2>
  <table id="other" border="1" width="100%">
  <tr>
    <th>Source File</th>
    <td>/home/jread/www/sierra/lib/util/SRA_File.php</td>
  </tr>
  <tr>
    <th>author</th>
    <td>Jason Read &lt;jason@idir.org&gt;</td>
  </tr>
  </table>
  </form>
</body>
</html>