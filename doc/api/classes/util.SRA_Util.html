<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>util.SRA_Util - sierra-php v1.1.3</title>
<script type="text/javascript">
<!--
var _qsAbortNext = false;
var _tipsIdx = 0;
var _tipIds;

function clearQsTips() {
  document.getElementById('quicksearch_tips').innerHTML = '';
}
function hideQsTips() {
  setTimeout("document.getElementById('quicksearch_tips').style.display = 'none'", 100);
}
function showQsTips() {
  document.getElementById('quicksearch_tips').style.display = '';
}
function qsTipsVisible() {
  return document.getElementById('quicksearch_tips').style.display != 'none';
}
function updateQsTips(evt) {
  if (qsTipsVisible() && evt && (evt.keyCode == 40 || evt.keyCode == 38 || evt.keyCode == 13)) {
    switch(evt.keyCode) {
      // up
      case 38:
      // down
      case 40:
        if (_tipsIdx >= 0) document.getElementById(_tipIds[_tipsIdx]).style.backgroundColor = '';
        evt.keyCode == 38 ? _tipsIdx-- : _tipsIdx++;
        if (_tipsIdx > _tipIds.length) _tipsIdx = 0;
        if (_tipsIdx < 0) _tipsIdx = _tipIds.length - 1;
        if (_tipsIdx >= 0) document.getElementById(_tipIds[_tipsIdx]).style.backgroundColor = '#ddd';
        break;
      // enter
      case 13:
        if (_tipsIdx >= 0 && _tipIds[_tipsIdx]) {
          document.location.replace('#' + _tipIds[_tipsIdx].substr(3));
        }
        break;
    }
    return;
  }
  
  _tipsIdx = -1;
  _tipIds = [];
  var str = document.getElementById('quicksearch').value.toLowerCase();
  var matches = {}
  var match = false;
  
  if (str) {
  // check constants
  if ("sra_util_ip_regex".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_IP_REGEX'] = "SRA_UTIL_IP_REGEX";
  }
  if ("sra_util_aspell".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_ASPELL'] = "SRA_UTIL_ASPELL";
  }
  if ("sra_util_data_unit_bit".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_DATA_UNIT_BIT'] = "SRA_UTIL_DATA_UNIT_BIT";
  }
  if ("sra_util_data_unit_byte".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_DATA_UNIT_BYTE'] = "SRA_UTIL_DATA_UNIT_BYTE";
  }
  if ("sra_util_data_unit_kilobit".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_DATA_UNIT_KILOBIT'] = "SRA_UTIL_DATA_UNIT_KILOBIT";
  }
  if ("sra_util_data_unit_kilobyte".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_DATA_UNIT_KILOBYTE'] = "SRA_UTIL_DATA_UNIT_KILOBYTE";
  }
  if ("sra_util_data_unit_megabit".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_DATA_UNIT_MEGABIT'] = "SRA_UTIL_DATA_UNIT_MEGABIT";
  }
  if ("sra_util_data_unit_megabyte".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_DATA_UNIT_MEGABYTE'] = "SRA_UTIL_DATA_UNIT_MEGABYTE";
  }
  if ("sra_util_data_unit_gigabit".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_DATA_UNIT_GIGABIT'] = "SRA_UTIL_DATA_UNIT_GIGABIT";
  }
  if ("sra_util_data_unit_gigabyte".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_DATA_UNIT_GIGABYTE'] = "SRA_UTIL_DATA_UNIT_GIGABYTE";
  }
  if ("sra_util_data_unit_terabit".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_DATA_UNIT_TERABIT'] = "SRA_UTIL_DATA_UNIT_TERABIT";
  }
  if ("sra_util_data_unit_terabyte".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_DATA_UNIT_TERABYTE'] = "SRA_UTIL_DATA_UNIT_TERABYTE";
  }
  if ("sra_util_data_unit_bit_labels".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_DATA_UNIT_BIT_LABELS'] = "SRA_UTIL_DATA_UNIT_BIT_LABELS";
  }
  if ("sra_util_data_unit_byte_labels".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_DATA_UNIT_BYTE_LABELS'] = "SRA_UTIL_DATA_UNIT_BYTE_LABELS";
  }
  if ("sra_util_data_unit_kilobit_labels".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_DATA_UNIT_KILOBIT_LABELS'] = "SRA_UTIL_DATA_UNIT_KILOBIT_LABELS";
  }
  if ("sra_util_data_unit_kilobyte_labels".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_DATA_UNIT_KILOBYTE_LABELS'] = "SRA_UTIL_DATA_UNIT_KILOBYTE_LABELS";
  }
  if ("sra_util_data_unit_megabit_labels".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_DATA_UNIT_MEGABIT_LABELS'] = "SRA_UTIL_DATA_UNIT_MEGABIT_LABELS";
  }
  if ("sra_util_data_unit_megabyte_labels".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_DATA_UNIT_MEGABYTE_LABELS'] = "SRA_UTIL_DATA_UNIT_MEGABYTE_LABELS";
  }
  if ("sra_util_data_unit_gigabit_labels".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_DATA_UNIT_GIGABIT_LABELS'] = "SRA_UTIL_DATA_UNIT_GIGABIT_LABELS";
  }
  if ("sra_util_data_unit_gigabyte_labels".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_DATA_UNIT_GIGABYTE_LABELS'] = "SRA_UTIL_DATA_UNIT_GIGABYTE_LABELS";
  }
  if ("sra_util_data_unit_terabit_labels".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_DATA_UNIT_TERABIT_LABELS'] = "SRA_UTIL_DATA_UNIT_TERABIT_LABELS";
  }
  if ("sra_util_data_unit_terabyte_labels".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_DATA_UNIT_TERABYTE_LABELS'] = "SRA_UTIL_DATA_UNIT_TERABYTE_LABELS";
  }
  if ("sra_util_measurement_centimeter".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_MEASUREMENT_CENTIMETER'] = "SRA_UTIL_MEASUREMENT_CENTIMETER";
  }
  if ("sra_util_measurement_foot".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_MEASUREMENT_FOOT'] = "SRA_UTIL_MEASUREMENT_FOOT";
  }
  if ("sra_util_measurement_inch".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_MEASUREMENT_INCH'] = "SRA_UTIL_MEASUREMENT_INCH";
  }
  if ("sra_util_measurement_kilometer".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_MEASUREMENT_KILOMETER'] = "SRA_UTIL_MEASUREMENT_KILOMETER";
  }
  if ("sra_util_measurement_meter".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_MEASUREMENT_METER'] = "SRA_UTIL_MEASUREMENT_METER";
  }
  if ("sra_util_measurement_mile".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_MEASUREMENT_MILE'] = "SRA_UTIL_MEASUREMENT_MILE";
  }
  if ("sra_util_measurement_yard".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_MEASUREMENT_YARD'] = "SRA_UTIL_MEASUREMENT_YARD";
  }
  if ("sra_util_measurement_gram".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_MEASUREMENT_GRAM'] = "SRA_UTIL_MEASUREMENT_GRAM";
  }
  if ("sra_util_measurement_kilogram".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_MEASUREMENT_KILOGRAM'] = "SRA_UTIL_MEASUREMENT_KILOGRAM";
  }
  if ("sra_util_measurement_ounce".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_MEASUREMENT_OUNCE'] = "SRA_UTIL_MEASUREMENT_OUNCE";
  }
  if ("sra_util_measurement_pound".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_MEASUREMENT_POUND'] = "SRA_UTIL_MEASUREMENT_POUND";
  }
  if ("sra_util_root".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_ROOT'] = "SRA_UTIL_ROOT";
  }
  if ("sra_util_services_config".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_SERVICES_CONFIG'] = "SRA_UTIL_SERVICES_CONFIG";
  }
  if ("sra_util_su_cmds_invalid_pswd".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_SU_CMDS_INVALID_PSWD'] = "SRA_UTIL_SU_CMDS_INVALID_PSWD";
  }
  if ("sra_util_su_cmds_invalid_user".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_SU_CMDS_INVALID_USER'] = "SRA_UTIL_SU_CMDS_INVALID_USER";
  }
  if ("sra_util_su_cmds_script".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_SU_CMDS_SCRIPT'] = "SRA_UTIL_SU_CMDS_SCRIPT";
  }
  if ("sra_util_su_password".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_SU_PASSWORD'] = "SRA_UTIL_SU_PASSWORD";
  }
  if ("sra_util_su_pswd_bad".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_SU_PSWD_BAD'] = "SRA_UTIL_SU_PSWD_BAD";
  }
  if ("sra_util_su_pswd_retype".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_SU_PSWD_RETYPE'] = "SRA_UTIL_SU_PSWD_RETYPE";
  }
  if ("sra_util_use_app_config_debug".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_USE_APP_CONFIG_DEBUG'] = "SRA_UTIL_USE_APP_CONFIG_DEBUG";
  }
  if ("sra_util_use_sys_config_debug".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_USE_SYS_CONFIG_DEBUG'] = "SRA_UTIL_USE_SYS_CONFIG_DEBUG";
  }
  if ("sra_util_url_safe_regex".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_UTIL_URL_SAFE_REGEX'] = "SRA_UTIL_URL_SAFE_REGEX";
  }


  // check methods
  if ("adddelimstring".indexOf(str) != -1) {
    match = true;
    matches['qs_method_addDelimString'] = "addDelimString";
  }
  if ("addsqloption".indexOf(str) != -1) {
    match = true;
    matches['qs_method_addSqlOption'] = "addSqlOption";
  }
  if ("applylimitoffset".indexOf(str) != -1) {
    match = true;
    matches['qs_method_applyLimitOffset'] = "applyLimitOffset";
  }
  if ("arraymerge".indexOf(str) != -1) {
    match = true;
    matches['qs_method_arrayMerge'] = "arrayMerge";
  }
  if ("arraytocsv".indexOf(str) != -1) {
    match = true;
    matches['qs_method_arrayToCsv'] = "arrayToCsv";
  }
  if ("tojson".indexOf(str) != -1) {
    match = true;
    matches['qs_method_toJson'] = "toJson";
  }
  if ("attrtoxml".indexOf(str) != -1) {
    match = true;
    matches['qs_method_attrToXml'] = "attrToXml";
  }
  if ("ishash".indexOf(str) != -1) {
    match = true;
    matches['qs_method_isHash'] = "isHash";
  }
  if ("beginswith".indexOf(str) != -1) {
    match = true;
    matches['qs_method_beginsWith'] = "beginsWith";
  }
  if ("endswith".indexOf(str) != -1) {
    match = true;
    matches['qs_method_endsWith'] = "endsWith";
  }
  if ("arraymovetotop".indexOf(str) != -1) {
    match = true;
    matches['qs_method_arrayMoveToTop'] = "arrayMoveToTop";
  }
  if ("bufferarray".indexOf(str) != -1) {
    match = true;
    matches['qs_method_bufferArray'] = "bufferArray";
  }
  if ("camelcasetodashes".indexOf(str) != -1) {
    match = true;
    matches['qs_method_camelCaseToDashes'] = "camelCaseToDashes";
  }
  if ("camelcasetounderscores".indexOf(str) != -1) {
    match = true;
    matches['qs_method_camelCaseToUnderscores'] = "camelCaseToUnderscores";
  }
  if ("camelcaseconvert".indexOf(str) != -1) {
    match = true;
    matches['qs_method_camelCaseConvert'] = "camelCaseConvert";
  }
  if ("checkbrowsercompatibility".indexOf(str) != -1) {
    match = true;
    matches['qs_method_checkBrowserCompatibility'] = "checkBrowserCompatibility";
  }
  if ("codetostring".indexOf(str) != -1) {
    match = true;
    matches['qs_method_codeToString'] = "codeToString";
  }
  if ("comparebitmasks".indexOf(str) != -1) {
    match = true;
    matches['qs_method_compareBitMasks'] = "compareBitMasks";
  }
  if ("isboolean".indexOf(str) != -1) {
    match = true;
    matches['qs_method_isBoolean'] = "isBoolean";
  }
  if ("convertboolean".indexOf(str) != -1) {
    match = true;
    matches['qs_method_convertBoolean'] = "convertBoolean";
  }
  if ("extractarrayvalue".indexOf(str) != -1) {
    match = true;
    matches['qs_method_extractArrayValue'] = "extractArrayValue";
  }
  if ("getarraylocation".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getArrayLocation'] = "getArrayLocation";
  }
  if ("getfileextension".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getFileExtension'] = "getFileExtension";
  }
  if ("getfilenamewoextension".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getFileNameWOExtension'] = "getFileNameWOExtension";
  }
  if ("getphpinimemorylimit".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getPhpIniMemoryLimit'] = "getPhpIniMemoryLimit";
  }
  if ("getprefixedarrayvalues".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getPrefixedArrayValues'] = "getPrefixedArrayValues";
  }
  if ("getcurrentuser".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getCurrentUser'] = "getCurrentUser";
  }
  if ("getprocessattr".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getProcessAttr'] = "getProcessAttr";
  }
  if ("getprocesshash".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getProcessHash'] = "getProcessHash";
  }
  if ("getprocessid".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getProcessId'] = "getProcessId";
  }
  if ("getprocessname".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getProcessName'] = "getProcessName";
  }
  if ("getrelativenumericval".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getRelativeNumericVal'] = "getRelativeNumericVal";
  }
  if ("getspellchecklanguages".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getSpellCheckLanguages'] = "getSpellCheckLanguages";
  }
  if ("getdefaultspellchecklanguage".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getDefaultSpellCheckLanguage'] = "getDefaultSpellCheckLanguage";
  }
  if ("getenglishordinalsuffix".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getEnglishOrdinalSuffix'] = "getEnglishOrdinalSuffix";
  }
  if ("gettextbetween".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getTextBetween'] = "getTextBetween";
  }
  if ("htmltotext".indexOf(str) != -1) {
    match = true;
    matches['qs_method_htmlToText'] = "htmlToText";
  }
  if ("implodeskipempty".indexOf(str) != -1) {
    match = true;
    matches['qs_method_implodeSkipEmpty'] = "implodeSkipEmpty";
  }
  if ("includeattributeinoutput".indexOf(str) != -1) {
    match = true;
    matches['qs_method_includeAttributeInOutput'] = "includeAttributeInOutput";
  }
  if ("isprocessactive".indexOf(str) != -1) {
    match = true;
    matches['qs_method_isProcessActive'] = "isProcessActive";
  }
  if ("issubclassof".indexOf(str) != -1) {
    match = true;
    matches['qs_method_isSubclassOf'] = "isSubclassOf";
  }
  if ("killprocess".indexOf(str) != -1) {
    match = true;
    matches['qs_method_killProcess'] = "killProcess";
  }
  if ("objtoarray".indexOf(str) != -1) {
    match = true;
    matches['qs_method_objToArray'] = "objToArray";
  }
  if ("parseemailstring".indexOf(str) != -1) {
    match = true;
    matches['qs_method_parseEmailString'] = "parseEmailString";
  }
  if ("printdebug".indexOf(str) != -1) {
    match = true;
    matches['qs_method_printDebug'] = "printDebug";
  }
  if ("rand".indexOf(str) != -1) {
    match = true;
    matches['qs_method_rand'] = "rand";
  }
  if ("removedelimstring".indexOf(str) != -1) {
    match = true;
    matches['qs_method_removeDelimString'] = "removeDelimString";
  }
  if ("replacearraykey".indexOf(str) != -1) {
    match = true;
    matches['qs_method_replaceArrayKey'] = "replaceArrayKey";
  }
  if ("sendemail".indexOf(str) != -1) {
    match = true;
    matches['qs_method_sendEmail'] = "sendEmail";
  }
  if ("spellcheck".indexOf(str) != -1) {
    match = true;
    matches['qs_method_spellcheck'] = "spellcheck";
  }
  if ("stripquotes".indexOf(str) != -1) {
    match = true;
    matches['qs_method_stripQuotes'] = "stripQuotes";
  }
  if ("strtohtml".indexOf(str) != -1) {
    match = true;
    matches['qs_method_strToHtml'] = "strToHtml";
  }
  if ("swapvalues".indexOf(str) != -1) {
    match = true;
    matches['qs_method_swapValues'] = "swapValues";
  }
  if ("writehttptofile".indexOf(str) != -1) {
    match = true;
    matches['qs_method_writeHttpToFile'] = "writeHttpToFile";
  }
  if ("validatebit".indexOf(str) != -1) {
    match = true;
    matches['qs_method_validateBit'] = "validateBit";
  }
  if ("validateemail".indexOf(str) != -1) {
    match = true;
    matches['qs_method_validateEmail'] = "validateEmail";
  }
  if ("ipv4tolong".indexOf(str) != -1) {
    match = true;
    matches['qs_method_ipv4ToLong'] = "ipv4ToLong";
  }
  if ("longtoipv4".indexOf(str) != -1) {
    match = true;
    matches['qs_method_longToIpv4'] = "longToIpv4";
  }
  if ("validateip".indexOf(str) != -1) {
    match = true;
    matches['qs_method_validateIp'] = "validateIp";
  }
  if ("sortobjects".indexOf(str) != -1) {
    match = true;
    matches['qs_method_sortObjects'] = "sortObjects";
  }
  if ("getcondvalfromtable".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getCondValFromTable'] = "getCondValFromTable";
  }
  if ("getfixedwidthstring".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getFixedWidthString'] = "getFixedWidthString";
  }
  if ("objecttostring".indexOf(str) != -1) {
    match = true;
    matches['qs_method_objectToString'] = "objectToString";
  }
  if ("copyobject".indexOf(str) != -1) {
    match = true;
    matches['qs_method_copyObject'] = "copyObject";
  }
  if ("removeleadingslash".indexOf(str) != -1) {
    match = true;
    matches['qs_method_removeLeadingSlash'] = "removeLeadingSlash";
  }
  if ("getnestedattr".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getNestedAttr'] = "getNestedAttr";
  }
  if ("getarray".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getArray'] = "getArray";
  }
  if ("getarrayreverse".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getArrayReverse'] = "getArrayReverse";
  }
  if ("equal".indexOf(str) != -1) {
    match = true;
    matches['qs_method_equal'] = "equal";
  }
  if ("getnewmatrix".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getNewMatrix'] = "getNewMatrix";
  }
  if ("invokemethod".indexOf(str) != -1) {
    match = true;
    matches['qs_method_invokeMethod'] = "invokeMethod";
  }
  if ("methodexists".indexOf(str) != -1) {
    match = true;
    matches['qs_method_methodExists'] = "methodExists";
  }
  if ("mergeobject".indexOf(str) != -1) {
    match = true;
    matches['qs_method_mergeObject'] = "mergeObject";
  }
  if ("mergearray".indexOf(str) != -1) {
    match = true;
    matches['qs_method_mergeArray'] = "mergeArray";
  }
  if ("isobject".indexOf(str) != -1) {
    match = true;
    matches['qs_method_isObject'] = "isObject";
  }
  if ("isnumericarray".indexOf(str) != -1) {
    match = true;
    matches['qs_method_isNumericArray'] = "isNumericArray";
  }
  if ("substituteparams".indexOf(str) != -1) {
    match = true;
    matches['qs_method_substituteParams'] = "substituteParams";
  }
  if ("getglobal".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getGlobal'] = "getGlobal";
  }
  if ("setglobal".indexOf(str) != -1) {
    match = true;
    matches['qs_method_setGlobal'] = "setGlobal";
  }
  if ("cliprompt".indexOf(str) != -1) {
    match = true;
    matches['qs_method_cliPrompt'] = "cliPrompt";
  }
  if ("sucmds".indexOf(str) != -1) {
    match = true;
    matches['qs_method_suCmds'] = "suCmds";
  }
  if ("passwd".indexOf(str) != -1) {
    match = true;
    matches['qs_method_passwd'] = "passwd";
  }
  if ("supasswd".indexOf(str) != -1) {
    match = true;
    matches['qs_method_suPasswd'] = "suPasswd";
  }
  if ("propertiesstringtohash".indexOf(str) != -1) {
    match = true;
    matches['qs_method_propertiesStringToHash'] = "propertiesStringToHash";
  }
  if ("isalphanumeric".indexOf(str) != -1) {
    match = true;
    matches['qs_method_isAlphaNumeric'] = "isAlphaNumeric";
  }
  if ("trimleadingzeros".indexOf(str) != -1) {
    match = true;
    matches['qs_method_trimLeadingZeros'] = "trimLeadingZeros";
  }
  if ("trimtrailingzeros".indexOf(str) != -1) {
    match = true;
    matches['qs_method_trimTrailingZeros'] = "trimTrailingZeros";
  }
  if ("normalizedataunit".indexOf(str) != -1) {
    match = true;
    matches['qs_method_normalizeDataUnit'] = "normalizeDataUnit";
  }
  if ("normalizemeasurement".indexOf(str) != -1) {
    match = true;
    matches['qs_method_normalizeMeasurement'] = "normalizeMeasurement";
  }
  if ("parsephpsource".indexOf(str) != -1) {
    match = true;
    matches['qs_method_parsePhpSource'] = "parsePhpSource";
  }
  if ("parsedtd".indexOf(str) != -1) {
    match = true;
    matches['qs_method_parseDtd'] = "parseDtd";
  }
  if ("validatestaticmethodpath".indexOf(str) != -1) {
    match = true;
    matches['qs_method_validateStaticMethodPath'] = "validateStaticMethodPath";
  }
  if ("invokestaticmethodpath".indexOf(str) != -1) {
    match = true;
    matches['qs_method_invokeStaticMethodPath'] = "invokeStaticMethodPath";
  }
  if ("getstaticmethodpathapi".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getStaticMethodPathApi'] = "getStaticMethodPathApi";
  }
  if ("ping".indexOf(str) != -1) {
    match = true;
    matches['qs_method_ping'] = "ping";
  }
  if ("fork".indexOf(str) != -1) {
    match = true;
    matches['qs_method_fork'] = "fork";
  }
  if ("getservicename".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getServiceName'] = "getServiceName";
  }
  if ("getserviceport".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getServicePort'] = "getServicePort";
  }
  if ("isprivatenetworkip".indexOf(str) != -1) {
    match = true;
    matches['qs_method_isPrivateNetworkIp'] = "isPrivateNetworkIp";
  }
  if ("createthumbnail".indexOf(str) != -1) {
    match = true;
    matches['qs_method_createThumbnail'] = "createThumbnail";
  }
  if ("stem".indexOf(str) != -1) {
    match = true;
    matches['qs_method_stem'] = "stem";
  }
  if ("parseuri".indexOf(str) != -1) {
    match = true;
    matches['qs_method_parseUri'] = "parseUri";
  }
  if ("objtohash".indexOf(str) != -1) {
    match = true;
    matches['qs_method_objToHash'] = "objToHash";
  }
  if ("mxlookup".indexOf(str) != -1) {
    match = true;
    matches['qs_method_mxlookup'] = "mxlookup";
  }
  if ("portinuse".indexOf(str) != -1) {
    match = true;
    matches['qs_method_portInUse'] = "portInUse";
  }

  // check classes
  if ("sra_workflow".indexOf(str) != -1) {
    match = true;
    matches['qs_class_SRA_Workflow'] = "SRA_Workflow";
  }
  if ("sra_workflowconstraint".indexOf(str) != -1) {
    match = true;
    matches['qs_class_SRA_WorkflowConstraint'] = "SRA_WorkflowConstraint";
  }
  if ("sra_workflowconstraintgroup".indexOf(str) != -1) {
    match = true;
    matches['qs_class_SRA_WorkflowConstraintGroup'] = "SRA_WorkflowConstraintGroup";
  }
  if ("sra_workflowdecision".indexOf(str) != -1) {
    match = true;
    matches['qs_class_SRA_WorkflowDecision'] = "SRA_WorkflowDecision";
  }
  if ("sra_workflowmanager".indexOf(str) != -1) {
    match = true;
    matches['qs_class_SRA_WorkflowManager'] = "SRA_WorkflowManager";
  }
  if ("sra_workflowstep".indexOf(str) != -1) {
    match = true;
    matches['qs_class_SRA_WorkflowStep'] = "SRA_WorkflowStep";
  }
  if ("sra_workflowtask".indexOf(str) != -1) {
    match = true;
    matches['qs_class_SRA_WorkflowTask'] = "SRA_WorkflowTask";
  }


  // check dtds
  if ("workflow.dtd".indexOf(str) != -1) {
    match = true;
    matches['qs_dtd_workflow.dtd'] = "workflow.dtd";
  }

  // check packages
  if ("etc".indexOf(str) != -1) {
    match = true;
    matches['qs_package_etc'] = "etc";
  }
  if ("etc.l10n".indexOf(str) != -1) {
    match = true;
    matches['qs_package_etc.l10n'] = "etc.l10n";
  }
  if ("auth".indexOf(str) != -1) {
    match = true;
    matches['qs_package_auth'] = "auth";
  }
  if ("core".indexOf(str) != -1) {
    match = true;
    matches['qs_package_core'] = "core";
  }
  if ("model".indexOf(str) != -1) {
    match = true;
    matches['qs_package_model'] = "model";
  }
  if ("sql".indexOf(str) != -1) {
    match = true;
    matches['qs_package_sql'] = "sql";
  }
  if ("test".indexOf(str) != -1) {
    match = true;
    matches['qs_package_test'] = "test";
  }
  if ("util".indexOf(str) != -1) {
    match = true;
    matches['qs_package_util'] = "util";
  }
  if ("util.installer".indexOf(str) != -1) {
    match = true;
    matches['qs_package_util.installer'] = "util.installer";
  }
  if ("util.l10n".indexOf(str) != -1) {
    match = true;
    matches['qs_package_util.l10n'] = "util.l10n";
  }
  if ("workflow".indexOf(str) != -1) {
    match = true;
    matches['qs_package_workflow'] = "workflow";
  }


  }
  
  if (match) {
    var html = '';
    for(var i in matches) {
      _tipIds.push(i);
      html += '<div id="' + i + '" style="background-color: white; cursor: pointer;" onclick="document.location.replace(\'#\' + this.id.substr(3))">' + matches[i] + '</div>\n';
    }
    document.getElementById('quicksearch_tips').innerHTML = html;
    showQsTips();
  }
  else {
    hideQsTips();
  }
}
-->
</script></head>
<body id="class" onload="document.getElementById('quicksearch').onkeyup = updateQsTips; document.getElementById('quicksearch').focus()">
  <h1 id="top">class SRA_Util</h1>
<p>&nbsp;&nbsp;&nbsp;&nbsp;package <a href="../packages/util.html" target="contentFrame">util</a></p>  <hr />
  <form onsubmit="return false">
  
  <div style="float:right">
    <b><label for="quicksearch">Quick Search:</label></b><br />
    <input id="quicksearch" type="text" onfocus="clearQsTips()" onblur="hideQsTips()" autocomplete="off" onclick="this.select()" /><br />
    <div id="quicksearch_tips" style="border: 1px solid #333; position:absolute; display:none"></div>
  </div>
  
  <pre>class SRA_Util</pre>
  
  <h2>Class Information</h2>
  <ul>
    <li><a href="#comments">Class Comments</a></li>
    <li><a href="#constants">Constants</a></li>
    <li><a href="#constant_details">Constant Details</a></li>
    <li><a href="#methods">Methods</a></li>
    <li><a href="#method_details">Method Details</a></li>
    <li><a href="#other">Other</a></li>
  </ul>
  
  <h2 id="comments">Comment</h2>
  <pre> This class is used to house random methods that do not logically belong in any other classes.
  Generally these methods will be used for minor calculations and processes that may be useful
  to other classes. All of the methods in this class are static.
 
</pre>
  
  <h2 id="constants">Class Constants</h2>
  <table border="1" width="100%">
    <tr>
      <td><pre>string </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_IP_REGEX">SRA_UTIL_IP_REGEX</a></pre>
<pre> regular expression used to locate an ip address
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_ASPELL">SRA_UTIL_ASPELL</a></pre>
<pre> the name of the aspell cli utility used by the getSpellCheckLanguages and
  spellcheck methods. aspell must be installed and present in the $PATH in
  order to use those methods
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_DATA_UNIT_BIT">SRA_UTIL_DATA_UNIT_BIT</a></pre>
<pre> unit identifiers for a &#039;bit&#039;, this is the smallest unit size. the
  SRA_UTIL_DATA_UNIT_* constants are used by the SRA_Util::normalizeDataUnit
  method below
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_DATA_UNIT_BYTE">SRA_UTIL_DATA_UNIT_BYTE</a></pre>
<pre> unit identifiers for a &#039;byte&#039;
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_DATA_UNIT_KILOBIT">SRA_UTIL_DATA_UNIT_KILOBIT</a></pre>
<pre> unit identifiers for a &#039;kilobit&#039;
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_DATA_UNIT_KILOBYTE">SRA_UTIL_DATA_UNIT_KILOBYTE</a></pre>
<pre> unit identifiers for a &#039;kilobyte&#039;
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_DATA_UNIT_MEGABIT">SRA_UTIL_DATA_UNIT_MEGABIT</a></pre>
<pre> unit identifiers for a &#039;megabit&#039;
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_DATA_UNIT_MEGABYTE">SRA_UTIL_DATA_UNIT_MEGABYTE</a></pre>
<pre> unit identifiers for a &#039;megabyte&#039;
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_DATA_UNIT_GIGABIT">SRA_UTIL_DATA_UNIT_GIGABIT</a></pre>
<pre> unit identifiers for a &#039;gigabit&#039;
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_DATA_UNIT_GIGABYTE">SRA_UTIL_DATA_UNIT_GIGABYTE</a></pre>
<pre> unit identifiers for a &#039;gigabyte&#039;
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_DATA_UNIT_TERABIT">SRA_UTIL_DATA_UNIT_TERABIT</a></pre>
<pre> unit identifiers for a &#039;terabit&#039;
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_DATA_UNIT_TERABYTE">SRA_UTIL_DATA_UNIT_TERABYTE</a></pre>
<pre> unit identifiers for a &#039;terabyte&#039;
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_DATA_UNIT_BIT_LABELS">SRA_UTIL_DATA_UNIT_BIT_LABELS</a></pre>
<pre> space separated list of unit labels used to identify a bit. if a label is
  prefixed with : the search for it will not be case sensitive
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_DATA_UNIT_BYTE_LABELS">SRA_UTIL_DATA_UNIT_BYTE_LABELS</a></pre>
<pre> space separated list of unit labels used to identify a byte
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_DATA_UNIT_KILOBIT_LABELS">SRA_UTIL_DATA_UNIT_KILOBIT_LABELS</a></pre>
<pre> space separated list of unit labels used to identify a kilobit
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_DATA_UNIT_KILOBYTE_LABELS">SRA_UTIL_DATA_UNIT_KILOBYTE_LABELS</a></pre>
<pre> space separated list of unit labels used to identify a kilobyte
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_DATA_UNIT_MEGABIT_LABELS">SRA_UTIL_DATA_UNIT_MEGABIT_LABELS</a></pre>
<pre> space separated list of unit labels used to identify a megabit
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_DATA_UNIT_MEGABYTE_LABELS">SRA_UTIL_DATA_UNIT_MEGABYTE_LABELS</a></pre>
<pre> space separated list of unit labels used to identify a megabyte
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_DATA_UNIT_GIGABIT_LABELS">SRA_UTIL_DATA_UNIT_GIGABIT_LABELS</a></pre>
<pre> space separated list of unit labels used to identify a gigabit
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_DATA_UNIT_GIGABYTE_LABELS">SRA_UTIL_DATA_UNIT_GIGABYTE_LABELS</a></pre>
<pre> space separated list of unit labels used to identify a gigabyte
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_DATA_UNIT_TERABIT_LABELS">SRA_UTIL_DATA_UNIT_TERABIT_LABELS</a></pre>
<pre> space separated list of unit labels used to identify a terabit
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_DATA_UNIT_TERABYTE_LABELS">SRA_UTIL_DATA_UNIT_TERABYTE_LABELS</a></pre>
<pre> space separated list of unit labels used to identify a terabyte
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_MEASUREMENT_CENTIMETER">SRA_UTIL_MEASUREMENT_CENTIMETER</a></pre>
<pre> measurement identifiers for a &#039;centimeter&#039;
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_MEASUREMENT_FOOT">SRA_UTIL_MEASUREMENT_FOOT</a></pre>
<pre> measurement identifiers for a &#039;foot&#039;
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_MEASUREMENT_INCH">SRA_UTIL_MEASUREMENT_INCH</a></pre>
<pre> measurement identifiers for an &#039;inch&#039;
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_MEASUREMENT_KILOMETER">SRA_UTIL_MEASUREMENT_KILOMETER</a></pre>
<pre> measurement identifiers for a &#039;kilometer&#039;
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_MEASUREMENT_METER">SRA_UTIL_MEASUREMENT_METER</a></pre>
<pre> measurement identifiers for a &#039;meter&#039;
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_MEASUREMENT_MILE">SRA_UTIL_MEASUREMENT_MILE</a></pre>
<pre> measurement identifiers for a &#039;mile&#039;
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_MEASUREMENT_YARD">SRA_UTIL_MEASUREMENT_YARD</a></pre>
<pre> measurement identifiers for a &#039;yard&#039;
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_MEASUREMENT_GRAM">SRA_UTIL_MEASUREMENT_GRAM</a></pre>
<pre> measurement identifiers for a &#039;gram&#039;
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_MEASUREMENT_KILOGRAM">SRA_UTIL_MEASUREMENT_KILOGRAM</a></pre>
<pre> measurement identifiers for a &#039;kilogram&#039;
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_MEASUREMENT_OUNCE">SRA_UTIL_MEASUREMENT_OUNCE</a></pre>
<pre> measurement identifiers for an &#039;ounce&#039;
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_MEASUREMENT_POUND">SRA_UTIL_MEASUREMENT_POUND</a></pre>
<pre> measurement identifiers for a &#039;pound&#039;
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_ROOT">SRA_UTIL_ROOT</a></pre>
<pre> the root username
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_SERVICES_CONFIG">SRA_UTIL_SERVICES_CONFIG</a></pre>
<pre> path to the services config file used by SRA_Util::getServiceName($port)
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_SU_CMDS_INVALID_PSWD">SRA_UTIL_SU_CMDS_INVALID_PSWD</a></pre>
<pre> string token that identifies an invalid password in SRA_Util::suCmds
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_SU_CMDS_INVALID_USER">SRA_UTIL_SU_CMDS_INVALID_USER</a></pre>
<pre> string token that identifies an invalid user in SRA_Util::suCmds
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_SU_CMDS_SCRIPT">SRA_UTIL_SU_CMDS_SCRIPT</a></pre>
<pre> the name of the temporary script created by SRA_Util::suCmds
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_SU_PASSWORD">SRA_UTIL_SU_PASSWORD</a></pre>
<pre> string token that identifies the password prompt in SRA_Util::suCmds and
  SRA_Util::suPswd
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_SU_PSWD_BAD">SRA_UTIL_SU_PSWD_BAD</a></pre>
<pre> string token that identifies an bad password in SRA_Util::suPswd
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_SU_PSWD_RETYPE">SRA_UTIL_SU_PSWD_RETYPE</a></pre>
<pre> string token that identifies the retype password command in SRA_Util::suPswd
</pre>      </td>
    </tr>
    <tr>
      <td><pre>int </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_USE_APP_CONFIG_DEBUG">SRA_UTIL_USE_APP_CONFIG_DEBUG</a></pre>
<pre> The value to use in the printDebug method to identify that the app debug flag should be used
</pre>      </td>
    </tr>
    <tr>
      <td><pre>int </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_USE_SYS_CONFIG_DEBUG">SRA_UTIL_USE_SYS_CONFIG_DEBUG</a></pre>
<pre> The value to use in the printDebug method to identify that the system debug flag should be used
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string </pre></td>
      <td>
        <pre><a href="#constant_SRA_UTIL_URL_SAFE_REGEX">SRA_UTIL_URL_SAFE_REGEX</a></pre>
<pre> regular expression used to strip out non-url-safe characters
</pre>      </td>
    </tr>
  </table>
  

  <h2 id="methods">Class Methods</h2>
  <table border="1" width="100%">
    <tr>
      <td><pre>public static String</pre></td>
      <td>
        <pre><a href="#method_addDelimString">addDelimString</a>($string, $delim=", $", $quote='"')</pre>
<pre> This method is used add or imbed a delimeter string. For example, if parsing a csv file you
  would want to use this method to convert commas in between quotes to a delim string that
  could later be converted back to a comma. This method would perform that function.
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static String</pre></td>
      <td>
        <pre><a href="#method_addSqlOption">addSqlOption</a>($sql, $option)</pre>
<pre> This static method adds an option to a sql statement. It uses the WHERE clause if no options
  exist in the sql statement. Otherwise it uses the AND clause.
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static array</pre></td>
      <td>
        <pre>&amp;<a href="#method_applyLimitOffset">applyLimitOffset</a>(array $arr, int $limit, int $offset, boolean $preserveKeys=FALSE)</pre>
<pre> used to apply limit and offset contraints to an array. returns a new
  array with those constraints applied
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static String[]</pre></td>
      <td>
        <pre>&amp;<a href="#method_arrayMerge">arrayMerge</a>($master, $merge, $overwriteExisting=true)</pre>
<pre> This method merges two arrays based on the parameters specified.
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static String</pre></td>
      <td>
        <pre>&amp;<a href="#method_arrayToCsv">arrayToCsv</a>($report, $useQuotes=true)</pre>
<pre> This method converts an array of arrays of strings to a csv formatted string. Each row in
  the array will be separated by a line break &quot;\n&quot; and each column will be separated by a
  comma and surrounded by double quotes (if the useQuotes parameter is true).
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public String</pre></td>
      <td>
        <pre><a href="#method_toJson">toJson</a>(mixed $attr, array $include, array $exclude, boolean $javascriptDate=FALSE)</pre>
<pre> converts $attr to the appropriate representation in a javascript evaluable
  string. the global variables $_utilDateFormat and $_utilTimeFormat
  may be specified to use an alternate date/time format
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public string</pre></td>
      <td>
        <pre><a href="#method_attrToXml">attrToXml</a>(mixed $attr, array $include, array $exclude, string $fileElementName=NULL, boolean $usePrimaryKey=FALSE, boolean $camelCase=FALSE, string $ikey=NULL)</pre>
<pre> converts $attr to the appropriate representation in a xml renderable array.
  the global variables $_utilDateFormat and $_utilTimeFormat may be
  specified to use an alternate date/time format
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public boolean</pre></td>
      <td>
        <pre><a href="#method_isHash">isHash</a>(array $arr)</pre>
<pre> returns TRUE if $arr is a hash (array indexes do not start with 0 and
  increment)
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public boolean</pre></td>
      <td>
        <pre><a href="#method_beginsWith">beginsWith</a>(string $str, string $substr, boolean $caseSensitive=TRUE)</pre>
<pre> returns TRUE if the $str specified begins with $substr
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public boolean</pre></td>
      <td>
        <pre><a href="#method_endsWith">endsWith</a>(string $str, string $substr, boolean $caseSensitive=TRUE)</pre>
<pre> returns TRUE if the $str specified ends with $substr
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public array</pre></td>
      <td>
        <pre>&amp;<a href="#method_arrayMoveToTop">arrayMoveToTop</a>(array $arr, string $key)</pre>
<pre> moves the array element $key to the top of the array and returns the new
  array
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static String</pre></td>
      <td>
        <pre><a href="#method_bufferArray">bufferArray</a>($array, $name, $indent=2, $recursive=false)</pre>
<pre> This method is used to convert an array into text (which may be imported into php at some
  point in the future to become an array). This method supports any number of levels of arrays.
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public String</pre></td>
      <td>
        <pre><a href="#method_camelCaseToDashes">camelCaseToDashes</a>(string $str, boolean $upper=FALSE)</pre>
<pre> returns the camel case variable name in a dash format
  e.g. myVariableName would return my-variable-name
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public String</pre></td>
      <td>
        <pre><a href="#method_camelCaseToUnderscores">camelCaseToUnderscores</a>(string $str, boolean $upper=FALSE)</pre>
<pre> returns the camel case variable name in an underscore format
  e.g. myVariableName would return my_variable_name
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public String</pre></td>
      <td>
        <pre><a href="#method_camelCaseConvert">camelCaseConvert</a>(string $str, string $delim, boolean $upper=FALSE)</pre>
<pre> converts a camel case (ie &#039;myNameIsBob&#039;) value into a fixed case value using
  $delim as the value to place between each camel case occurrence. for
  example, if $delim was &#039;_&#039; the value above would become &#039;my_name_is_bob&#039;
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public void</pre></td>
      <td>
        <pre><a href="#method_checkBrowserCompatibility">checkBrowserCompatibility</a>($supportedBrowsers, string $errorTpl)</pre>
<pre> checks for browser compatibility and displays an error page when an
  incompatible browser is encountered. when the php script is being run at
  the command line, the compatibility check will be bypassed
</pre>      </td>
    </tr>
    <tr>
      <td><pre>void</pre></td>
      <td>
        <pre><a href="#method_codeToString">codeToString</a>($code)</pre>
<pre> Used function used to forward to SRA_Util:: function (see method api for more
  info)
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static boolean</pre></td>
      <td>
        <pre><a href="#method_compareBitMasks">compareBitMasks</a>($mask, $compare, $full)</pre>
<pre> This method compares two bitmasks. It returns true if all of the bits specified in the mask
  parameter are also specified in the compare parameter.
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static boolean</pre></td>
      <td>
        <pre><a href="#method_isBoolean">isBoolean</a>($bool)</pre>
<pre> returns TRUE if $bool is a valid representation of the boolean data type
  the following are considered valid representations:
 	 boolean constants TRUE/FALSE
    integers 1/0
 	 strings &#039;1&#039;/&#039;0&#039;
    strings &#039;true&#039;/&#039;false&#039; (not case sensitive)
    strings &#039;t&#039;/&#039;f&#039;
    strings &#039;yes&#039;/&#039;no&#039;
    strings &#039;y&#039;/&#039;n&#039;
    strings &#039;on&#039;/&#039;off&#039;
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static mixed</pre></td>
      <td>
        <pre><a href="#method_convertBoolean">convertBoolean</a>(mixed $bool, boolean $default=NULL)</pre>
<pre> returns TRUE if $bool is a valid boolean data type representation of TRUE
  (see isBoolean api documentation for more details on what is considered
  a valid boolean data type representation). returns NULL if $bool is not a
  valid boolean type
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static boolean</pre></td>
      <td>
        <pre>&amp;<a href="#method_extractArrayValue">extractArrayValue</a>($array, $key, $typeCast=NULL, $returnValue=NULL)</pre>
<pre> Extracts and returns the value in the array identified by the key parameter.
  Returns the return parameter (default is NULL) is that array key is not set.
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static Object</pre></td>
      <td>
        <pre>&amp;<a href="#method_getArrayLocation">getArrayLocation</a>($array, $value, $recursive=false, $arrayKey=NULL)</pre>
<pre> Returns a reference to a location in an array containing the value specified.
  Returns an OPERATIONAL SRA_Error object if the key is not found.
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static string</pre></td>
      <td>
        <pre><a href="#method_getFileExtension">getFileExtension</a>(string $fileName, boolean $urlSafe=FALSE)</pre>
<pre> Returns the file extension for a given file (the string following the
  last .) or empty string if there is not extension
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static String</pre></td>
      <td>
        <pre><a href="#method_getFileNameWOExtension">getFileNameWOExtension</a>(string $fileName, boolean $urlSafe=FALSE)</pre>
<pre> Returns the file extension for a given file (the string following the
  last .)
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static String</pre></td>
      <td>
        <pre><a href="#method_getPhpIniMemoryLimit">getPhpIniMemoryLimit</a>()</pre>
<pre> This method returns the memory_limit specified in the php.ini file in
  bytes.
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>array</pre></td>
      <td>
        <pre>&amp;<a href="#method_getPrefixedArrayValues">getPrefixedArrayValues</a>(string $prefix, array $arr, boolean $removePrefix=TRUE)</pre>
<pre> returns a sub-array containing all of the values in $arr that are
  are prefixed with $prefix
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string</pre></td>
      <td>
        <pre><a href="#method_getCurrentUser">getCurrentUser</a>()</pre>
<pre> same as the php &#039;get_current_user&#039; function but returns the correct
  username for child processes (the &#039;get_current_user&#039; function returns the
  username for the parent process even if the child process owner is
  different)
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string</pre></td>
      <td>
        <pre><a href="#method_getProcessAttr">getProcessAttr</a>(string $attr, int $pid=NULL)</pre>
<pre> returns a process attribute
</pre>      </td>
    </tr>
    <tr>
      <td><pre>hash</pre></td>
      <td>
        <pre><a href="#method_getProcessHash">getProcessHash</a>(string $val='command')</pre>
<pre> returns a hash of the currently running processes where the key is the pid
  and the value is the process command
</pre>      </td>
    </tr>
    <tr>
      <td><pre>mixed</pre></td>
      <td>
        <pre><a href="#method_getProcessId">getProcessId</a>(string $script, boolean $last=TRUE, mixed $user=NULL, boolean $multiple=FALSE)</pre>
<pre> this method returns the pid of the $script process. NULL is returned if
  no process currently exists. if $multiple is TRUE, the return value will be
  an array containing all of the matching pids (or NULL if none)
</pre>      </td>
    </tr>
    <tr>
      <td><pre>mixed</pre></td>
      <td>
        <pre><a href="#method_getProcessName">getProcessName</a>(int $pid)</pre>
<pre> returns the name of the process identified by $pid. returns NULL if $pid is
  not a valid process. the name of the process is the &quot;command&quot; keyword from
  ps
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static int</pre></td>
      <td>
        <pre><a href="#method_getRelativeNumericVal">getRelativeNumericVal</a>(string $expr)</pre>
<pre> returns the numeric value for a relative $expr where $expr is in the format
  &quot;+n&quot; and n may be designated as negative by enclosing it in parenthesis
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static array</pre></td>
      <td>
        <pre>&amp;<a href="#method_getSpellCheckLanguages">getSpellCheckLanguages</a>()</pre>
<pre> returns the spellcheck languages as an associative array where the key is
  the locale code (see SRA_Locale::getLocale($code...)), and the value is
  the locale label (see SRA_Locale::getLabel()). returns NULL if aspell is
  not available or if the dictionary path cannot be determined or read from
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static String</pre></td>
      <td>
        <pre><a href="#method_getDefaultSpellCheckLanguage">getDefaultSpellCheckLanguage</a>()</pre>
<pre> returns the default spell check language code for the current active user
  this is done by first accessing the spellcheck languages using
  SRA_Util::getSpellCheckLanguages() followed by the user&#039;s locales using
  SRA_Controller::getUserLocales(), and then finding the first match in the
  spellcheck languages that exists in the user&#039;s locales. if not match is
  found the first spell check language will be returned. if there are no
  spellcheck languages NULL will be returned
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>publicstatic String</pre></td>
      <td>
        <pre><a href="#method_getEnglishOrdinalSuffix">getEnglishOrdinalSuffix</a>(int $number)</pre>
<pre> returns the english ordinal suffix for $number (st, nd, rd, or th)
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static String</pre></td>
      <td>
        <pre>&amp;<a href="#method_getTextBetween">getTextBetween</a>($startToken, $endToken, $text)</pre>
<pre> Returns a substring of the text provided that is between the startToken
  and the endToken
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static void</pre></td>
      <td>
        <pre><a href="#method_htmlToText">htmlToText</a>($html)</pre>
<pre> This method is used to convert html to plain text (no html tags)
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static string</pre></td>
      <td>
        <pre><a href="#method_implodeSkipEmpty">implodeSkipEmpty</a>(string $glue, array $pieces, boolean $lead=FALSE, boolean $trim=TRUE)</pre>
<pre> same as the php implode function but skips $pieces values that are empty
  (do not evaluate to PHP true)
</pre>      </td>
    </tr>
    <tr>
      <td><pre>boolean</pre></td>
      <td>
        <pre><a href="#method_includeAttributeInOutput">includeAttributeInOutput</a>(string $attr, mixed $include, mixed $exclude)</pre>
<pre> returns TRUE if ($include is an array and $attr is in it or if $include
  is not an array) and ($exclude is an array and $attr is not in it or if
  $exclude is not an array)
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>boolean</pre></td>
      <td>
        <pre><a href="#method_isProcessActive">isProcessActive</a>(int $pid)</pre>
<pre> returns TRUE if a process identified by $pid is currently active
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static boolean</pre></td>
      <td>
        <pre><a href="#method_isSubclassOf">isSubclassOf</a>($parent, $child)</pre>
<pre> This method is very simliar to the built in php is_subclass_of function with the
  exception that the object parameter may be either an object or a class name
  (php function requires it to be an object). This method returns true if the
  parent parameter class type is a class that the child parameter extends from.
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public boolean</pre></td>
      <td>
        <pre><a href="#method_killProcess">killProcess</a>(int $pid)</pre>
<pre> kills $pid if it is active. returns TRUE on success, FALSE if the kill
  fails, and NULL if $pid is not valid
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public array</pre></td>
      <td>
        <pre>&amp;<a href="#method_objToArray">objToArray</a>($obj)</pre>
<pre> returns the attributes associated with an object as an associative array
  where the array index is the attribute name. all leading underscores are
  removed from the attribute names. only attributes with leading underscores
  are included in the returned array
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public array</pre></td>
      <td>
        <pre><a href="#method_parseEmailString">parseEmailString</a>(string $str)</pre>
<pre> used to parse an email string and return the corresponding name and email
  values from the string. an email string may be in any of the following
  formats:
    john@doe.com
    &lt;john@doe.com&gt;
    John Doe &lt;john@doe.com&gt;
    &quot;John Doe&quot; &lt;john@doe.com&gt;
  the return value will be a hash with the keys &#039;email&#039; and &#039;name&#039; where
  those values were extracted from the email string provided. name may not
  be present in the return value if it is not part of the email string
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static void</pre></td>
      <td>
        <pre><a href="#method_printDebug">printDebug</a>($output, $debug=SRA_UTIL_USE_SYS_CONFIG_DEBUG, $file="", $line, $pre=false, $quiet=false, $timestamp=false, $traceFile=false)</pre>
<pre> This method displays a debug statement followed by a newline character if the debug parameter
  is true. If no debug statement is specified it checks the SRA_Controller::DEBUG constant. If this
  is true, it displays the debug info.
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static int</pre></td>
      <td>
        <pre><a href="#method_rand">rand</a>(int $min, int $max)</pre>
<pre> wrapper for the php rand function (for use in templates)
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static void</pre></td>
      <td>
        <pre><a href="#method_removeDelimString">removeDelimString</a>($string, $delim=", $")</pre>
<pre> This method is used remove a delimeter string added through the addDelimString method..
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static String[]</pre></td>
      <td>
        <pre>&amp;<a href="#method_replaceArrayKey">replaceArrayKey</a>($arr, $oldKey, $newKey, $caseSensitive=TRUE)</pre>
<pre> This method is used replace an array key. It simply unsets the array element with the key
  identified by the oldKey parameter and adds the value at that element to a new key identified
  by the newKey parameter. If the oldKey does not exist, or the newKey does, the array will be
  returned as is.
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static void</pre></td>
      <td>
        <pre><a href="#method_sendEmail">sendEmail</a>(mixed $to, string $subject, string $message=NULL, string $messageHtml=NULL, string $from=NULL, string $fromName=NULL, mixed $toName=NULL, string $cc=NULL, string $bcc=NULL, mixed $attachments)</pre>
<pre> sends an email message based on the following parameters:
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static array</pre></td>
      <td>
        <pre><a href="#method_spellcheck">spellcheck</a>(string $str, string $lang=NULL, boolean $html=FALSE, array $skip=NULL)</pre>
<pre> used to spellcheck $str. the return value is an associative array with
  the following values:
   word:        the word that was mispelled
   suggestions: an array containing correction suggestion (NULL if none)
   offsets:     character positions in $str where the mispelling occured
                (will contain 1 or more character positions if mispelled
                multiple times)
  this array will be indexed by &quot;word&quot;. if aspell is not enabled, or
  another error occurs, this method will will return NULL
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static void</pre></td>
      <td>
        <pre><a href="#method_stripQuotes">stripQuotes</a>($string, $quoteTokenStart='"', $quoteTokenEnd='"')</pre>
<pre> This method is used to strip quotes (or another quote token) from a string. It returns the stripped string
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static void</pre></td>
      <td>
        <pre><a href="#method_strToHtml">strToHtml</a>(string $str)</pre>
<pre> replaces linebreaks with html &lt;br /&gt; tags and other special html
  characters to HTML entities
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static void</pre></td>
      <td>
        <pre><a href="#method_swapValues">swapValues</a>($currVal, $firstVal, $secondVal)</pre>
<pre> Swaps two values
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static void</pre></td>
      <td>
        <pre><a href="#method_writeHttpToFile">writeHttpToFile</a>($file, $errorMsg="")</pre>
<pre> This method is used to write an http request to a file. To do this it extracts all of the
  related data from the GLOBAL variables $_POST, $_GET, $_COOKIE, $_SERVER, and $_ENV
  and writes them to a file containing arrays specifying these values. The optional errorMsg
  attribute may be specified to have an errorMsg array attribute added to the &#039;values&#039; array (the
  array in which all of the values are stored) along with the other globals (&#039;_POST&#039;, &#039;_GET&#039;, etc.).
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static boolean</pre></td>
      <td>
        <pre><a href="#method_validateBit">validateBit</a>($bit, $fullBitMask)</pre>
<pre> Returns true if the bit parameter specified is a single bit in the fullBitMask parameter.
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static boolean</pre></td>
      <td>
        <pre><a href="#method_validateEmail">validateEmail</a>(string $email)</pre>
<pre> returns TRUE if an email address is properly constructed, FALSE otherwise
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public long</pre></td>
      <td>
        <pre><a href="#method_ipv4ToLong">ipv4ToLong</a>(string $ip)</pre>
<pre> converts an IP address to it&#039;s corresponding numeric value
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public string</pre></td>
      <td>
        <pre><a href="#method_longToIpv4">longToIpv4</a>(long $num)</pre>
<pre> converts a numeric IPv4 address to dot notation
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public boolean</pre></td>
      <td>
        <pre><a href="#method_validateIp">validateIp</a>(array $validateAddresses, string $validateAddress=false)</pre>
<pre> This method is used to validate an IP address against an array of valid IPs. If the IP
  address is valid it returns true. Otherwise it returns false.
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>object[]</pre></td>
      <td>
        <pre>&amp;<a href="#method_sortObjects">sortObjects</a>(object[] $objects, string $getter, boolean $desc=TRUE, int $maintainKeys=TRUE)</pre>
<pre> used to sort objects based on a given attribute
</pre>      </td>
    </tr>
    <tr>
      <td><pre>String</pre></td>
      <td>
        <pre><a href="#method_getCondValFromTable">getCondValFromTable</a>(array[][] $table, int $condValCol, String $condVal, int $valCol)</pre>
<pre> Used to return a value from a two dimensional table
</pre>      </td>
    </tr>
    <tr>
      <td><pre>String</pre></td>
      <td>
        <pre><a href="#method_getFixedWidthString">getFixedWidthString</a>(String $string, int $width=FALSE)</pre>
<pre> Used to add padding to a string so that it conforms with a specified width
</pre>      </td>
    </tr>
    <tr>
      <td><pre>String</pre></td>
      <td>
        <pre>&amp;<a href="#method_objectToString">objectToString</a>($object)</pre>
<pre> Converts an object instance into a string representation using the print_r
  function and output buffering (ob_start)
</pre>      </td>
    </tr>
    <tr>
      <td><pre>Object</pre></td>
      <td>
        <pre><a href="#method_copyObject">copyObject</a>($object)</pre>
<pre> Creates a copy of an object
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string</pre></td>
      <td>
        <pre><a href="#method_removeLeadingSlash">removeLeadingSlash</a>($str)</pre>
<pre> removes a leading slash from a string
</pre>      </td>
    </tr>
    <tr>
      <td><pre>mixed</pre></td>
      <td>
        <pre><a href="#method_getNestedAttr">getNestedAttr</a>(mixed $baseObj, string $attrId)</pre>
<pre> gets the attribute specified from the baseObj if it exists
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static array</pre></td>
      <td>
        <pre><a href="#method_getArray">getArray</a>(int $size, int $start=1, int $increment=1)</pre>
<pre> simple method that returns an array of size $size
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static array</pre></td>
      <td>
        <pre><a href="#method_getArrayReverse">getArrayReverse</a>(int $size, int $start=1, int $increment=1)</pre>
<pre> same as #getArray, but returns elements in reverse order
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static boolean</pre></td>
      <td>
        <pre><a href="#method_equal">equal</a>(mixed $attr, mixed $match)</pre>
<pre> returns TRUE if $attr and $match are equal based on the following criteria:
    1) if $attr and $match are both the same scalar type and equal, then return TRUE.
    2) if $attr and $match are both objects with equals methods, then return $attr-&gt;equals($match)
    3) if $attr or $match are objects with a &quot;getPrimaryKey&quot; method, invoke those methods and compare the results, return TRUE if equal
    4) if $attr is an array, and $match is not, then check 1-3 for each element in $attr, return TRUE if any matches are found
    5) if $attr is an array and $match is an array, then check 4 for each element of $match and return TRUE if all return TRUE
    6) if $attr and $match are both booleans (as determined by SRA_Util::isBoolean) and equal (as determined by SRA_Util::convertBoolean), then return TRUE
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static <a href="util.SRA_Matrix.html" target="contentFrame">SRA_Matrix</a></pre></td>
      <td>
        <pre><a href="#method_getNewMatrix">getNewMatrix</a>()</pre>
<pre> returns a new instance of a SRA_Matrix object
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static mixed</pre></td>
      <td>
        <pre>&amp;<a href="#method_invokeMethod">invokeMethod</a>(Object $obj, string $method, string $param1=FALSE, string $param2=FALSE, string $param3=FALSE)</pre>
<pre> invoked a method on an object if it exists and returns the value of that
  method call. returns $obj if $obj is not an object or the $method does not
  exist
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static boolean</pre></td>
      <td>
        <pre><a href="#method_methodExists">methodExists</a>(mixed $obj, string $method)</pre>
<pre> returns TRUE if $obj is an object and has a method $method
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static void</pre></td>
      <td>
        <pre><a href="#method_mergeObject">mergeObject</a>(Object $obj, Object $merge, boolean $overwrite=FALSE)</pre>
<pre> recursively merges the attributes of 2 objects. only those attrs that exist
  in $merge and not in $obj (or are not set) will be merged unless $overwrite
  is TRUE
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static void</pre></td>
      <td>
        <pre><a href="#method_mergeArray">mergeArray</a>(array $arr1, array $arr2, boolean $overwrite=FALSE)</pre>
<pre> recursively merges the 2 arrays. only those attrs that exist in $arr2
  and not in $arr1 (or are not set) will be merged
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static void</pre></td>
      <td>
        <pre><a href="#method_isObject">isObject</a>(Object $obj, $type=FALSE)</pre>
<pre> used to validate an object is actually an object and optionally of a
  specific type
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public static boolean</pre></td>
      <td>
        <pre><a href="#method_isNumericArray">isNumericArray</a>(array $arr)</pre>
<pre> returns true if $arr is an array with a numeric incrementing index starting
  at 0
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public string</pre></td>
      <td>
        <pre><a href="#method_substituteParams">substituteParams</a>(string $str, array $params)</pre>
<pre> substitutes params in $str with their values in $params where the values
  are embedded using the format &quot;${param name}&quot;
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public string</pre></td>
      <td>
        <pre>&amp;<a href="#method_getGlobal">getGlobal</a>(string $name)</pre>
<pre> returns the value of a global variable
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public void</pre></td>
      <td>
        <pre>&amp;<a href="#method_setGlobal">setGlobal</a>(string $name, mixed $val)</pre>
<pre> sets a global variable
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public string</pre></td>
      <td>
        <pre><a href="#method_cliPrompt">cliPrompt</a>(string $question, boolean $required=TRUE, array $options=NULL)</pre>
<pre> prompts the user for an input value from the command line and returns that
  value
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public mixed</pre></td>
      <td>
        <pre><a href="#method_suCmds">suCmds</a>(string $user, string $pswd, mixed $cmds=NULL, hash $callbacks=NULL, boolean $skipSuIfEqual=FALSE, boolean $asynchronous=FALSE)</pre>
<pre> uses expect (http://expect.nist.gov) to login as another user and execute
  the commands specified by $cmds. returns a hash indexed by the $cmds where
  the value is the result of executing those commands if the login was
  successful (returns TRUE if $cmds is not specified). otherwise, returns 0
  if expect is not installed, -1 for invalid user, -2 for invalid password
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public boolean</pre></td>
      <td>
        <pre><a href="#method_passwd">passwd</a>(string $pswd, string $curPswd=NULL, string $user=NULL, string $output)</pre>
<pre> uses expect (http://expect.nist.gov) to change the current running user&#039;s
  password. alternatively, if the current running user is root, $user may be
  specified identifying the name of another user to change the password for.
  returns TRUE on success, FALSE otherwise
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public boolean</pre></td>
      <td>
        <pre><a href="#method_suPasswd">suPasswd</a>(string $user, string $pswd, string $newPswd, boolean $root=FALSE, string $output)</pre>
<pre> uses expect (http://expect.nist.gov) to change a system user&#039;s password.
  return TRUE on success, FALSE otherwise
</pre>      </td>
    </tr>
    <tr>
      <td><pre>hash</pre></td>
      <td>
        <pre><a href="#method_propertiesStringToHash">propertiesStringToHash</a>(string $str)</pre>
<pre> this method converts a properties string into a hash. a properties string
  is a string containing key/value pairs where each pair is separated by a
  newline character and the key/value pair is separated by a equals sign.
  for example, the string:
    test1=test 1 string
    test2=test 2 string
  would result in this method returns the hash:
    array(&#039;test1&#039; =&gt; &#039;test 1 string&#039;, &#039;test2&#039; =&gt; &#039;test 2 string&#039;)
  comments can be delimited using a preceding #
</pre>      </td>
    </tr>
    <tr>
      <td><pre>boolean</pre></td>
      <td>
        <pre><a href="#method_isAlphaNumeric">isAlphaNumeric</a>(string $str)</pre>
<pre> returns TRUE if $str is an alphanumeric string
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public string</pre></td>
      <td>
        <pre><a href="#method_trimLeadingZeros">trimLeadingZeros</a>(string $str)</pre>
<pre> trims any leading zeros from $str. if $str consists of only 0s, 0 will be
  returned
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public string</pre></td>
      <td>
        <pre><a href="#method_trimTrailingZeros">trimTrailingZeros</a>(string $str)</pre>
<pre> trims any trailing zeros from $str. if $str consists of only 0s, 0 will be
  returned
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public mixed</pre></td>
      <td>
        <pre><a href="#method_normalizeDataUnit">normalizeDataUnit</a>(mixed $data, int $unit=NULL, mixed $suffix=1, int $decimals=2, boolean $base2=FALSE)</pre>
<pre> this method is used to normalize a data unit. normalization involves first
  determining the unit size by parsing $data for a standard unit symbol or
  name and then applying the correct multiplier to convert the numeric value
  in $data to the new $unit of measure. return return value will either be
  the numeric representation of $data in $unit or the numeric value followed
  by the specified $suffix (if $suffix is specified). if $data cannot be
  parsed its numeric value will be returned. the following unit labels are
  recognized ($data can be parsed with or without spaces between the numeric
  value and the unit label) - note labels are case sensative except for the
  non abbreviated value (i.e. both &#039;bit&#039; and &#039;BIT&#039; are recognized):
    UNIT      LABELS
    bit:      b bs bS bps bpS b/s b/S bit bit/s
    byte:     B Bs BS Bps BpS B/s B/S byte byte/s
    kilobit:  Kb kb Kbs kbs KbS kbS Kbps KbpS kbps kbpS Kb/s Kb/S kb/s kb/S kilobit[s] kbit[s] kbit/s kilobit/s kilo bit[s]
    kilobyte: KB kB KBs kBs KBS kBS KBps KBpS kBps kBpS KB/s KB/S kB/s kB/S kilobyte[s] kbyte[s] kbyte/s kilobyte/s kilo byte[s]
    megabit:  Mb mb Mbs mbs MbS mbS Mbps MbpS mbps mbpS Mb/s Mb/S mb/s mb/S megabit[s] mbit[s] mbit/s megabit/s mega bit[s]
    megabyte: MB mB MBs mBs MBS mBS MBps MBpS mBps mBpS MB/s MB/S mB/s mB/S megabyte[s] mbyte[s] mbyte/s megabyte/s mega byte[s]
    gigabit:  Gb gb Gbs gbs GbS gbS Gbps GbpS gbps gbpS Gb/s Gb/S gb/s gb/S gigabit[s] gbit[s] gbit/s gigabit/s giga bit[s]
    gigabyte: GB gB GBs gBs GBS gBS GBps GBpS gBps gBpS GB/s GB/S gB/s gB/S gigabyte[s] gbyte[s] gbyte/s gigabyte/s giga byte[s]
    terabit:  Tb tb Tbs tbs TbS tbS Tbps TbpS tbps tbpS Tb/s Tb/S tb/s tb/S terabit[s] tbit[s] tbit/s terabit/s tera bit[s]
    terabyte: TB tB TBs tBs TBS tBS TBps TBpS tBps tBpS TB/s TB/S tB/s tB/S terabyte[s] tbyte[s] tbyte/s terabyte/s tera byte[s]
  NOTE: this method is not localized - it interprets and outputs only english
  strings
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public mixed</pre></td>
      <td>
        <pre><a href="#method_normalizeMeasurement">normalizeMeasurement</a>(mixed $data, int $unit=NULL, mixed $suffix=1, int $decimals=2, <a href="util.l10n.SRA_Locale.html" target="contentFrame">SRA_Locale</a> $locale=NULL)</pre>
<pre> this method is used to normalize a measurement. normalization involves first
  determining the unit size by parsing $data for a standard unit symbol or
  name and then applying the correct multiplier to convert the numeric value
  in $data to the new $unit of measure. return return value will either be
  the numeric representation of $data in $unit or the numeric value followed
  by the specified $suffix (if $suffix is specified). if $data cannot be
  parsed its numeric value will be returned. the following unit labels are
  recognized ($data can be parsed with or without spaces between the numeric
  value and the unit label) - labels are not case sensitive. conversion cannot
  occur between classes of measurement for obvious reasons.
    UNIT        METRIC? LABELS
    LENGTH MEASUREMENTS
    Centimeter: Y       centimeter(s) cm cms
    Foot:       N       foot feet ft fts
    Inch:       N       inch(es) in ins
    Kilometer:  Y       kilometer(s) km kms
    Meter:      Y       meter(s) m ms
    Mile:       N       mile(s) mi mis
    Yard:       N       yard(s) yd yds
 
    WEIGHT MEASUREMENTS
    Gram:       Y       gram(s) gm gms
    Kilogram:   Y       kilogram(s) kg kgs
    Ounce:      N       ounce(s) oz ozs
    Pound:      N       pound(s) lb lbs
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public mixed</pre></td>
      <td>
        <pre>&amp;<a href="#method_parsePhpSource">parsePhpSource</a>(string $file, boolean $cache=TRUE)</pre>
<pre> this method parses a PHP 4.x source file and utilizes javadoc formatted
  comments to construct a hash of metadata pertaining to that file. this hash
  will contain the following keys (comment values can be imbedded using the
  localizeable format &quot;[app resource bundle string]&quot;):
    constants:     array of hashes (indexed by name) with the following keys:
      comment:     the constant comment
      name:        the name of the constant
      value:       the constant value
      [other]:     other metadata (metadata value keys are prefixed with @)
    classes:       array of hashes (indexed by name) with the following keys:
      comment:     the class comment
      extends:     the name of another class extended by this class
      name:        the class name
      [other]:     other metadata (metadata value keys are prefixed with @)
      attrs:       array of hashes (indexed by name) with the following keys:
        comment:   the attribute comment
        name:      the name of the attribute
        value:     the attribute value
        [other]:   other metadata (metadata value keys are prefixed with @)
      methods:     array of hashes (indexed by name) with the following keys:
        comment:   the method comment
        name:      the name of the method
        params:    array of hashes (indexed by name) with the following keys:
          byRef:   whether or not this parameter is passed by reference
          comment: the parameter comment
          name:    the name of the parameter
          type:    the parameter data type
          value:   the default parameter value (if applicable)
        returnRef: whether or not this method returns value by reference
        [other]:   other metadata (metadata value keys are prefixed with @)
     functions:    same as &#039;methods&#039; documented above, but for non-class
                   defined functions
</pre>      </td>
    </tr>
    <tr>
      <td><pre>mixed</pre></td>
      <td>
        <pre><a href="#method_parseDtd">parseDtd</a>(string $file, boolean $cache=TRUE)</pre>
<pre> used to parse a DTD. the return value will be a hash with the following
  values:
    comment:      any comments provided for the DTD
    entities:     a hash of DTD entities indexed by entity name with the
                  following sub-keys:
      name:       the entity name
      value:      the entity value
      comment:    the entity comment
    elements:     a hash of DTD elements indexed by element name with the
                  following sub-keys:
      name:       the element name
      comment:    the element comment
      elements:   an array of sub-elements where the value contains the
                  following sub-keys:
        name:     the sub-element name
        set:      if the sub-element is a choice of different sub-elements,
                  this sub-key will be populated instead of &#039;name&#039; which is
                  an array of the names of possible sub-elements
        required: whether or not this sub-element is required
        many:     whether or not many of these sub-elements may exist (if
                  FALSE, only 1 sub-element of this type may exist)
      mixed:      TRUE if the sub-elements are mixed (* modified) - meaning
                  this element may contain zero or more occurrences of them
      attributes: an array of attributes that this element may contain
                  indexed by attribute name where each attribute may have the
                  following sub-keys:
        name:     the attribute name
        comment:  the attribute comment
        options:  if this attribute can be one of a set of options, this
                  attribute will be an array representing those options
        type:     the attribute type, either CDATA, PCDATA, ID, IDREF,
                  &#039;options&#039; (if &#039;options&#039; is set), or an entity name
        default:  the  default value
        required: whether or not this attribute is required
      used:       an array of names of other elements where this element is
                  used (not specified for the root element)
    root:         the name of the root element
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public mixed</pre></td>
      <td>
        <pre><a href="#method_validateStaticMethodPath">validateStaticMethodPath</a>(string $path, boolean $returnFilePath=FALSE)</pre>
<pre> used to validate a static method path which is a class path followed by two
  colons and the method name. to do so, this method includes the class file
  and verifies that the method exists in the class. returns TRUE if the path
  is valid, FALSE otherwise. Here are some examples of static method paths:
    &#039;users/User::validateEmail&#039; - looks for class in
                                    [app]/lib/users/User.php and method
                                    &#039;validateEmail&#039; in that class
  NOTE: the .php extension is not needed
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public mixed</pre></td>
      <td>
        <pre>&amp;<a href="#method_invokeStaticMethodPath">invokeStaticMethodPath</a>(string $path, array $params)</pre>
<pre> invokes a static method using a static method path (see
  &#039;validateStaticMethodPath&#039; above) and returns the results of invoking that
  method. returns NULL if the method is not valid
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public hash</pre></td>
      <td>
        <pre><a href="#method_getStaticMethodPathApi">getStaticMethodPathApi</a>(string $path)</pre>
<pre> returns the api (if $path is properly documented) for the class and method
  defined by $path. this is a hash with the same keys as defined for methods
  in SRA_Util::parsePhpSource. returns NULL if unsuccessful
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public boolean</pre></td>
      <td>
        <pre><a href="#method_ping">ping</a>(string $host)</pre>
<pre> pings $host and returns TRUE if it is reachable, FALSE otherwise
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public int</pre></td>
      <td>
        <pre><a href="#method_fork">fork</a>(string $cmd)</pre>
<pre> executes a command as a new process. this command will fork off the current
  php process and thus will not stall execution. returns the PID of the
  forked command if successful
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public string</pre></td>
      <td>
        <pre><a href="#method_getServiceName">getServiceName</a>(int $port, string $proto='tcp')</pre>
<pre> uses the /etc/services file to attempt to determine the name of the service
  for a given port
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public int</pre></td>
      <td>
        <pre><a href="#method_getServicePort">getServicePort</a>(string $service)</pre>
<pre> uses the /etc/services file to attempt to determine the port used by
  $services
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public boolean</pre></td>
      <td>
        <pre><a href="#method_isPrivateNetworkIp">isPrivateNetworkIp</a>(string $ip)</pre>
<pre> returns TRUE if $ip is on a private IPv4 network (10.0.0.0-10.255.255.255
  OR 172.16.0.0-172.31.255.255 OR 192.168.0.0-192.168.255.255)
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public boolean</pre></td>
      <td>
        <pre><a href="#method_createThumbnail">createThumbnail</a>(string $src, int $theight, int $twidth, string $thumb)</pre>
<pre> creates a thumbnail image using the php gd image manipulation functions.
  returns TRUE on success, FALSE otherwise. the proportional dimensions of
  the image will be maintained, so the thumbnail image will have either
  height=$height OR width=$width but not both and neither height nor width in
  the thumbnail will exceed the $height and $width specified. this method
  uses ImageMagick if it is installed, php-gd otherwise
</pre>      </td>
    </tr>
    <tr>
      <td><pre>string</pre></td>
      <td>
        <pre><a href="#method_stem">stem</a>(string $word)</pre>
<pre> PHP implementation of the Porter Stemming Algorithm written by Iain Argent
  for Complinet Ltd., 17/2/00. Translated from the PERL version at
  http://www.muscat.com/~martin/p.txt. Version 1.1 (Includes British English
  endings). Reduces words to their base stem for search engines and indexing
  this code was borrowed from http://www.weberdev.com/get_example-1503.html
</pre>      </td>
    </tr>
    <tr>
      <td><pre>hash</pre></td>
      <td>
        <pre><a href="#method_parseUri">parseUri</a>(string $uri)</pre>
<pre> parses a URI and return the pieces as a hash containing the following
  possible keys (values not present in the URI will not in the hash):
    user: username
    pswd: password
    protocol: protocol (i.e. http, https, ftp) - always lowercase
    host: hostname or IP - always lowercase
    port: port
    path: url path
    params: hash of URI parameters
  this method is not case sensitive. for example, the $uri
  &quot;Https://test:mypass@test.com:32/test/script?hello=world&amp;hi=yes&quot; would result in the
  following hash being returned:
    user =&gt; test
    pswd =&gt; mypass
    protocol =&gt; https
    host =&gt; test.com
    port =&gt; 32
    path =&gt; /test/script
    params =&gt; (hash)
      hello =&gt; world
      hi =&gt; yes
</pre>      </td>
    </tr>
    <tr>
      <td><pre>hash</pre></td>
      <td>
        <pre><a href="#method_objToHash">objToHash</a>(object $obj)</pre>
<pre> converts an object to a hash recursively using get_object_vars
</pre>      </td>
    </tr>
    <tr>
      <td><pre>boolean</pre></td>
      <td>
        <pre><a href="#method_mxlookup">mxlookup</a>(string $domain, string $dns, int $timeout=2)</pre>
<pre> may be used to lookup MX DNS records. the return value will be an array of
  hashes each with the following keys
</pre>      </td>
    </tr>
    <tr>
      <td><pre>boolean</pre></td>
      <td>
        <pre><a href="#method_portInUse">portInUse</a>(int $port, string $host='localhost', int $timeout=1)</pre>
<pre> checks if port is already in use by attempting to make a tcp socket
  connection
</pre>      </td>
    </tr>
  </table>

  <h2 id="constant_details">Constant Details</h2>
  <a href="#top" style="float:right">Top</a>
  <h3 id="constant_SRA_UTIL_IP_REGEX">SRA_UTIL_IP_REGEX</h3>
  <pre>string <b>SRA_UTIL_IP_REGEX</b> = '/\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b/'</pre>
  <pre> regular expression used to locate an ip address
</pre>
 <hr />  <h3 id="constant_SRA_UTIL_ASPELL">SRA_UTIL_ASPELL</h3>
  <pre>string <b>SRA_UTIL_ASPELL</b> = 'aspell'</pre>
  <pre> the name of the aspell cli utility used by the getSpellCheckLanguages and
  spellcheck methods. aspell must be installed and present in the $PATH in
  order to use those methods
</pre>
 <hr />  <h3 id="constant_SRA_UTIL_DATA_UNIT_BIT">SRA_UTIL_DATA_UNIT_BIT</h3>
  <pre>string <b>SRA_UTIL_DATA_UNIT_BIT</b> = 'b'</pre>
  <pre> unit identifiers for a &#039;bit&#039;, this is the smallest unit size. the
  SRA_UTIL_DATA_UNIT_* constants are used by the SRA_Util::normalizeDataUnit
  method below
</pre>
 <hr />  <h3 id="constant_SRA_UTIL_DATA_UNIT_BYTE">SRA_UTIL_DATA_UNIT_BYTE</h3>
  <pre>string <b>SRA_UTIL_DATA_UNIT_BYTE</b> = 'B'</pre>
  <pre> unit identifiers for a &#039;byte&#039;
</pre>
 <hr />  <h3 id="constant_SRA_UTIL_DATA_UNIT_KILOBIT">SRA_UTIL_DATA_UNIT_KILOBIT</h3>
  <pre>string <b>SRA_UTIL_DATA_UNIT_KILOBIT</b> = 'Kb'</pre>
  <pre> unit identifiers for a &#039;kilobit&#039;
</pre>
 <hr />  <h3 id="constant_SRA_UTIL_DATA_UNIT_KILOBYTE">SRA_UTIL_DATA_UNIT_KILOBYTE</h3>
  <pre>string <b>SRA_UTIL_DATA_UNIT_KILOBYTE</b> = 'KB'</pre>
  <pre> unit identifiers for a &#039;kilobyte&#039;
</pre>
 <hr />  <h3 id="constant_SRA_UTIL_DATA_UNIT_MEGABIT">SRA_UTIL_DATA_UNIT_MEGABIT</h3>
  <pre>string <b>SRA_UTIL_DATA_UNIT_MEGABIT</b> = 'Mb'</pre>
  <pre> unit identifiers for a &#039;megabit&#039;
</pre>
 <hr />  <h3 id="constant_SRA_UTIL_DATA_UNIT_MEGABYTE">SRA_UTIL_DATA_UNIT_MEGABYTE</h3>
  <pre>string <b>SRA_UTIL_DATA_UNIT_MEGABYTE</b> = 'MB'</pre>
  <pre> unit identifiers for a &#039;megabyte&#039;
</pre>
 <hr />  <h3 id="constant_SRA_UTIL_DATA_UNIT_GIGABIT">SRA_UTIL_DATA_UNIT_GIGABIT</h3>
  <pre>string <b>SRA_UTIL_DATA_UNIT_GIGABIT</b> = 'Gb'</pre>
  <pre> unit identifiers for a &#039;gigabit&#039;
</pre>
 <hr />  <h3 id="constant_SRA_UTIL_DATA_UNIT_GIGABYTE">SRA_UTIL_DATA_UNIT_GIGABYTE</h3>
  <pre>string <b>SRA_UTIL_DATA_UNIT_GIGABYTE</b> = 'GB'</pre>
  <pre> unit identifiers for a &#039;gigabyte&#039;
</pre>
 <hr />  <h3 id="constant_SRA_UTIL_DATA_UNIT_TERABIT">SRA_UTIL_DATA_UNIT_TERABIT</h3>
  <pre>string <b>SRA_UTIL_DATA_UNIT_TERABIT</b> = 'Tb'</pre>
  <pre> unit identifiers for a &#039;terabit&#039;
</pre>
 <hr />  <h3 id="constant_SRA_UTIL_DATA_UNIT_TERABYTE">SRA_UTIL_DATA_UNIT_TERABYTE</h3>
  <pre>string <b>SRA_UTIL_DATA_UNIT_TERABYTE</b> = 'TB'</pre>
  <pre> unit identifiers for a &#039;terabyte&#039;
</pre>
 <hr />  <h3 id="constant_SRA_UTIL_DATA_UNIT_BIT_LABELS">SRA_UTIL_DATA_UNIT_BIT_LABELS</h3>
  <pre>string <b>SRA_UTIL_DATA_UNIT_BIT_LABELS</b> = 'b,b/s,:bit,:bit/s,,bs,,bS,,bps,bpS,,,b/S,,,,,,,:bits,:bits/s,'</pre>
  <pre> space separated list of unit labels used to identify a bit. if a label is
  prefixed with : the search for it will not be case sensitive
</pre>
 <hr />  <h3 id="constant_SRA_UTIL_DATA_UNIT_BYTE_LABELS">SRA_UTIL_DATA_UNIT_BYTE_LABELS</h3>
  <pre>string <b>SRA_UTIL_DATA_UNIT_BYTE_LABELS</b> = 'B,B/s,:byte,:byte/s,,Bs,,BS,,Bps,BpS,,,B/S,,,,,,,:bytes,:bytes/s,'</pre>
  <pre> space separated list of unit labels used to identify a byte
</pre>
 <hr />  <h3 id="constant_SRA_UTIL_DATA_UNIT_KILOBIT_LABELS">SRA_UTIL_DATA_UNIT_KILOBIT_LABELS</h3>
  <pre>string <b>SRA_UTIL_DATA_UNIT_KILOBIT_LABELS</b> = 'Kb,Kb/s,:kilobit,:kilobit/s,kb,Kbs,kbs,KbS,kbS,Kbps,KbpS,kbps,kbpS,Kb/S,kb/s,kb/S,:kbit,:kbits,:kbit/s,:kilo bit,:kilobits,:kilobits/s,:kilo bits'</pre>
  <pre> space separated list of unit labels used to identify a kilobit
</pre>
 <hr />  <h3 id="constant_SRA_UTIL_DATA_UNIT_KILOBYTE_LABELS">SRA_UTIL_DATA_UNIT_KILOBYTE_LABELS</h3>
  <pre>string <b>SRA_UTIL_DATA_UNIT_KILOBYTE_LABELS</b> = 'KB,KB/s,:kilobyte,:kilobyte/s,kB,KBs,kBs,KBS,kBS,KBps,KBpS,kBps,kBpS,KB/S,kB/s,kB/S,:kbyte,:kbytes,:kbyte/s,:kilo byte,:kilobytes,:kilobytes/s,:kilo bytes'</pre>
  <pre> space separated list of unit labels used to identify a kilobyte
</pre>
 <hr />  <h3 id="constant_SRA_UTIL_DATA_UNIT_MEGABIT_LABELS">SRA_UTIL_DATA_UNIT_MEGABIT_LABELS</h3>
  <pre>string <b>SRA_UTIL_DATA_UNIT_MEGABIT_LABELS</b> = 'Mb,Mb/s,:megabit,:megabit/s,mb,Mbs,mbs,MbS,mbS,Mbps,MbpS,mbps,mbpS,Mb/S,mb/s,mb/S,:mbit,:mbits,:mbit/s,:mega bit,:megabits,:megabits/s,:mega bits'</pre>
  <pre> space separated list of unit labels used to identify a megabit
</pre>
 <hr />  <h3 id="constant_SRA_UTIL_DATA_UNIT_MEGABYTE_LABELS">SRA_UTIL_DATA_UNIT_MEGABYTE_LABELS</h3>
  <pre>string <b>SRA_UTIL_DATA_UNIT_MEGABYTE_LABELS</b> = 'MB,MB/s,megabyte,megabyte/s,mB,MBs,mBs,MBS,mBS,MBps,MBpS,mBps,mBpS,MB/S,mB/s,mB/S,:mbyte,:mbytes,:mbyte/s,:mega byte,megabytes,megabytes/s,:mega bytes'</pre>
  <pre> space separated list of unit labels used to identify a megabyte
</pre>
 <hr />  <h3 id="constant_SRA_UTIL_DATA_UNIT_GIGABIT_LABELS">SRA_UTIL_DATA_UNIT_GIGABIT_LABELS</h3>
  <pre>string <b>SRA_UTIL_DATA_UNIT_GIGABIT_LABELS</b> = 'Gb,Gb/s,:gigabit,:gigabit/s,gb,Gbs,gbs,GbS,gbS,Gbps,GbpS,gbps,gbpS,Gb/S,gb/s,gb/S,:gbit,:gbits,:gbit/s,:giga bit,:gigabits,:gigabits/s,:giga bits'</pre>
  <pre> space separated list of unit labels used to identify a gigabit
</pre>
 <hr />  <h3 id="constant_SRA_UTIL_DATA_UNIT_GIGABYTE_LABELS">SRA_UTIL_DATA_UNIT_GIGABYTE_LABELS</h3>
  <pre>string <b>SRA_UTIL_DATA_UNIT_GIGABYTE_LABELS</b> = 'GB,GB/s,:gigabyte,:gigabyte/s,gB,GBs,gBs,GBS,gBS,GBps,GBpS,gBps,gBpS,GB/S,gB/s,gB/S,:gbyte,:gbytes,:gbyte/s,:giga byte,:gigabytes,:gigabytes/s,:giga bytes'</pre>
  <pre> space separated list of unit labels used to identify a gigabyte
</pre>
 <hr />  <h3 id="constant_SRA_UTIL_DATA_UNIT_TERABIT_LABELS">SRA_UTIL_DATA_UNIT_TERABIT_LABELS</h3>
  <pre>string <b>SRA_UTIL_DATA_UNIT_TERABIT_LABELS</b> = 'Tb,Tb/s,:terabit,:terabit/s,tb,Tbs,tbs,TbS,tbS,Tbps,TbpS,tbps,tbpS,Tb/S,tb/s,tb/S,:tbit,:tbits,:tbit/s,:tera bit,:terabits,:terabits/s,:tera bits'</pre>
  <pre> space separated list of unit labels used to identify a terabit
</pre>
 <hr />  <h3 id="constant_SRA_UTIL_DATA_UNIT_TERABYTE_LABELS">SRA_UTIL_DATA_UNIT_TERABYTE_LABELS</h3>
  <pre>string <b>SRA_UTIL_DATA_UNIT_TERABYTE_LABELS</b> = 'TB,TB/s,:terabyte,:terabyte/s,tB,TBs,tBs,TBS,tBS,TBps,TBpS,tBps,tBpS,TB/S,tB/s,tB/S,:tbyte,:tbytes,:tbyte/s,:tera byte,:terabytes,:terabytes/s,:tera bytes'</pre>
  <pre> space separated list of unit labels used to identify a terabyte
</pre>
 <hr />  <h3 id="constant_SRA_UTIL_MEASUREMENT_CENTIMETER">SRA_UTIL_MEASUREMENT_CENTIMETER</h3>
  <pre>string <b>SRA_UTIL_MEASUREMENT_CENTIMETER</b> = 'cm'</pre>
  <pre> measurement identifiers for a &#039;centimeter&#039;
</pre>
 <hr />  <h3 id="constant_SRA_UTIL_MEASUREMENT_FOOT">SRA_UTIL_MEASUREMENT_FOOT</h3>
  <pre>string <b>SRA_UTIL_MEASUREMENT_FOOT</b> = 'ft'</pre>
  <pre> measurement identifiers for a &#039;foot&#039;
</pre>
 <hr />  <h3 id="constant_SRA_UTIL_MEASUREMENT_INCH">SRA_UTIL_MEASUREMENT_INCH</h3>
  <pre>string <b>SRA_UTIL_MEASUREMENT_INCH</b> = 'in'</pre>
  <pre> measurement identifiers for an &#039;inch&#039;
</pre>
 <hr />  <h3 id="constant_SRA_UTIL_MEASUREMENT_KILOMETER">SRA_UTIL_MEASUREMENT_KILOMETER</h3>
  <pre>string <b>SRA_UTIL_MEASUREMENT_KILOMETER</b> = 'km'</pre>
  <pre> measurement identifiers for a &#039;kilometer&#039;
</pre>
 <hr />  <h3 id="constant_SRA_UTIL_MEASUREMENT_METER">SRA_UTIL_MEASUREMENT_METER</h3>
  <pre>string <b>SRA_UTIL_MEASUREMENT_METER</b> = 'm'</pre>
  <pre> measurement identifiers for a &#039;meter&#039;
</pre>
 <hr />  <h3 id="constant_SRA_UTIL_MEASUREMENT_MILE">SRA_UTIL_MEASUREMENT_MILE</h3>
  <pre>string <b>SRA_UTIL_MEASUREMENT_MILE</b> = 'mi'</pre>
  <pre> measurement identifiers for a &#039;mile&#039;
</pre>
 <hr />  <h3 id="constant_SRA_UTIL_MEASUREMENT_YARD">SRA_UTIL_MEASUREMENT_YARD</h3>
  <pre>string <b>SRA_UTIL_MEASUREMENT_YARD</b> = 'yd'</pre>
  <pre> measurement identifiers for a &#039;yard&#039;
</pre>
 <hr />  <h3 id="constant_SRA_UTIL_MEASUREMENT_GRAM">SRA_UTIL_MEASUREMENT_GRAM</h3>
  <pre>string <b>SRA_UTIL_MEASUREMENT_GRAM</b> = 'gm'</pre>
  <pre> measurement identifiers for a &#039;gram&#039;
</pre>
 <hr />  <h3 id="constant_SRA_UTIL_MEASUREMENT_KILOGRAM">SRA_UTIL_MEASUREMENT_KILOGRAM</h3>
  <pre>string <b>SRA_UTIL_MEASUREMENT_KILOGRAM</b> = 'kg'</pre>
  <pre> measurement identifiers for a &#039;kilogram&#039;
</pre>
 <hr />  <h3 id="constant_SRA_UTIL_MEASUREMENT_OUNCE">SRA_UTIL_MEASUREMENT_OUNCE</h3>
  <pre>string <b>SRA_UTIL_MEASUREMENT_OUNCE</b> = 'oz'</pre>
  <pre> measurement identifiers for an &#039;ounce&#039;
</pre>
 <hr />  <h3 id="constant_SRA_UTIL_MEASUREMENT_POUND">SRA_UTIL_MEASUREMENT_POUND</h3>
  <pre>string <b>SRA_UTIL_MEASUREMENT_POUND</b> = 'lb'</pre>
  <pre> measurement identifiers for a &#039;pound&#039;
</pre>
 <hr />  <h3 id="constant_SRA_UTIL_ROOT">SRA_UTIL_ROOT</h3>
  <pre>string <b>SRA_UTIL_ROOT</b> = 'root'</pre>
  <pre> the root username
</pre>
 <hr />  <h3 id="constant_SRA_UTIL_SERVICES_CONFIG">SRA_UTIL_SERVICES_CONFIG</h3>
  <pre>string <b>SRA_UTIL_SERVICES_CONFIG</b> = '/etc/services'</pre>
  <pre> path to the services config file used by SRA_Util::getServiceName($port)
</pre>
 <hr />  <h3 id="constant_SRA_UTIL_SU_CMDS_INVALID_PSWD">SRA_UTIL_SU_CMDS_INVALID_PSWD</h3>
  <pre>string <b>SRA_UTIL_SU_CMDS_INVALID_PSWD</b> = 'incorrect password'</pre>
  <pre> string token that identifies an invalid password in SRA_Util::suCmds
</pre>
 <hr />  <h3 id="constant_SRA_UTIL_SU_CMDS_INVALID_USER">SRA_UTIL_SU_CMDS_INVALID_USER</h3>
  <pre>string <b>SRA_UTIL_SU_CMDS_INVALID_USER</b> = 'not exist'</pre>
  <pre> string token that identifies an invalid user in SRA_Util::suCmds
</pre>
 <hr />  <h3 id="constant_SRA_UTIL_SU_CMDS_SCRIPT">SRA_UTIL_SU_CMDS_SCRIPT</h3>
  <pre>string <b>SRA_UTIL_SU_CMDS_SCRIPT</b> = '.su-cmds'</pre>
  <pre> the name of the temporary script created by SRA_Util::suCmds
</pre>
 <hr />  <h3 id="constant_SRA_UTIL_SU_PASSWORD">SRA_UTIL_SU_PASSWORD</h3>
  <pre>string <b>SRA_UTIL_SU_PASSWORD</b> = '"assword:"'</pre>
  <pre> string token that identifies the password prompt in SRA_Util::suCmds and
  SRA_Util::suPswd
</pre>
 <hr />  <h3 id="constant_SRA_UTIL_SU_PSWD_BAD">SRA_UTIL_SU_PSWD_BAD</h3>
  <pre>string <b>SRA_UTIL_SU_PSWD_BAD</b> = 'BAD'</pre>
  <pre> string token that identifies an bad password in SRA_Util::suPswd
</pre>
 <hr />  <h3 id="constant_SRA_UTIL_SU_PSWD_RETYPE">SRA_UTIL_SU_PSWD_RETYPE</h3>
  <pre>string <b>SRA_UTIL_SU_PSWD_RETYPE</b> = 'etype'</pre>
  <pre> string token that identifies the retype password command in SRA_Util::suPswd
</pre>
 <hr />  <h3 id="constant_SRA_UTIL_USE_APP_CONFIG_DEBUG">SRA_UTIL_USE_APP_CONFIG_DEBUG</h3>
  <pre>int <b>SRA_UTIL_USE_APP_CONFIG_DEBUG</b> = -1</pre>
  <pre> The value to use in the printDebug method to identify that the app debug flag should be used
</pre>
 <hr />  <h3 id="constant_SRA_UTIL_USE_SYS_CONFIG_DEBUG">SRA_UTIL_USE_SYS_CONFIG_DEBUG</h3>
  <pre>int <b>SRA_UTIL_USE_SYS_CONFIG_DEBUG</b> = -2</pre>
  <pre> The value to use in the printDebug method to identify that the system debug flag should be used
</pre>
 <hr />  <h3 id="constant_SRA_UTIL_URL_SAFE_REGEX">SRA_UTIL_URL_SAFE_REGEX</h3>
  <pre>string <b>SRA_UTIL_URL_SAFE_REGEX</b> = '|[^\w-_\.]|'</pre>
  <pre> regular expression used to strip out non-url-safe characters
</pre>


  <h2 id="method_details">Method Details</h2>
  <a href="#top" style="float:right">Top</a>
  <h3 id="method_addDelimString">addDelimString</h3>
  <pre>public static String function <b>addDelimString</b>($string, $delim=", $", $quote='"')</pre>
  <pre> This method is used add or imbed a delimeter string. For example, if parsing a csv file you
  would want to use this method to convert commas in between quotes to a delim string that
  could later be converted back to a comma. This method would perform that function.
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>string</td>
      <td>Not Specified</td>
      <td><pre>- The String to add the delimeter string to</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>delim</td>
      <td>Not Specified</td>
      <td><pre>- The delimeter to imbed a delimeter string for (by default a comma).</pre></td>
      <td>"</td>
      <td>No</td>
    </tr>
    <tr>
      <td>"</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>quote</td>
      <td>Not Specified</td>
      <td><pre>- The quote for the string (only delims between this will be replaced).  					The default is a double quote.</pre></td>
      <td>'"'</td>
      <td>No</td>
    </tr>
  </table>
  <p>author = Jason Read <jason@idir.org></p>
 <hr />  <h3 id="method_addSqlOption">addSqlOption</h3>
  <pre>public static String function <b>addSqlOption</b>($sql, $option)</pre>
  <pre> This static method adds an option to a sql statement. It uses the WHERE clause if no options
  exist in the sql statement. Otherwise it uses the AND clause.
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>sql</td>
      <td>Not Specified</td>
      <td><pre>- The sql statement to add the option to.</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>option</td>
      <td>Not Specified</td>
      <td><pre>- The option to add to the sql statement.</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
  <p>author = Jason Read <jason@idir.org></p>
 <hr />  <h3 id="method_applyLimitOffset">applyLimitOffset</h3>
  <pre>public static array function &amp;<b>applyLimitOffset</b>(array $arr, int $limit, int $offset, boolean $preserveKeys=FALSE)</pre>
  <pre> used to apply limit and offset contraints to an array. returns a new
  array with those constraints applied
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>arr</td>
      <td>array</td>
      <td><pre>ay $arr the array to apply the limit/offset to</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>limit</td>
      <td>int</td>
      <td><pre>the limit (if none, no limit will be applied)</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>offset</td>
      <td>int</td>
      <td><pre>the offset (if none, no offset will be applied)</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>preserveKeys</td>
      <td>boolean</td>
      <td><pre>whether or not to preserve the keys in $arr</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_arrayMerge">arrayMerge</h3>
  <pre>public static String[] function &amp;<b>arrayMerge</b>($master, $merge, $overwriteExisting=true)</pre>
  <pre> This method merges two arrays based on the parameters specified.
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>master</td>
      <td>Not Specified</td>
      <td><pre>: String[] - The master array to merge from. This will be a key based array.</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>merge</td>
      <td>Not Specified</td>
      <td><pre>: String[] - The merge array. This will also be a key based array. At the end of the method  			all of the key based values in the master array will exist in this array.</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>overwriteExisting</td>
      <td>Not Specified</td>
      <td><pre>: boolean - Optional parameter that specifies whether or not existing values should  			be overwritten if then exist already in the merge array. The default value for this is true.</pre></td>
      <td>true</td>
      <td>No</td>
    </tr>
  </table>
  <p>author = Jason Read <jason@idir.org></p>
 <hr />  <h3 id="method_arrayToCsv">arrayToCsv</h3>
  <pre>public static String function &amp;<b>arrayToCsv</b>($report, $useQuotes=true)</pre>
  <pre> This method converts an array of arrays of strings to a csv formatted string. Each row in
  the array will be separated by a line break &quot;\n&quot; and each column will be separated by a
  comma and surrounded by double quotes (if the useQuotes parameter is true).
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>report</td>
      <td>Not Specified</td>
      <td><pre>: String[][] - An array of string arrays. Each array in the first array will  be considered a row and each element in the second arrays will be considered a column.</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>useQuotes</td>
      <td>Not Specified</td>
      <td><pre>: boolean - Whether or not each column should be double quote delimited.</pre></td>
      <td>true</td>
      <td>No</td>
    </tr>
  </table>
  <p>author = Jason Read <jason@idir.org></p>
 <hr />  <h3 id="method_toJson">toJson</h3>
  <pre>public String function <b>toJson</b>(mixed $attr, array $include, array $exclude, boolean $javascriptDate=FALSE)</pre>
  <pre> converts $attr to the appropriate representation in a javascript evaluable
  string. the global variables $_utilDateFormat and $_utilTimeFormat
  may be specified to use an alternate date/time format
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>attr</td>
      <td>mixed</td>
      <td><pre>the attribute to render</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>include</td>
      <td>array</td>
      <td><pre>if $attr is an entity, the attributes to render</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>exclude</td>
      <td>array</td>
      <td><pre>if $attr is an entity, the attributes not to render</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>javascriptDate</td>
      <td>boolean</td>
      <td><pre>whether or not is $attr is a  SRA_GregorianDate object, it should be converted to a javascript Date
  object</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_attrToXml">attrToXml</h3>
  <pre>public string function <b>attrToXml</b>(mixed $attr, array $include, array $exclude, string $fileElementName=NULL, boolean $usePrimaryKey=FALSE, boolean $camelCase=FALSE, string $ikey=NULL)</pre>
  <pre> converts $attr to the appropriate representation in a xml renderable array.
  the global variables $_utilDateFormat and $_utilTimeFormat may be
  specified to use an alternate date/time format
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>attr</td>
      <td>mixed</td>
      <td><pre>the attribute to render</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>include</td>
      <td>array</td>
      <td><pre>if $attr is an entity, the attributes to render</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>exclude</td>
      <td>array</td>
      <td><pre>if $attr is an entity, the attributes not to render</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>fileElementName</td>
      <td>string</td>
      <td><pre>the element name to use for file attributes</pre></td>
      <td>NULL</td>
      <td>No</td>
    </tr>
    <tr>
      <td>usePrimaryKey</td>
      <td>boolean</td>
      <td><pre>whether or not to use primary key to  serialize entities (otherwise the &#039;toXmlArray&#039; method will be used)</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
    <tr>
      <td>camelCase</td>
      <td>boolean</td>
      <td><pre>whether or not to force the xml attributes and  elements to camel case (otherwise, model defined format will be used)</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
    <tr>
      <td>ikey</td>
      <td>string</td>
      <td><pre>optional parameter used internally for recursive calls</pre></td>
      <td>NULL</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_isHash">isHash</h3>
  <pre>public boolean function <b>isHash</b>(array $arr)</pre>
  <pre> returns TRUE if $arr is a hash (array indexes do not start with 0 and
  increment)
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>arr</td>
      <td>array</td>
      <td><pre>ay $arr the array to check</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
  </table>
 <hr />  <h3 id="method_beginsWith">beginsWith</h3>
  <pre>public boolean function <b>beginsWith</b>(string $str, string $substr, boolean $caseSensitive=TRUE)</pre>
  <pre> returns TRUE if the $str specified begins with $substr
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>str</td>
      <td>string</td>
      <td><pre>ing $str the string to chec</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>substr</td>
      <td>string</td>
      <td><pre>the string to check for</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>caseSensitive</td>
      <td>boolean</td>
      <td><pre>whether or not case sensitive</pre></td>
      <td>TRUE</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_endsWith">endsWith</h3>
  <pre>public boolean function <b>endsWith</b>(string $str, string $substr, boolean $caseSensitive=TRUE)</pre>
  <pre> returns TRUE if the $str specified ends with $substr
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>str</td>
      <td>string</td>
      <td><pre>ing $str the string to chec</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>substr</td>
      <td>string</td>
      <td><pre>the string to check for</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>caseSensitive</td>
      <td>boolean</td>
      <td><pre>whether or not case sensitive</pre></td>
      <td>TRUE</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_arrayMoveToTop">arrayMoveToTop</h3>
  <pre>public array function &amp;<b>arrayMoveToTop</b>(array $arr, string $key)</pre>
  <pre> moves the array element $key to the top of the array and returns the new
  array
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>arr</td>
      <td>array</td>
      <td><pre>ay $arr the array</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>key</td>
      <td>string</td>
      <td><pre>the hash key of the element to move</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_bufferArray">bufferArray</h3>
  <pre>public static String function <b>bufferArray</b>($array, $name, $indent=2, $recursive=false)</pre>
  <pre> This method is used to convert an array into text (which may be imported into php at some
  point in the future to become an array). This method supports any number of levels of arrays.
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>array</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>name</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>indent</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>2</td>
      <td>No</td>
    </tr>
    <tr>
      <td>recursive</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>false</td>
      <td>No</td>
    </tr>
  </table>
  <p>author = Jason Read <jason@idir.org></p>
 <hr />  <h3 id="method_camelCaseToDashes">camelCaseToDashes</h3>
  <pre>public String function <b>camelCaseToDashes</b>(string $str, boolean $upper=FALSE)</pre>
  <pre> returns the camel case variable name in a dash format
  e.g. myVariableName would return my-variable-name
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>str</td>
      <td>string</td>
      <td><pre>ing $str the string to convert</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>upper</td>
      <td>boolean</td>
      <td><pre>whether or not the new value should be all uppercase  default is all lowercase</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_camelCaseToUnderscores">camelCaseToUnderscores</h3>
  <pre>public String function <b>camelCaseToUnderscores</b>(string $str, boolean $upper=FALSE)</pre>
  <pre> returns the camel case variable name in an underscore format
  e.g. myVariableName would return my_variable_name
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>str</td>
      <td>string</td>
      <td><pre>ing $str the string to convert</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>upper</td>
      <td>boolean</td>
      <td><pre>whether or not the new value should be all uppercase  default is all lowercase</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_camelCaseConvert">camelCaseConvert</h3>
  <pre>public String function <b>camelCaseConvert</b>(string $str, string $delim, boolean $upper=FALSE)</pre>
  <pre> converts a camel case (ie &#039;myNameIsBob&#039;) value into a fixed case value using
  $delim as the value to place between each camel case occurrence. for
  example, if $delim was &#039;_&#039; the value above would become &#039;my_name_is_bob&#039;
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>str</td>
      <td>string</td>
      <td><pre>ing $str the string to convert</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>delim</td>
      <td>string</td>
      <td><pre>the delimeter to insert between each camel case occurrence</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>upper</td>
      <td>boolean</td>
      <td><pre>whether or not the new value should be all uppercase  default is all lowercase</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_checkBrowserCompatibility">checkBrowserCompatibility</h3>
  <pre>public void function <b>checkBrowserCompatibility</b>($supportedBrowsers, string $errorTpl)</pre>
  <pre> checks for browser compatibility and displays an error page when an
  incompatible browser is encountered. when the php script is being run at
  the command line, the compatibility check will be bypassed
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>supportedBrowsers</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>errorTpl</td>
      <td>string</td>
      <td><pre>the template to display when an incompatible  browser is encountered</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_codeToString">codeToString</h3>
  <pre>void function <b>codeToString</b>($code)</pre>
  <pre> Used function used to forward to SRA_Util:: function (see method api for more
  info)
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>code</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_compareBitMasks">compareBitMasks</h3>
  <pre>public static boolean function <b>compareBitMasks</b>($mask, $compare, $full)</pre>
  <pre> This method compares two bitmasks. It returns true if all of the bits specified in the mask
  parameter are also specified in the compare parameter.
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>mask</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>compare</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>full</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
  <p>author = Jason Read <jason@idir.org></p>
 <hr />  <h3 id="method_isBoolean">isBoolean</h3>
  <pre>public static boolean function <b>isBoolean</b>($bool)</pre>
  <pre> returns TRUE if $bool is a valid representation of the boolean data type
  the following are considered valid representations:
 	 boolean constants TRUE/FALSE
    integers 1/0
 	 strings &#039;1&#039;/&#039;0&#039;
    strings &#039;true&#039;/&#039;false&#039; (not case sensitive)
    strings &#039;t&#039;/&#039;f&#039;
    strings &#039;yes&#039;/&#039;no&#039;
    strings &#039;y&#039;/&#039;n&#039;
    strings &#039;on&#039;/&#039;off&#039;
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>bool</td>
      <td>Not Specified</td>
      <td><pre>- The boolean string to convert</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_convertBoolean">convertBoolean</h3>
  <pre>public static mixed function <b>convertBoolean</b>(mixed $bool, boolean $default=NULL)</pre>
  <pre> returns TRUE if $bool is a valid boolean data type representation of TRUE
  (see isBoolean api documentation for more details on what is considered
  a valid boolean data type representation). returns NULL if $bool is not a
  valid boolean type
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>bool</td>
      <td>mixed</td>
      <td><pre>The boolean string to convert</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>default</td>
      <td>boolean</td>
      <td><pre>the default value to return</pre></td>
      <td>NULL</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_extractArrayValue">extractArrayValue</h3>
  <pre>public static boolean function &amp;<b>extractArrayValue</b>($array, $key, $typeCast=NULL, $returnValue=NULL)</pre>
  <pre> Extracts and returns the value in the array identified by the key parameter.
  Returns the return parameter (default is NULL) is that array key is not set.
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>array</td>
      <td>Not Specified</td>
      <td><pre>: Object[] - The array from which the value should be  			extracted.</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>key</td>
      <td>Not Specified</td>
      <td><pre>: String - The array key identifying the value that should be  			extracted.</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>typeCast</td>
      <td>Not Specified</td>
      <td><pre>: String - A type cast to apply to the value. This parameter is optional. By default no type cast is applied.</pre></td>
      <td>NULL</td>
      <td>No</td>
    </tr>
    <tr>
      <td>returnValue</td>
      <td>Not Specified</td>
      <td><pre>: Object - The value to return if the array key specified  			is not set. This is an optional parameter. The default value is NULL.</pre></td>
      <td>NULL</td>
      <td>No</td>
    </tr>
  </table>
  <p>author = Jason Read <jason@idir.org></p>
 <hr />  <h3 id="method_getArrayLocation">getArrayLocation</h3>
  <pre>public static Object function &amp;<b>getArrayLocation</b>($array, $value, $recursive=false, $arrayKey=NULL)</pre>
  <pre> Returns a reference to a location in an array containing the value specified.
  Returns an OPERATIONAL SRA_Error object if the key is not found.
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>array</td>
      <td>Not Specified</td>
      <td><pre>: Object - The array to search for the value in</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>value</td>
      <td>Not Specified</td>
      <td><pre>: String - The value to search for</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>recursive</td>
      <td>Not Specified</td>
      <td><pre>: boolean - Optional parameter specifying whether or not  the value should be searched for recursively. The default value for this
  parameter is false.</pre></td>
      <td>false</td>
      <td>No</td>
    </tr>
    <tr>
      <td>arrayKey</td>
      <td>Not Specified</td>
      <td><pre>: String - Optional parameter specifying the element key name.  If this parameter is not specified, the array key will be used.</pre></td>
      <td>NULL</td>
      <td>No</td>
    </tr>
  </table>
  <p>author = Jason Read <jason@idir.org></p>
 <hr />  <h3 id="method_getFileExtension">getFileExtension</h3>
  <pre>public static string function <b>getFileExtension</b>(string $fileName, boolean $urlSafe=FALSE)</pre>
  <pre> Returns the file extension for a given file (the string following the
  last .) or empty string if there is not extension
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>fileName</td>
      <td>string</td>
      <td><pre>the file to return the extension of</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>urlSafe</td>
      <td>boolean</td>
      <td><pre>whether or not to make the return value url safe</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_getFileNameWOExtension">getFileNameWOExtension</h3>
  <pre>public static String function <b>getFileNameWOExtension</b>(string $fileName, boolean $urlSafe=FALSE)</pre>
  <pre> Returns the file extension for a given file (the string following the
  last .)
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>fileName</td>
      <td>string</td>
      <td><pre>the file to return the extension of</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>urlSafe</td>
      <td>boolean</td>
      <td><pre>whether or not to make the return value url safe</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_getPhpIniMemoryLimit">getPhpIniMemoryLimit</h3>
  <pre>public static String function <b>getPhpIniMemoryLimit</b>()</pre>
  <pre> This method returns the memory_limit specified in the php.ini file in
  bytes.
 
</pre>
  <p>author = Jason Read <jason@idir.org></p>
 <hr />  <h3 id="method_getPrefixedArrayValues">getPrefixedArrayValues</h3>
  <pre>array function &amp;<b>getPrefixedArrayValues</b>(string $prefix, array $arr, boolean $removePrefix=TRUE)</pre>
  <pre> returns a sub-array containing all of the values in $arr that are
  are prefixed with $prefix
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>prefix</td>
      <td>string</td>
      <td><pre>the prefix value</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>arr</td>
      <td>array</td>
      <td><pre>ay $arr the array to search</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>removePrefix</td>
      <td>boolean</td>
      <td><pre>whether or not to remove $prefix from the  return values. default is TRUE</pre></td>
      <td>TRUE</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_getCurrentUser">getCurrentUser</h3>
  <pre>string function <b>getCurrentUser</b>()</pre>
  <pre> same as the php &#039;get_current_user&#039; function but returns the correct
  username for child processes (the &#039;get_current_user&#039; function returns the
  username for the parent process even if the child process owner is
  different)
</pre>
 <hr />  <h3 id="method_getProcessAttr">getProcessAttr</h3>
  <pre>string function <b>getProcessAttr</b>(string $attr, int $pid=NULL)</pre>
  <pre> returns a process attribute
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>attr</td>
      <td>string</td>
      <td><pre>the attribute to return. some examples of attributes  are: %cpu, %mem, egid, egroup, etime, euid, euser, ppid, args. for more
  information, see the man page for &#039;ps&#039;</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>pid</td>
      <td>int</td>
      <td><pre>the pid of the process. if not specified, the pid of the  current running process will be used</pre></td>
      <td>NULL</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_getProcessHash">getProcessHash</h3>
  <pre>hash function <b>getProcessHash</b>(string $val='command')</pre>
  <pre> returns a hash of the currently running processes where the key is the pid
  and the value is the process command
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>val</td>
      <td>string</td>
      <td><pre>the process value to use as the hash value. the default  value is the process command. alternatively, any of the &quot;ps&quot; output value
  identifiers may be specified</pre></td>
      <td>'command'</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_getProcessId">getProcessId</h3>
  <pre>mixed function <b>getProcessId</b>(string $script, boolean $last=TRUE, mixed $user=NULL, boolean $multiple=FALSE)</pre>
  <pre> this method returns the pid of the $script process. NULL is returned if
  no process currently exists. if $multiple is TRUE, the return value will be
  an array containing all of the matching pids (or NULL if none)
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>script</td>
      <td>string</td>
      <td><pre>the name of the script, either the full path or  just the name</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>last</td>
      <td>boolean</td>
      <td><pre>whether or not the pid of the oldest or most recent  process should be returned if multiple are running</pre></td>
      <td>TRUE</td>
      <td>No</td>
    </tr>
    <tr>
      <td>user</td>
      <td>mixed</td>
      <td><pre>an optional uid or username to limit the search to (only  processes owned by this user will be returned)</pre></td>
      <td>NULL</td>
      <td>No</td>
    </tr>
    <tr>
      <td>multiple</td>
      <td>boolean</td>
      <td><pre>whether or not to return multiple pids if they  exist (return value will be an array)</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_getProcessName">getProcessName</h3>
  <pre>mixed function <b>getProcessName</b>(int $pid)</pre>
  <pre> returns the name of the process identified by $pid. returns NULL if $pid is
  not a valid process. the name of the process is the &quot;command&quot; keyword from
  ps
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>pid</td>
      <td>int</td>
      <td><pre>the id of the process</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_getRelativeNumericVal">getRelativeNumericVal</h3>
  <pre>public static int function <b>getRelativeNumericVal</b>(string $expr)</pre>
  <pre> returns the numeric value for a relative $expr where $expr is in the format
  &quot;+n&quot; and n may be designated as negative by enclosing it in parenthesis
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>expr</td>
      <td>string</td>
      <td><pre>the expression value to return</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_getSpellCheckLanguages">getSpellCheckLanguages</h3>
  <pre>public static array function &amp;<b>getSpellCheckLanguages</b>()</pre>
  <pre> returns the spellcheck languages as an associative array where the key is
  the locale code (see SRA_Locale::getLocale($code...)), and the value is
  the locale label (see SRA_Locale::getLabel()). returns NULL if aspell is
  not available or if the dictionary path cannot be determined or read from
</pre>
 <hr />  <h3 id="method_getDefaultSpellCheckLanguage">getDefaultSpellCheckLanguage</h3>
  <pre>public static String function <b>getDefaultSpellCheckLanguage</b>()</pre>
  <pre> returns the default spell check language code for the current active user
  this is done by first accessing the spellcheck languages using
  SRA_Util::getSpellCheckLanguages() followed by the user&#039;s locales using
  SRA_Controller::getUserLocales(), and then finding the first match in the
  spellcheck languages that exists in the user&#039;s locales. if not match is
  found the first spell check language will be returned. if there are no
  spellcheck languages NULL will be returned
 
</pre>
 <hr />  <h3 id="method_getEnglishOrdinalSuffix">getEnglishOrdinalSuffix</h3>
  <pre>publicstatic String function <b>getEnglishOrdinalSuffix</b>(int $number)</pre>
  <pre> returns the english ordinal suffix for $number (st, nd, rd, or th)
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>number</td>
      <td>int</td>
      <td><pre>the number to return the ordinal suffix for</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_getTextBetween">getTextBetween</h3>
  <pre>public static String function &amp;<b>getTextBetween</b>($startToken, $endToken, $text)</pre>
  <pre> Returns a substring of the text provided that is between the startToken
  and the endToken
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>startToken</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>endToken</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>text</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
  </table>
  <p>author = Jason Read <jason@idir.org></p>
 <hr />  <h3 id="method_htmlToText">htmlToText</h3>
  <pre>public static void function <b>htmlToText</b>($html)</pre>
  <pre> This method is used to convert html to plain text (no html tags)
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>html</td>
      <td>Not Specified</td>
      <td><pre>- 	The html text to convert to text</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
  <p>author = Jason Read <jason@idir.org></p>
 <hr />  <h3 id="method_implodeSkipEmpty">implodeSkipEmpty</h3>
  <pre>public static string function <b>implodeSkipEmpty</b>(string $glue, array $pieces, boolean $lead=FALSE, boolean $trim=TRUE)</pre>
  <pre> same as the php implode function but skips $pieces values that are empty
  (do not evaluate to PHP true)
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>glue</td>
      <td>string</td>
      <td><pre>the string to insert between each value in $pieces</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>pieces</td>
      <td>array</td>
      <td><pre>the array to implode</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>lead</td>
      <td>boolean</td>
      <td><pre>whether or not to lead the return value with $glue  if it is not empty</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
    <tr>
      <td>trim</td>
      <td>boolean</td>
      <td><pre>whether or not to trim the values in $pieces</pre></td>
      <td>TRUE</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_includeAttributeInOutput">includeAttributeInOutput</h3>
  <pre>boolean function <b>includeAttributeInOutput</b>(string $attr, mixed $include, mixed $exclude)</pre>
  <pre> returns TRUE if ($include is an array and $attr is in it or if $include
  is not an array) and ($exclude is an array and $attr is not in it or if
  $exclude is not an array)
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>attr</td>
      <td>string</td>
      <td><pre>the name of the attribute to check</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>include</td>
      <td>mixed</td>
      <td><pre>the include array. may include nested values  for entity type attributes delimited by &#039;_&#039;</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>exclude</td>
      <td>mixed</td>
      <td><pre>the exclude array. may include nested values  for entity type attributes delimited by &#039;_&#039;</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_isProcessActive">isProcessActive</h3>
  <pre>boolean function <b>isProcessActive</b>(int $pid)</pre>
  <pre> returns TRUE if a process identified by $pid is currently active
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>pid</td>
      <td>int</td>
      <td><pre>the id of the process</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_isSubclassOf">isSubclassOf</h3>
  <pre>public static boolean function <b>isSubclassOf</b>($parent, $child)</pre>
  <pre> This method is very simliar to the built in php is_subclass_of function with the
  exception that the object parameter may be either an object or a class name
  (php function requires it to be an object). This method returns true if the
  parent parameter class type is a class that the child parameter extends from.
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>parent</td>
      <td>Not Specified</td>
      <td><pre>: Object - The parent object or class name. This parameter must  be passed as a variable (i.e. &quot;MyClass&quot; wll not work...
  instead use $temp = &quot;MyClass&quot;).</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>child</td>
      <td>Not Specified</td>
      <td><pre>: Object - The child object or class name. This parameter must  be passed as a variable (i.e. &quot;MyClass&quot; wll not work...
  instead use $temp = &quot;MyClass&quot;).</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
  </table>
  <p>author = Jason Read <jason@idir.org></p>
 <hr />  <h3 id="method_killProcess">killProcess</h3>
  <pre>public boolean function <b>killProcess</b>(int $pid)</pre>
  <pre> kills $pid if it is active. returns TRUE on success, FALSE if the kill
  fails, and NULL if $pid is not valid
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>pid</td>
      <td>int</td>
      <td><pre>the process id to kill</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_objToArray">objToArray</h3>
  <pre>public array function &amp;<b>objToArray</b>($obj)</pre>
  <pre> returns the attributes associated with an object as an associative array
  where the array index is the attribute name. all leading underscores are
  removed from the attribute names. only attributes with leading underscores
  are included in the returned array
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>obj</td>
      <td>Not Specified</td>
      <td><pre>: Object - the object to return the array for</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
  </table>
 <hr />  <h3 id="method_parseEmailString">parseEmailString</h3>
  <pre>public array function <b>parseEmailString</b>(string $str)</pre>
  <pre> used to parse an email string and return the corresponding name and email
  values from the string. an email string may be in any of the following
  formats:
    john@doe.com
    &lt;john@doe.com&gt;
    John Doe &lt;john@doe.com&gt;
    &quot;John Doe&quot; &lt;john@doe.com&gt;
  the return value will be a hash with the keys &#039;email&#039; and &#039;name&#039; where
  those values were extracted from the email string provided. name may not
  be present in the return value if it is not part of the email string
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>str</td>
      <td>string</td>
      <td><pre>ing $str the email string to parse</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_printDebug">printDebug</h3>
  <pre>public static void function <b>printDebug</b>($output, $debug=SRA_UTIL_USE_SYS_CONFIG_DEBUG, $file="", $line, $pre=false, $quiet=false, $timestamp=false, $traceFile=false)</pre>
  <pre> This method displays a debug statement followed by a newline character if the debug parameter
  is true. If no debug statement is specified it checks the SRA_Controller::DEBUG constant. If this
  is true, it displays the debug info.
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>output</td>
      <td>Not Specified</td>
      <td><pre>-	The debug output. If this is an array or object, it will be printed using print_r</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>debug</td>
      <td>Not Specified</td>
      <td><pre>- 	The debug boolean flag. if not specified, the SRA_Controller::isAppInDebug() method will be  					called to determine if debug output should be produced</pre></td>
      <td>SRA_UTIL_USE_SYS_CONFIG_DEBUG</td>
      <td>No</td>
    </tr>
    <tr>
      <td>file</td>
      <td>Not Specified</td>
      <td><pre>-	The file where the debug message originated from (optional).</pre></td>
      <td>""</td>
      <td>No</td>
    </tr>
    <tr>
      <td>line</td>
      <td>Not Specified</td>
      <td><pre>-	The line number where the debug message originated from (optional).</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>pre</td>
      <td>Not Specified</td>
      <td><pre>-	Boolean. Wrap the output in &lt;pre&gt;&lt;/pre&gt; tags for display in browser (optional).</pre></td>
      <td>false</td>
      <td>No</td>
    </tr>
    <tr>
      <td>quiet</td>
      <td>Not Specified</td>
      <td><pre>-   Whether or not the output should be quiet... meaning, only the output is displayed, followed by a newline</pre></td>
      <td>false</td>
      <td>No</td>
    </tr>
    <tr>
      <td>timestamp</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>false</td>
      <td>No</td>
    </tr>
    <tr>
      <td>traceFile</td>
      <td>Not Specified</td>
      <td><pre>- an optional file to output to</pre></td>
      <td>false</td>
      <td>No</td>
    </tr>
  </table>
  <p>author = Jason Read <jason@idir.org></p>
 <hr />  <h3 id="method_rand">rand</h3>
  <pre>public static int function <b>rand</b>(int $min, int $max)</pre>
  <pre> wrapper for the php rand function (for use in templates)
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>min</td>
      <td>int</td>
      <td><pre>t $min min value</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>max</td>
      <td>int</td>
      <td><pre>max value</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_removeDelimString">removeDelimString</h3>
  <pre>public static void function <b>removeDelimString</b>($string, $delim=", $")</pre>
  <pre> This method is used remove a delimeter string added through the addDelimString method..
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>string</td>
      <td>Not Specified</td>
      <td><pre>- The String to remove the delimeter string from</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>delim</td>
      <td>Not Specified</td>
      <td><pre>- The delimeter to replace the delimeter string with. The default is a comma.</pre></td>
      <td>"</td>
      <td>No</td>
    </tr>
    <tr>
      <td>"</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
  <p>author = Jason Read <jason@idir.org></p>
 <hr />  <h3 id="method_replaceArrayKey">replaceArrayKey</h3>
  <pre>public static String[] function &amp;<b>replaceArrayKey</b>($arr, $oldKey, $newKey, $caseSensitive=TRUE)</pre>
  <pre> This method is used replace an array key. It simply unsets the array element with the key
  identified by the oldKey parameter and adds the value at that element to a new key identified
  by the newKey parameter. If the oldKey does not exist, or the newKey does, the array will be
  returned as is.
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>arr</td>
      <td>Not Specified</td>
      <td><pre>- The array to replace the key in.</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>oldKey</td>
      <td>Not Specified</td>
      <td><pre>- The key to be replaced</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>newKey</td>
      <td>Not Specified</td>
      <td><pre>- The key to add</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>caseSensitive</td>
      <td>Not Specified</td>
      <td><pre>- Whether or not the comparison should be case sensitive</pre></td>
      <td>TRUE</td>
      <td>No</td>
    </tr>
  </table>
  <p>author = Jason Read <jason@idir.org></p>
 <hr />  <h3 id="method_sendEmail">sendEmail</h3>
  <pre>public static void function <b>sendEmail</b>(mixed $to, string $subject, string $message=NULL, string $messageHtml=NULL, string $from=NULL, string $fromName=NULL, mixed $toName=NULL, string $cc=NULL, string $bcc=NULL, mixed $attachments)</pre>
  <pre> sends an email message based on the following parameters:
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>to</td>
      <td>mixed</td>
      <td><pre>the recipient email address. if $to is an array, 1  message will be sent to each recipient. multiple messages can be sent to
  in the same message instance by separating each recipient with a comma
  (i.e. &quot;john@john.com, Jason &lt;jason@jason.com&gt;&quot;)</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>subject</td>
      <td>string</td>
      <td><pre>the email subject</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>message</td>
      <td>string</td>
      <td><pre>the text version of the email message. either  $message or $messageHtml MUST be specified. if both are specified, the
  message will be sent with both content types. otherwise, only the content
  type specified will be sent</pre></td>
      <td>NULL</td>
      <td>No</td>
    </tr>
    <tr>
      <td>messageHtml</td>
      <td>string</td>
      <td><pre>the html version of the email message</pre></td>
      <td>NULL</td>
      <td>No</td>
    </tr>
    <tr>
      <td>from</td>
      <td>string</td>
      <td><pre>the sender email address. if not specified, the  default from address will be used ([process user]@[server domain])</pre></td>
      <td>NULL</td>
      <td>No</td>
    </tr>
    <tr>
      <td>fromName</td>
      <td>string</td>
      <td><pre>the sender name (optional). can also be specified  in $from using the syntax &quot;[email] &lt;[name]&gt;&quot;</pre></td>
      <td>NULL</td>
      <td>No</td>
    </tr>
    <tr>
      <td>toName</td>
      <td>mixed</td>
      <td><pre>the recipient name (optional). if $to is an array,  and $toName is specified, it much also be an array with the same # of
  values. can also be specified in $from using the syntax
  &quot;[email] &lt;[name]&gt;&quot;</pre></td>
      <td>NULL</td>
      <td>No</td>
    </tr>
    <tr>
      <td>cc</td>
      <td>string</td>
      <td><pre>c optional comma separated list of carbon copy recipients</pre></td>
      <td>NULL</td>
      <td>No</td>
    </tr>
    <tr>
      <td>bcc</td>
      <td>string</td>
      <td><pre>optional comma separated list of blind carbon copy  recipients</pre></td>
      <td>NULL</td>
      <td>No</td>
    </tr>
    <tr>
      <td>attachments</td>
      <td>mixed</td>
      <td><pre>a single file absolute path/SRA_FileAttribute  object or array of absolute file paths/SRA_FileAttribute objects that
  should be attached to this email. the names assigned to these attachments
  will be the names of the files themselves. content type must be able to
  be determined based on the file extension (for paths - the extension must
  have a corresponding content type in /etc/mime.types)</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
  </table>
 <hr />  <h3 id="method_spellcheck">spellcheck</h3>
  <pre>public static array function <b>spellcheck</b>(string $str, string $lang=NULL, boolean $html=FALSE, array $skip=NULL)</pre>
  <pre> used to spellcheck $str. the return value is an associative array with
  the following values:
   word:        the word that was mispelled
   suggestions: an array containing correction suggestion (NULL if none)
   offsets:     character positions in $str where the mispelling occured
                (will contain 1 or more character positions if mispelled
                multiple times)
  this array will be indexed by &quot;word&quot;. if aspell is not enabled, or
  another error occurs, this method will will return NULL
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>str</td>
      <td>string</td>
      <td><pre>ing $str the string to spellcheck. alternatively, $str may be  a file path</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>lang</td>
      <td>string</td>
      <td><pre>the language code. this MUST be one of the language  codes returned by getSpellCheckLanguages. if not valid, or not specified,
  SRA_Util::getDefaultSpellCheckLanguage will be used</pre></td>
      <td>NULL</td>
      <td>No</td>
    </tr>
    <tr>
      <td>html</td>
      <td>boolean</td>
      <td><pre>whether or not to perform the spellcheck in html  mode (html tags will be ignored)</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
    <tr>
      <td>skip</td>
      <td>array</td>
      <td><pre>optional array of words to skip if misspelled</pre></td>
      <td>NULL</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_stripQuotes">stripQuotes</h3>
  <pre>public static void function <b>stripQuotes</b>($string, $quoteTokenStart='"', $quoteTokenEnd='"')</pre>
  <pre> This method is used to strip quotes (or another quote token) from a string. It returns the stripped string
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>string</td>
      <td>Not Specified</td>
      <td><pre>- The String to strip the quotes from.</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>quoteTokenStart</td>
      <td>Not Specified</td>
      <td><pre>- The start quote token to strip (by default this is a double quote)</pre></td>
      <td>'"'</td>
      <td>No</td>
    </tr>
    <tr>
      <td>quoteTokenEnd</td>
      <td>Not Specified</td>
      <td><pre>- The end quote token to strip (by default this is a double quote)</pre></td>
      <td>'"'</td>
      <td>No</td>
    </tr>
  </table>
  <p>author = Jason Read <jason@idir.org></p>
 <hr />  <h3 id="method_strToHtml">strToHtml</h3>
  <pre>public static void function <b>strToHtml</b>(string $str)</pre>
  <pre> replaces linebreaks with html &lt;br /&gt; tags and other special html
  characters to HTML entities
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>str</td>
      <td>string</td>
      <td><pre>ing $str the string to convert</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_swapValues">swapValues</h3>
  <pre>public static void function <b>swapValues</b>($currVal, $firstVal, $secondVal)</pre>
  <pre> Swaps two values
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>currVal</td>
      <td>Not Specified</td>
      <td><pre>: String - The current value (this is a reference parameter</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>firstVal</td>
      <td>Not Specified</td>
      <td><pre>: String - The first value</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>secondVal</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
  <p>author = Jason Read <jason@idir.org></p>
 <hr />  <h3 id="method_writeHttpToFile">writeHttpToFile</h3>
  <pre>public static void function <b>writeHttpToFile</b>($file, $errorMsg="")</pre>
  <pre> This method is used to write an http request to a file. To do this it extracts all of the
  related data from the GLOBAL variables $_POST, $_GET, $_COOKIE, $_SERVER, and $_ENV
  and writes them to a file containing arrays specifying these values. The optional errorMsg
  attribute may be specified to have an errorMsg array attribute added to the &#039;values&#039; array (the
  array in which all of the values are stored) along with the other globals (&#039;_POST&#039;, &#039;_GET&#039;, etc.).
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>file</td>
      <td>Not Specified</td>
      <td><pre>- 		The file where the data should be saved.</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>errorMsg</td>
      <td>Not Specified</td>
      <td><pre>- 	An optional error message that will be added to the array if specified.</pre></td>
      <td>""</td>
      <td>No</td>
    </tr>
  </table>
  <p>author = Jason Read <jason@idir.org></p>
 <hr />  <h3 id="method_validateBit">validateBit</h3>
  <pre>public static boolean function <b>validateBit</b>($bit, $fullBitMask)</pre>
  <pre> Returns true if the bit parameter specified is a single bit in the fullBitMask parameter.
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>bit</td>
      <td>Not Specified</td>
      <td><pre>: int - The bit to validate.</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>fullBitMask</td>
      <td>Not Specified</td>
      <td><pre>: int - The bitmask to validate against.</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
  <p>author = Jason Read <jason@idir.org></p>
 <hr />  <h3 id="method_validateEmail">validateEmail</h3>
  <pre>public static boolean function <b>validateEmail</b>(string $email)</pre>
  <pre> returns TRUE if an email address is properly constructed, FALSE otherwise
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>email</td>
      <td>string</td>
      <td><pre>the email address to validate</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_ipv4ToLong">ipv4ToLong</h3>
  <pre>public long function <b>ipv4ToLong</b>(string $ip)</pre>
  <pre> converts an IP address to it&#039;s corresponding numeric value
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>ip</td>
      <td>string</td>
      <td><pre>the ip address (ipv4 or ipv6) to convert</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_longToIpv4">longToIpv4</h3>
  <pre>public string function <b>longToIpv4</b>(long $num)</pre>
  <pre> converts a numeric IPv4 address to dot notation
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>num</td>
      <td>long</td>
      <td><pre>the IP number to convert</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_validateIp">validateIp</h3>
  <pre>public boolean function <b>validateIp</b>(array $validateAddresses, string $validateAddress=false)</pre>
  <pre> This method is used to validate an IP address against an array of valid IPs. If the IP
  address is valid it returns true. Otherwise it returns false.
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>validateAddresses</td>
      <td>array</td>
      <td><pre>an array of valid IP addresses. This array may contain  			wild card values for any of the ip address  sub-nets. For example, to allow all IP
  			addresses in the 192.168.1.0 network, the value in this array would be 192.168.1.*.
  			If not restriction is desired, this array should consist of a single value: &#039;*&#039;.</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>validateAddress</td>
      <td>string</td>
      <td><pre>optional parameter specifying the IP address to validate.  			If this parameter is not specified the current IP address in the globals $_SERVER
  			array will be used ($_SERVER[&#039;REMOTE_ADDR&#039;]).</pre></td>
      <td>false</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_sortObjects">sortObjects</h3>
  <pre>object[] function &amp;<b>sortObjects</b>(object[] $objects, string $getter, boolean $desc=TRUE, int $maintainKeys=TRUE)</pre>
  <pre> used to sort objects based on a given attribute
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>objects</td>
      <td>object[]</td>
      <td><pre>- the array of objects to sort. the array index  associations will be maintained by this method. alternatively, this may be
  an array of associative arrays</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>getter</td>
      <td>string</td>
      <td><pre>- the name of the getter method, object attribute or  array index to sort on</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>desc</td>
      <td>boolean</td>
      <td><pre>- whether or not to sort the objects in descending order  the default is ascending order</pre></td>
      <td>TRUE</td>
      <td>No</td>
    </tr>
    <tr>
      <td>maintainKeys</td>
      <td>int</td>
      <td><pre>whether or not to maintain the array keys or reset  them in the returned sorted array</pre></td>
      <td>TRUE</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_getCondValFromTable">getCondValFromTable</h3>
  <pre>String function <b>getCondValFromTable</b>(array[][] $table, int $condValCol, String $condVal, int $valCol)</pre>
  <pre> Used to return a value from a two dimensional table
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>table</td>
      <td>array[][]</td>
      <td><pre>- the table to evaluate</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>condValCol</td>
      <td>int</td>
      <td><pre>- the conditional value column</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>condVal</td>
      <td>String</td>
      <td><pre>- the conditional value</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>valCol</td>
      <td>int</td>
      <td><pre>- the value column</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_getFixedWidthString">getFixedWidthString</h3>
  <pre>String function <b>getFixedWidthString</b>(String $string, int $width=FALSE)</pre>
  <pre> Used to add padding to a string so that it conforms with a specified width
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>string</td>
      <td>String</td>
      <td><pre>string - the string to pad</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>width</td>
      <td>int</td>
      <td><pre>- the desired fixed width of the string</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_objectToString">objectToString</h3>
  <pre>String function &amp;<b>objectToString</b>($object)</pre>
  <pre> Converts an object instance into a string representation using the print_r
  function and output buffering (ob_start)
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>object</td>
      <td>Not Specified</td>
      <td><pre>: Object - the object to convert</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
  </table>
 <hr />  <h3 id="method_copyObject">copyObject</h3>
  <pre>Object function <b>copyObject</b>($object)</pre>
  <pre> Creates a copy of an object
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>object</td>
      <td>Not Specified</td>
      <td><pre>: Object - the object to copy</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_removeLeadingSlash">removeLeadingSlash</h3>
  <pre>string function <b>removeLeadingSlash</b>($str)</pre>
  <pre> removes a leading slash from a string
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>str</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_getNestedAttr">getNestedAttr</h3>
  <pre>mixed function <b>getNestedAttr</b>(mixed $baseObj, string $attrId)</pre>
  <pre> gets the attribute specified from the baseObj if it exists
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>baseObj</td>
      <td>mixed</td>
      <td><pre>the base object or array to start from</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>attrId</td>
      <td>string</td>
      <td><pre>the attribute identifies. this may be a combinantion  of sub-methods and array indices. methods must not require parameters.
  for example, attrId &quot;getMailingAddress-&gt;getStreet.line1&quot; would return line 1
  of the mailing address for object $baseObj assuming that getStreet returned
  some form of Address object containing a getStreet method. Additionally, if
  getMaillingAddress had returned multiple Address objects, the return value
  would be an array containing all of the line 1 strings for those addresses</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_getArray">getArray</h3>
  <pre>public static array function <b>getArray</b>(int $size, int $start=1, int $increment=1)</pre>
  <pre> simple method that returns an array of size $size
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>size</td>
      <td>int</td>
      <td><pre>the size of the array to return</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>start</td>
      <td>int</td>
      <td><pre>the starting index of the array</pre></td>
      <td>1</td>
      <td>No</td>
    </tr>
    <tr>
      <td>increment</td>
      <td>int</td>
      <td><pre>the increment</pre></td>
      <td>1</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_getArrayReverse">getArrayReverse</h3>
  <pre>public static array function <b>getArrayReverse</b>(int $size, int $start=1, int $increment=1)</pre>
  <pre> same as #getArray, but returns elements in reverse order
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>size</td>
      <td>int</td>
      <td><pre>the size of the array to return</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>start</td>
      <td>int</td>
      <td><pre>the starting index of the array</pre></td>
      <td>1</td>
      <td>No</td>
    </tr>
    <tr>
      <td>increment</td>
      <td>int</td>
      <td><pre>the increment</pre></td>
      <td>1</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_equal">equal</h3>
  <pre>public static boolean function <b>equal</b>(mixed $attr, mixed $match)</pre>
  <pre> returns TRUE if $attr and $match are equal based on the following criteria:
    1) if $attr and $match are both the same scalar type and equal, then return TRUE.
    2) if $attr and $match are both objects with equals methods, then return $attr-&gt;equals($match)
    3) if $attr or $match are objects with a &quot;getPrimaryKey&quot; method, invoke those methods and compare the results, return TRUE if equal
    4) if $attr is an array, and $match is not, then check 1-3 for each element in $attr, return TRUE if any matches are found
    5) if $attr is an array and $match is an array, then check 4 for each element of $match and return TRUE if all return TRUE
    6) if $attr and $match are both booleans (as determined by SRA_Util::isBoolean) and equal (as determined by SRA_Util::convertBoolean), then return TRUE
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>attr</td>
      <td>mixed</td>
      <td><pre>the attribute value</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>match</td>
      <td>mixed</td>
      <td><pre>the value to match</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
  </table>
 <hr />  <h3 id="method_getNewMatrix">getNewMatrix</h3>
  <pre>public static <a href="util.SRA_Matrix.html" target="contentFrame">SRA_Matrix</a> function <b>getNewMatrix</b>()</pre>
  <pre> returns a new instance of a SRA_Matrix object
 
</pre>
 <hr />  <h3 id="method_invokeMethod">invokeMethod</h3>
  <pre>public static mixed function &amp;<b>invokeMethod</b>(Object $obj, string $method, string $param1=FALSE, string $param2=FALSE, string $param3=FALSE)</pre>
  <pre> invoked a method on an object if it exists and returns the value of that
  method call. returns $obj if $obj is not an object or the $method does not
  exist
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>obj</td>
      <td>Object</td>
      <td><pre>ect $obj the object to invoke the method on</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>method</td>
      <td>string</td>
      <td><pre>the name of the method</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>param1</td>
      <td>string</td>
      <td><pre>the first parameter (optional)</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
    <tr>
      <td>param2</td>
      <td>string</td>
      <td><pre>the second parameter (optional)</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
    <tr>
      <td>param3</td>
      <td>string</td>
      <td><pre>the third parameter (optional)</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_methodExists">methodExists</h3>
  <pre>public static boolean function <b>methodExists</b>(mixed $obj, string $method)</pre>
  <pre> returns TRUE if $obj is an object and has a method $method
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>obj</td>
      <td>mixed</td>
      <td><pre>the object to check</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>method</td>
      <td>string</td>
      <td><pre>the name of the method</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_mergeObject">mergeObject</h3>
  <pre>public static void function <b>mergeObject</b>(Object $obj, Object $merge, boolean $overwrite=FALSE)</pre>
  <pre> recursively merges the attributes of 2 objects. only those attrs that exist
  in $merge and not in $obj (or are not set) will be merged unless $overwrite
  is TRUE
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>obj</td>
      <td>Object</td>
      <td><pre>ect $obj the object to merge into</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>merge</td>
      <td>Object</td>
      <td><pre>the object to merge with</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>overwrite</td>
      <td>boolean</td>
      <td><pre>whether or not to overwrite attributes in $obj  that exist in $merge</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_mergeArray">mergeArray</h3>
  <pre>public static void function <b>mergeArray</b>(array $arr1, array $arr2, boolean $overwrite=FALSE)</pre>
  <pre> recursively merges the 2 arrays. only those attrs that exist in $arr2
  and not in $arr1 (or are not set) will be merged
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>arr1</td>
      <td>array</td>
      <td><pre>the array to merge into</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>arr2</td>
      <td>array</td>
      <td><pre>the array to merge with</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>overwrite</td>
      <td>boolean</td>
      <td><pre>whether or not to overwrite elements in $obj  that exist in $merge</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_isObject">isObject</h3>
  <pre>public static void function <b>isObject</b>(Object $obj, $type=FALSE)</pre>
  <pre> used to validate an object is actually an object and optionally of a
  specific type
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>obj</td>
      <td>Object</td>
      <td><pre>ect $obj the object to validate</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>type</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_isNumericArray">isNumericArray</h3>
  <pre>public static boolean function <b>isNumericArray</b>(array $arr)</pre>
  <pre> returns true if $arr is an array with a numeric incrementing index starting
  at 0
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>arr</td>
      <td>array</td>
      <td><pre>ay $arr the array to check</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
  </table>
 <hr />  <h3 id="method_substituteParams">substituteParams</h3>
  <pre>public string function <b>substituteParams</b>(string $str, array $params)</pre>
  <pre> substitutes params in $str with their values in $params where the values
  are embedded using the format &quot;${param name}&quot;
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>str</td>
      <td>string</td>
      <td><pre>ing $str the string to parse</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>params</td>
      <td>array</td>
      <td><pre>the param values to substitute</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_getGlobal">getGlobal</h3>
  <pre>public string function &amp;<b>getGlobal</b>(string $name)</pre>
  <pre> returns the value of a global variable
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>name</td>
      <td>string</td>
      <td><pre>the name of the global variable to return</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_setGlobal">setGlobal</h3>
  <pre>public void function &amp;<b>setGlobal</b>(string $name, mixed $val)</pre>
  <pre> sets a global variable
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>name</td>
      <td>string</td>
      <td><pre>the name of the global variable to set</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>val</td>
      <td>mixed</td>
      <td><pre>the value to set (passed and set by reference)</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_cliPrompt">cliPrompt</h3>
  <pre>public string function <b>cliPrompt</b>(string $question, boolean $required=TRUE, array $options=NULL)</pre>
  <pre> prompts the user for an input value from the command line and returns that
  value
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>question</td>
      <td>string</td>
      <td><pre>the question to ask when prompting</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>required</td>
      <td>boolean</td>
      <td><pre>whether or not a response is required. if not  required and the user does not provide a value, NULL will be returned</pre></td>
      <td>TRUE</td>
      <td>No</td>
    </tr>
    <tr>
      <td>options</td>
      <td>array</td>
      <td><pre>an optional array of valid response values. if  specified, the user, will be continually asked $question until they provide
  one of these values</pre></td>
      <td>NULL</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_suCmds">suCmds</h3>
  <pre>public mixed function <b>suCmds</b>(string $user, string $pswd, mixed $cmds=NULL, hash $callbacks=NULL, boolean $skipSuIfEqual=FALSE, boolean $asynchronous=FALSE)</pre>
  <pre> uses expect (http://expect.nist.gov) to login as another user and execute
  the commands specified by $cmds. returns a hash indexed by the $cmds where
  the value is the result of executing those commands if the login was
  successful (returns TRUE if $cmds is not specified). otherwise, returns 0
  if expect is not installed, -1 for invalid user, -2 for invalid password
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>user</td>
      <td>string</td>
      <td><pre>the name of the user to login as</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>pswd</td>
      <td>string</td>
      <td><pre>the user&#039;s password</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>cmds</td>
      <td>mixed</td>
      <td><pre>the commands to execute. if not specified, TRUE will be  returned if the login is successful. alternatively, this parameter can be
  a single string command in which case the return value will be a string
  representing the results of invoking that command instead of a hash indexed
  by command</pre></td>
      <td>NULL</td>
      <td>No</td>
    </tr>
    <tr>
      <td>callbacks</td>
      <td>hash</td>
      <td><pre>an optional array of callback methods to execute on  the return values for $cmds. this value should be indexed by $cmd. when
  specified the return values will be substituted with the results of
  invoking those callback methods. each value specified can either be a
  full function call with the key ${results} which will be substituted with
  the command result value or just the function name in which case the
  function will be invoked with the command return value as the first
  parameter</pre></td>
      <td>NULL</td>
      <td>No</td>
    </tr>
    <tr>
      <td>skipSuIfEqual</td>
      <td>boolean</td>
      <td><pre>when TRUE and SRA_Util::getCurrentUser() is  the same as $user, su will not be performed</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
    <tr>
      <td>asynchronous</td>
      <td>boolean</td>
      <td><pre>when TRUE, the su and command execution will  be invoked asynchronously using a separate process and the return value
  will always be NULL (the results of the execution will be unknown)</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_passwd">passwd</h3>
  <pre>public boolean function <b>passwd</b>(string $pswd, string $curPswd=NULL, string $user=NULL, string $output)</pre>
  <pre> uses expect (http://expect.nist.gov) to change the current running user&#039;s
  password. alternatively, if the current running user is root, $user may be
  specified identifying the name of another user to change the password for.
  returns TRUE on success, FALSE otherwise
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>pswd</td>
      <td>string</td>
      <td><pre>the new password</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>curPswd</td>
      <td>string</td>
      <td><pre>the existing password. required, unless being  invoked by the root user</pre></td>
      <td>NULL</td>
      <td>No</td>
    </tr>
    <tr>
      <td>user</td>
      <td>string</td>
      <td><pre>the username to change the password for. if not  specified, the current user&#039;s password will be changed</pre></td>
      <td>NULL</td>
      <td>No</td>
    </tr>
    <tr>
      <td>output</td>
      <td>string</td>
      <td><pre>an optional reference variable that will be set with  the results of the passwd execution</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
  </table>
 <hr />  <h3 id="method_suPasswd">suPasswd</h3>
  <pre>public boolean function <b>suPasswd</b>(string $user, string $pswd, string $newPswd, boolean $root=FALSE, string $output)</pre>
  <pre> uses expect (http://expect.nist.gov) to change a system user&#039;s password.
  return TRUE on success, FALSE otherwise
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>user</td>
      <td>string</td>
      <td><pre>the name of the user to change the password for</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>pswd</td>
      <td>string</td>
      <td><pre>the user&#039;s current password (or root&#039;s password if  $root is TRUE)</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>newPswd</td>
      <td>string</td>
      <td><pre>the new password to set</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>root</td>
      <td>boolean</td>
      <td><pre>whether or not to use the root user to change the  password. when TRUE, $pswd should be the root user password and not the
  password of $user</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
    <tr>
      <td>output</td>
      <td>string</td>
      <td><pre>an optional reference variable that will be set with  the results of the passwd execution</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
  </table>
 <hr />  <h3 id="method_propertiesStringToHash">propertiesStringToHash</h3>
  <pre>hash function <b>propertiesStringToHash</b>(string $str)</pre>
  <pre> this method converts a properties string into a hash. a properties string
  is a string containing key/value pairs where each pair is separated by a
  newline character and the key/value pair is separated by a equals sign.
  for example, the string:
    test1=test 1 string
    test2=test 2 string
  would result in this method returns the hash:
    array(&#039;test1&#039; =&gt; &#039;test 1 string&#039;, &#039;test2&#039; =&gt; &#039;test 2 string&#039;)
  comments can be delimited using a preceding #
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>str</td>
      <td>string</td>
      <td><pre>ing $str the properties string to parses</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_isAlphaNumeric">isAlphaNumeric</h3>
  <pre>boolean function <b>isAlphaNumeric</b>(string $str)</pre>
  <pre> returns TRUE if $str is an alphanumeric string
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>str</td>
      <td>string</td>
      <td><pre>ing $str the string to check</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_trimLeadingZeros">trimLeadingZeros</h3>
  <pre>public string function <b>trimLeadingZeros</b>(string $str)</pre>
  <pre> trims any leading zeros from $str. if $str consists of only 0s, 0 will be
  returned
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>str</td>
      <td>string</td>
      <td><pre>ing $str the string to trim the leading zeros from</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_trimTrailingZeros">trimTrailingZeros</h3>
  <pre>public string function <b>trimTrailingZeros</b>(string $str)</pre>
  <pre> trims any trailing zeros from $str. if $str consists of only 0s, 0 will be
  returned
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>str</td>
      <td>string</td>
      <td><pre>ing $str the string to trim the leading zeros from</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_normalizeDataUnit">normalizeDataUnit</h3>
  <pre>public mixed function <b>normalizeDataUnit</b>(mixed $data, int $unit=NULL, mixed $suffix=1, int $decimals=2, boolean $base2=FALSE)</pre>
  <pre> this method is used to normalize a data unit. normalization involves first
  determining the unit size by parsing $data for a standard unit symbol or
  name and then applying the correct multiplier to convert the numeric value
  in $data to the new $unit of measure. return return value will either be
  the numeric representation of $data in $unit or the numeric value followed
  by the specified $suffix (if $suffix is specified). if $data cannot be
  parsed its numeric value will be returned. the following unit labels are
  recognized ($data can be parsed with or without spaces between the numeric
  value and the unit label) - note labels are case sensative except for the
  non abbreviated value (i.e. both &#039;bit&#039; and &#039;BIT&#039; are recognized):
    UNIT      LABELS
    bit:      b bs bS bps bpS b/s b/S bit bit/s
    byte:     B Bs BS Bps BpS B/s B/S byte byte/s
    kilobit:  Kb kb Kbs kbs KbS kbS Kbps KbpS kbps kbpS Kb/s Kb/S kb/s kb/S kilobit[s] kbit[s] kbit/s kilobit/s kilo bit[s]
    kilobyte: KB kB KBs kBs KBS kBS KBps KBpS kBps kBpS KB/s KB/S kB/s kB/S kilobyte[s] kbyte[s] kbyte/s kilobyte/s kilo byte[s]
    megabit:  Mb mb Mbs mbs MbS mbS Mbps MbpS mbps mbpS Mb/s Mb/S mb/s mb/S megabit[s] mbit[s] mbit/s megabit/s mega bit[s]
    megabyte: MB mB MBs mBs MBS mBS MBps MBpS mBps mBpS MB/s MB/S mB/s mB/S megabyte[s] mbyte[s] mbyte/s megabyte/s mega byte[s]
    gigabit:  Gb gb Gbs gbs GbS gbS Gbps GbpS gbps gbpS Gb/s Gb/S gb/s gb/S gigabit[s] gbit[s] gbit/s gigabit/s giga bit[s]
    gigabyte: GB gB GBs gBs GBS gBS GBps GBpS gBps gBpS GB/s GB/S gB/s gB/S gigabyte[s] gbyte[s] gbyte/s gigabyte/s giga byte[s]
    terabit:  Tb tb Tbs tbs TbS tbS Tbps TbpS tbps tbpS Tb/s Tb/S tb/s tb/S terabit[s] tbit[s] tbit/s terabit/s tera bit[s]
    terabyte: TB tB TBs tBs TBS tBS TBps TBpS tBps tBpS TB/s TB/S tB/s tB/S terabyte[s] tbyte[s] tbyte/s terabyte/s tera byte[s]
  NOTE: this method is not localized - it interprets and outputs only english
  strings
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>data</td>
      <td>mixed</td>
      <td><pre>the data unit size and unit size label to normalize  represents as a string (i.e. &#039;567Mb&#039;), or a hash with the following 2 keys:
  &#039;value&#039;: the value to convert, &#039;unit&#039; the current unit identifier</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>unit</td>
      <td>int</td>
      <td><pre>the identifier of the unit that $data should be converted  to. this value must correspond with one of the SRA_UTIL_DATA_UNIT_*
  constants (see the constant declarations at the top of this file). if not
  specified, the corresponding unit (bits or bytes depending on the unit
  label in $data) that will represent $data in the smallest whole number will
  be used</pre></td>
      <td>NULL</td>
      <td>No</td>
    </tr>
    <tr>
      <td>suffix</td>
      <td>mixed</td>
      <td><pre>if the return value should include the unit size  label suffix this attribute may be used to specify which label to use. the
  options are 1 for the same abbreviation in the new $unit, 2 for the default
  unit size abbreviation or 3 for the default unit size name or a custom
  suffix string. NOTE: if $suffix is 2 or 3 and the $data unit identifier
  includes the per second identifier, the new suffix will also include this
  identifier (the default labels are the first 4 labels in the
  SRA_UTIL_DATA_UNIT_*_LABELS constants)</pre></td>
      <td>1</td>
      <td>No</td>
    </tr>
    <tr>
      <td>decimals</td>
      <td>int</td>
      <td><pre>the max # of decimals to include in the normalized  value</pre></td>
      <td>2</td>
      <td>No</td>
    </tr>
    <tr>
      <td>base2</td>
      <td>boolean</td>
      <td><pre>whether or not to use base 2 or base 10 conversions  i.e. is a kilobyte 2^10 or 1024 bytes or 10^3 or 1000 bytes. the correct
  conversion is base 10 according to the International Electrotechnical
  Commission (IEC), the International Committee for Weights and Measures
  (CIPM) and the Institute of Electrical and Electronics Engineers (IEEE)
  for more information see: http://physics.nist.gov/cuu/Units/binary.html</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_normalizeMeasurement">normalizeMeasurement</h3>
  <pre>public mixed function <b>normalizeMeasurement</b>(mixed $data, int $unit=NULL, mixed $suffix=1, int $decimals=2, <a href="util.l10n.SRA_Locale.html" target="contentFrame">SRA_Locale</a> $locale=NULL)</pre>
  <pre> this method is used to normalize a measurement. normalization involves first
  determining the unit size by parsing $data for a standard unit symbol or
  name and then applying the correct multiplier to convert the numeric value
  in $data to the new $unit of measure. return return value will either be
  the numeric representation of $data in $unit or the numeric value followed
  by the specified $suffix (if $suffix is specified). if $data cannot be
  parsed its numeric value will be returned. the following unit labels are
  recognized ($data can be parsed with or without spaces between the numeric
  value and the unit label) - labels are not case sensitive. conversion cannot
  occur between classes of measurement for obvious reasons.
    UNIT        METRIC? LABELS
    LENGTH MEASUREMENTS
    Centimeter: Y       centimeter(s) cm cms
    Foot:       N       foot feet ft fts
    Inch:       N       inch(es) in ins
    Kilometer:  Y       kilometer(s) km kms
    Meter:      Y       meter(s) m ms
    Mile:       N       mile(s) mi mis
    Yard:       N       yard(s) yd yds
 
    WEIGHT MEASUREMENTS
    Gram:       Y       gram(s) gm gms
    Kilogram:   Y       kilogram(s) kg kgs
    Ounce:      N       ounce(s) oz ozs
    Pound:      N       pound(s) lb lbs
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>data</td>
      <td>mixed</td>
      <td><pre>the data unit size and unit size label to normalize  represents as a string (i.e. &#039;516 LBS&#039;), or a hash with the following 2/3 keys:
  &#039;value&#039;: the value to convert, &#039;unit&#039; the current unit identifier, and
  &#039;multiplier&#039; (optional) - a multiplier to apply to &#039;value&#039;</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>unit</td>
      <td>int</td>
      <td><pre>the identifier of the unit that $data should be converted  to. this value must correspond with one of the SRA_UTIL_MEASUREMENT_*
  constants (see the constant declarations at the top of this file). if not
  specified, the corresponding unit that will represent $data in the smallest
  whole number will be used</pre></td>
      <td>NULL</td>
      <td>No</td>
    </tr>
    <tr>
      <td>suffix</td>
      <td>mixed</td>
      <td><pre>if the return value should include the unit size  label suffix this attribute may be used to specify which label to use. the
  options are 1 for the same abbreviation in the new $unit, 2 for the unit
  abbreviation or 3 for the unit name</pre></td>
      <td>1</td>
      <td>No</td>
    </tr>
    <tr>
      <td>decimals</td>
      <td>int</td>
      <td><pre>the max # of decimals to include in the normalized  value</pre></td>
      <td>2</td>
      <td>No</td>
    </tr>
    <tr>
      <td>locale</td>
      <td>SRA_Locale</td>
      <td><pre>$locale by default if $unit is not specified, $data will  be normalized using the smallest unit of measure in the same measurement
  systems as specified in $data (i.e. 1000 meters will be converted to 1 kilometer
  NOT 0.62 miles). if you want to change this behavior, you may specify this
  locale parameter and if $locale uses metric measurements, $data will be
  normalized to the measurement system used by that locale</pre></td>
      <td>NULL</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_parsePhpSource">parsePhpSource</h3>
  <pre>public mixed function &amp;<b>parsePhpSource</b>(string $file, boolean $cache=TRUE)</pre>
  <pre> this method parses a PHP 4.x source file and utilizes javadoc formatted
  comments to construct a hash of metadata pertaining to that file. this hash
  will contain the following keys (comment values can be imbedded using the
  localizeable format &quot;[app resource bundle string]&quot;):
    constants:     array of hashes (indexed by name) with the following keys:
      comment:     the constant comment
      name:        the name of the constant
      value:       the constant value
      [other]:     other metadata (metadata value keys are prefixed with @)
    classes:       array of hashes (indexed by name) with the following keys:
      comment:     the class comment
      extends:     the name of another class extended by this class
      name:        the class name
      [other]:     other metadata (metadata value keys are prefixed with @)
      attrs:       array of hashes (indexed by name) with the following keys:
        comment:   the attribute comment
        name:      the name of the attribute
        value:     the attribute value
        [other]:   other metadata (metadata value keys are prefixed with @)
      methods:     array of hashes (indexed by name) with the following keys:
        comment:   the method comment
        name:      the name of the method
        params:    array of hashes (indexed by name) with the following keys:
          byRef:   whether or not this parameter is passed by reference
          comment: the parameter comment
          name:    the name of the parameter
          type:    the parameter data type
          value:   the default parameter value (if applicable)
        returnRef: whether or not this method returns value by reference
        [other]:   other metadata (metadata value keys are prefixed with @)
     functions:    same as &#039;methods&#039; documented above, but for non-class
                   defined functions
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>file</td>
      <td>string</td>
      <td><pre>the path to the php source file that should be parsed</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>cache</td>
      <td>boolean</td>
      <td><pre>whether or not the parse results should be cached  (cache will be updated if the source file changes)</pre></td>
      <td>TRUE</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_parseDtd">parseDtd</h3>
  <pre>mixed function <b>parseDtd</b>(string $file, boolean $cache=TRUE)</pre>
  <pre> used to parse a DTD. the return value will be a hash with the following
  values:
    comment:      any comments provided for the DTD
    entities:     a hash of DTD entities indexed by entity name with the
                  following sub-keys:
      name:       the entity name
      value:      the entity value
      comment:    the entity comment
    elements:     a hash of DTD elements indexed by element name with the
                  following sub-keys:
      name:       the element name
      comment:    the element comment
      elements:   an array of sub-elements where the value contains the
                  following sub-keys:
        name:     the sub-element name
        set:      if the sub-element is a choice of different sub-elements,
                  this sub-key will be populated instead of &#039;name&#039; which is
                  an array of the names of possible sub-elements
        required: whether or not this sub-element is required
        many:     whether or not many of these sub-elements may exist (if
                  FALSE, only 1 sub-element of this type may exist)
      mixed:      TRUE if the sub-elements are mixed (* modified) - meaning
                  this element may contain zero or more occurrences of them
      attributes: an array of attributes that this element may contain
                  indexed by attribute name where each attribute may have the
                  following sub-keys:
        name:     the attribute name
        comment:  the attribute comment
        options:  if this attribute can be one of a set of options, this
                  attribute will be an array representing those options
        type:     the attribute type, either CDATA, PCDATA, ID, IDREF,
                  &#039;options&#039; (if &#039;options&#039; is set), or an entity name
        default:  the  default value
        required: whether or not this attribute is required
      used:       an array of names of other elements where this element is
                  used (not specified for the root element)
    root:         the name of the root element
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>file</td>
      <td>string</td>
      <td><pre>the absolute path to the DTD to parse</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>cache</td>
      <td>boolean</td>
      <td><pre>whether or not the parse results should be cached  (cache will be updated if the source file changes)</pre></td>
      <td>TRUE</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_validateStaticMethodPath">validateStaticMethodPath</h3>
  <pre>public mixed function <b>validateStaticMethodPath</b>(string $path, boolean $returnFilePath=FALSE)</pre>
  <pre> used to validate a static method path which is a class path followed by two
  colons and the method name. to do so, this method includes the class file
  and verifies that the method exists in the class. returns TRUE if the path
  is valid, FALSE otherwise. Here are some examples of static method paths:
    &#039;users/User::validateEmail&#039; - looks for class in
                                    [app]/lib/users/User.php and method
                                    &#039;validateEmail&#039; in that class
  NOTE: the .php extension is not needed
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>path</td>
      <td>string</td>
      <td><pre>the static method path to validate</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>returnFilePath</td>
      <td>boolean</td>
      <td><pre>when true, the absolute path to the PHP  source file will be returned if $path is valid instead of TRUE or FALSE</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_invokeStaticMethodPath">invokeStaticMethodPath</h3>
  <pre>public mixed function &amp;<b>invokeStaticMethodPath</b>(string $path, array $params)</pre>
  <pre> invokes a static method using a static method path (see
  &#039;validateStaticMethodPath&#039; above) and returns the results of invoking that
  method. returns NULL if the method is not valid
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>path</td>
      <td>string</td>
      <td><pre>the path to static method to invoke</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>params</td>
      <td>array</td>
      <td><pre>an array of  parameters to invoke. these will be  passed into the method as arguments where the first value in the array is
  the first argument, the 2nd is the second, and so on. this parameter is
  optional</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
  </table>
 <hr />  <h3 id="method_getStaticMethodPathApi">getStaticMethodPathApi</h3>
  <pre>public hash function <b>getStaticMethodPathApi</b>(string $path)</pre>
  <pre> returns the api (if $path is properly documented) for the class and method
  defined by $path. this is a hash with the same keys as defined for methods
  in SRA_Util::parsePhpSource. returns NULL if unsuccessful
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>path</td>
      <td>string</td>
      <td><pre>the static method path to return the api for</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_ping">ping</h3>
  <pre>public boolean function <b>ping</b>(string $host)</pre>
  <pre> pings $host and returns TRUE if it is reachable, FALSE otherwise
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>host</td>
      <td>string</td>
      <td><pre>the host to ping. either a hostname or IP address</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_fork">fork</h3>
  <pre>public int function <b>fork</b>(string $cmd)</pre>
  <pre> executes a command as a new process. this command will fork off the current
  php process and thus will not stall execution. returns the PID of the
  forked command if successful
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>cmd</td>
      <td>string</td>
      <td><pre>the command to fork</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_getServiceName">getServiceName</h3>
  <pre>public string function <b>getServiceName</b>(int $port, string $proto='tcp')</pre>
  <pre> uses the /etc/services file to attempt to determine the name of the service
  for a given port
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>port</td>
      <td>int</td>
      <td><pre>the port to lookup</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>proto</td>
      <td>string</td>
      <td><pre>the protocol (tcp or udp)</pre></td>
      <td>'tcp'</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_getServicePort">getServicePort</h3>
  <pre>public int function <b>getServicePort</b>(string $service)</pre>
  <pre> uses the /etc/services file to attempt to determine the port used by
  $services
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>service</td>
      <td>string</td>
      <td><pre>the name of the service to return the port for</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_isPrivateNetworkIp">isPrivateNetworkIp</h3>
  <pre>public boolean function <b>isPrivateNetworkIp</b>(string $ip)</pre>
  <pre> returns TRUE if $ip is on a private IPv4 network (10.0.0.0-10.255.255.255
  OR 172.16.0.0-172.31.255.255 OR 192.168.0.0-192.168.255.255)
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>ip</td>
      <td>string</td>
      <td><pre>the IP address to check</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_createThumbnail">createThumbnail</h3>
  <pre>public boolean function <b>createThumbnail</b>(string $src, int $theight, int $twidth, string $thumb)</pre>
  <pre> creates a thumbnail image using the php gd image manipulation functions.
  returns TRUE on success, FALSE otherwise. the proportional dimensions of
  the image will be maintained, so the thumbnail image will have either
  height=$height OR width=$width but not both and neither height nor width in
  the thumbnail will exceed the $height and $width specified. this method
  uses ImageMagick if it is installed, php-gd otherwise
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>src</td>
      <td>string</td>
      <td><pre>the source image. should have a correct file extension:  jpg, gif or png</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>theight</td>
      <td>int</td>
      <td><pre>the maximum height. at least 1, theight or twidth must  be specified</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>twidth</td>
      <td>int</td>
      <td><pre>the maximum width. at least 1, theight or twidth must be  specified</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>thumb</td>
      <td>string</td>
      <td><pre>path to the thumbnail image that should be created. if  not specified, the new image will be named the same as $src but with a &quot;-t&quot;
  suffix (preceeding the file extension)</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_stem">stem</h3>
  <pre>string function <b>stem</b>(string $word)</pre>
  <pre> PHP implementation of the Porter Stemming Algorithm written by Iain Argent
  for Complinet Ltd., 17/2/00. Translated from the PERL version at
  http://www.muscat.com/~martin/p.txt. Version 1.1 (Includes British English
  endings). Reduces words to their base stem for search engines and indexing
  this code was borrowed from http://www.weberdev.com/get_example-1503.html
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>word</td>
      <td>string</td>
      <td><pre>the word to step</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_parseUri">parseUri</h3>
  <pre>hash function <b>parseUri</b>(string $uri)</pre>
  <pre> parses a URI and return the pieces as a hash containing the following
  possible keys (values not present in the URI will not in the hash):
    user: username
    pswd: password
    protocol: protocol (i.e. http, https, ftp) - always lowercase
    host: hostname or IP - always lowercase
    port: port
    path: url path
    params: hash of URI parameters
  this method is not case sensitive. for example, the $uri
  &quot;Https://test:mypass@test.com:32/test/script?hello=world&amp;hi=yes&quot; would result in the
  following hash being returned:
    user =&gt; test
    pswd =&gt; mypass
    protocol =&gt; https
    host =&gt; test.com
    port =&gt; 32
    path =&gt; /test/script
    params =&gt; (hash)
      hello =&gt; world
      hi =&gt; yes
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>uri</td>
      <td>string</td>
      <td><pre>ng $uri the uri to parse</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_objToHash">objToHash</h3>
  <pre>hash function <b>objToHash</b>(object $obj)</pre>
  <pre> converts an object to a hash recursively using get_object_vars
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>obj</td>
      <td>object</td>
      <td><pre>ect $obj the object to convert</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
  </table>
 <hr />  <h3 id="method_mxlookup">mxlookup</h3>
  <pre>boolean function <b>mxlookup</b>(string $domain, string $dns, int $timeout=2)</pre>
  <pre> may be used to lookup MX DNS records. the return value will be an array of
  hashes each with the following keys
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>domain</td>
      <td>string</td>
      <td><pre>the domain to lookup</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>dns</td>
      <td>string</td>
      <td><pre>the dns server to use</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>timeout</td>
      <td>int</td>
      <td><pre>the amount of time to wait for a response before  timing out</pre></td>
      <td>2</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_portInUse">portInUse</h3>
  <pre>boolean function <b>portInUse</b>(int $port, string $host='localhost', int $timeout=1)</pre>
  <pre> checks if port is already in use by attempting to make a tcp socket
  connection
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>port</td>
      <td>int</td>
      <td><pre>the port to check</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>host</td>
      <td>string</td>
      <td><pre>the host to verify the port on. if not specified,  localhost will be used</pre></td>
      <td>'localhost'</td>
      <td>No</td>
    </tr>
    <tr>
      <td>timeout</td>
      <td>int</td>
      <td><pre>the amount of time in seconds to wait for a response</pre></td>
      <td>1</td>
      <td>No</td>
    </tr>
  </table>
  
  <h2>Other Information</h2>
  <table id="other" border="1" width="100%">
  <tr>
    <th>Source File</th>
    <td>/home/jread/www/sierra/lib/util/SRA_Util.php</td>
  </tr>
  <tr>
    <th>author</th>
    <td>:  Jason Read &lt;jason@idir.org&gt;</td>
  </tr>
  </table>
  </form>
</body>
</html>