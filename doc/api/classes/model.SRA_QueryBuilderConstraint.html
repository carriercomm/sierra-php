<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>model.SRA_QueryBuilderConstraint - sierra-php v1.1.3</title>
<script type="text/javascript">
<!--
var _qsAbortNext = false;
var _tipsIdx = 0;
var _tipIds;

function clearQsTips() {
  document.getElementById('quicksearch_tips').innerHTML = '';
}
function hideQsTips() {
  setTimeout("document.getElementById('quicksearch_tips').style.display = 'none'", 100);
}
function showQsTips() {
  document.getElementById('quicksearch_tips').style.display = '';
}
function qsTipsVisible() {
  return document.getElementById('quicksearch_tips').style.display != 'none';
}
function updateQsTips(evt) {
  if (qsTipsVisible() && evt && (evt.keyCode == 40 || evt.keyCode == 38 || evt.keyCode == 13)) {
    switch(evt.keyCode) {
      // up
      case 38:
      // down
      case 40:
        if (_tipsIdx >= 0) document.getElementById(_tipIds[_tipsIdx]).style.backgroundColor = '';
        evt.keyCode == 38 ? _tipsIdx-- : _tipsIdx++;
        if (_tipsIdx > _tipIds.length) _tipsIdx = 0;
        if (_tipsIdx < 0) _tipsIdx = _tipIds.length - 1;
        if (_tipsIdx >= 0) document.getElementById(_tipIds[_tipsIdx]).style.backgroundColor = '#ddd';
        break;
      // enter
      case 13:
        if (_tipsIdx >= 0 && _tipIds[_tipsIdx]) {
          document.location.replace('#' + _tipIds[_tipsIdx].substr(3));
        }
        break;
    }
    return;
  }
  
  _tipsIdx = -1;
  _tipIds = [];
  var str = document.getElementById('quicksearch').value.toLowerCase();
  var matches = {}
  var match = false;
  
  if (str) {
  // check constants
  if ("sra_query_builder_constraint_type_equal".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_QUERY_BUILDER_CONSTRAINT_TYPE_EQUAL'] = "SRA_QUERY_BUILDER_CONSTRAINT_TYPE_EQUAL";
  }
  if ("sra_query_builder_constraint_type_greater".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_QUERY_BUILDER_CONSTRAINT_TYPE_GREATER'] = "SRA_QUERY_BUILDER_CONSTRAINT_TYPE_GREATER";
  }
  if ("sra_query_builder_constraint_type_less".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_QUERY_BUILDER_CONSTRAINT_TYPE_LESS'] = "SRA_QUERY_BUILDER_CONSTRAINT_TYPE_LESS";
  }
  if ("sra_query_builder_constraint_type_starts_with".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_QUERY_BUILDER_CONSTRAINT_TYPE_STARTS_WITH'] = "SRA_QUERY_BUILDER_CONSTRAINT_TYPE_STARTS_WITH";
  }
  if ("sra_query_builder_constraint_type_ends_with".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_QUERY_BUILDER_CONSTRAINT_TYPE_ENDS_WITH'] = "SRA_QUERY_BUILDER_CONSTRAINT_TYPE_ENDS_WITH";
  }
  if ("sra_query_builder_constraint_type_in_str".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_QUERY_BUILDER_CONSTRAINT_TYPE_IN_STR'] = "SRA_QUERY_BUILDER_CONSTRAINT_TYPE_IN_STR";
  }
  if ("sra_query_builder_constraint_type_sort_asc".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_QUERY_BUILDER_CONSTRAINT_TYPE_SORT_ASC'] = "SRA_QUERY_BUILDER_CONSTRAINT_TYPE_SORT_ASC";
  }
  if ("sra_query_builder_constraint_type_sort_desc".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_QUERY_BUILDER_CONSTRAINT_TYPE_SORT_DESC'] = "SRA_QUERY_BUILDER_CONSTRAINT_TYPE_SORT_DESC";
  }
  if ("sra_query_builder_constraint_type_not".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_QUERY_BUILDER_CONSTRAINT_TYPE_NOT'] = "SRA_QUERY_BUILDER_CONSTRAINT_TYPE_NOT";
  }
  if ("sra_query_builder_constraint_type_all".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_QUERY_BUILDER_CONSTRAINT_TYPE_ALL'] = "SRA_QUERY_BUILDER_CONSTRAINT_TYPE_ALL";
  }
  if ("sra_query_builder_constraint_null".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_QUERY_BUILDER_CONSTRAINT_NULL'] = "SRA_QUERY_BUILDER_CONSTRAINT_NULL";
  }

  // check attributes
  if ("attribute".indexOf(str) != -1) {
    match = true;
    matches['qs_attr_attribute'] = "attribute";
  }
  if ("type".indexOf(str) != -1) {
    match = true;
    matches['qs_attr_type'] = "type";
  }
  if ("value".indexOf(str) != -1) {
    match = true;
    matches['qs_attr_value'] = "value";
  }

  // check methods
  if ("sra_querybuilderconstraint".indexOf(str) != -1) {
    match = true;
    matches['qs_method_SRA_QueryBuilderConstraint'] = "SRA_QueryBuilderConstraint";
  }
  if ("issortingconstraint".indexOf(str) != -1) {
    match = true;
    matches['qs_method_isSortingConstraint'] = "isSortingConstraint";
  }
  if ("getkeys".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getKeys'] = "getKeys";
  }
  if ("getsqloperator".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getSqlOperator'] = "getSqlOperator";
  }
  if ("getsqlvalue".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getSqlValue'] = "getSqlValue";
  }
  if ("validateconstraint".indexOf(str) != -1) {
    match = true;
    matches['qs_method_validateConstraint'] = "validateConstraint";
  }
  if ("isvalid".indexOf(str) != -1) {
    match = true;
    matches['qs_method_isValid'] = "isValid";
  }

  // check classes
  if ("sra_workflow".indexOf(str) != -1) {
    match = true;
    matches['qs_class_SRA_Workflow'] = "SRA_Workflow";
  }
  if ("sra_workflowconstraint".indexOf(str) != -1) {
    match = true;
    matches['qs_class_SRA_WorkflowConstraint'] = "SRA_WorkflowConstraint";
  }
  if ("sra_workflowconstraintgroup".indexOf(str) != -1) {
    match = true;
    matches['qs_class_SRA_WorkflowConstraintGroup'] = "SRA_WorkflowConstraintGroup";
  }
  if ("sra_workflowdecision".indexOf(str) != -1) {
    match = true;
    matches['qs_class_SRA_WorkflowDecision'] = "SRA_WorkflowDecision";
  }
  if ("sra_workflowmanager".indexOf(str) != -1) {
    match = true;
    matches['qs_class_SRA_WorkflowManager'] = "SRA_WorkflowManager";
  }
  if ("sra_workflowstep".indexOf(str) != -1) {
    match = true;
    matches['qs_class_SRA_WorkflowStep'] = "SRA_WorkflowStep";
  }
  if ("sra_workflowtask".indexOf(str) != -1) {
    match = true;
    matches['qs_class_SRA_WorkflowTask'] = "SRA_WorkflowTask";
  }


  // check dtds
  if ("workflow.dtd".indexOf(str) != -1) {
    match = true;
    matches['qs_dtd_workflow.dtd'] = "workflow.dtd";
  }

  // check packages
  if ("etc".indexOf(str) != -1) {
    match = true;
    matches['qs_package_etc'] = "etc";
  }
  if ("etc.l10n".indexOf(str) != -1) {
    match = true;
    matches['qs_package_etc.l10n'] = "etc.l10n";
  }
  if ("auth".indexOf(str) != -1) {
    match = true;
    matches['qs_package_auth'] = "auth";
  }
  if ("core".indexOf(str) != -1) {
    match = true;
    matches['qs_package_core'] = "core";
  }
  if ("model".indexOf(str) != -1) {
    match = true;
    matches['qs_package_model'] = "model";
  }
  if ("sql".indexOf(str) != -1) {
    match = true;
    matches['qs_package_sql'] = "sql";
  }
  if ("test".indexOf(str) != -1) {
    match = true;
    matches['qs_package_test'] = "test";
  }
  if ("util".indexOf(str) != -1) {
    match = true;
    matches['qs_package_util'] = "util";
  }
  if ("util.installer".indexOf(str) != -1) {
    match = true;
    matches['qs_package_util.installer'] = "util.installer";
  }
  if ("util.l10n".indexOf(str) != -1) {
    match = true;
    matches['qs_package_util.l10n'] = "util.l10n";
  }
  if ("workflow".indexOf(str) != -1) {
    match = true;
    matches['qs_package_workflow'] = "workflow";
  }


  }
  
  if (match) {
    var html = '';
    for(var i in matches) {
      _tipIds.push(i);
      html += '<div id="' + i + '" style="background-color: white; cursor: pointer;" onclick="document.location.replace(\'#\' + this.id.substr(3))">' + matches[i] + '</div>\n';
    }
    document.getElementById('quicksearch_tips').innerHTML = html;
    showQsTips();
  }
  else {
    hideQsTips();
  }
}
-->
</script></head>
<body id="class" onload="document.getElementById('quicksearch').onkeyup = updateQsTips; document.getElementById('quicksearch').focus()">
  <h1 id="top">class SRA_QueryBuilderConstraint</h1>
<p>&nbsp;&nbsp;&nbsp;&nbsp;package <a href="../packages/model.html" target="contentFrame">model</a></p>  <hr />
  <form onsubmit="return false">
  
  <div style="float:right">
    <b><label for="quicksearch">Quick Search:</label></b><br />
    <input id="quicksearch" type="text" onfocus="clearQsTips()" onblur="hideQsTips()" autocomplete="off" onclick="this.select()" /><br />
    <div id="quicksearch_tips" style="border: 1px solid #333; position:absolute; display:none"></div>
  </div>
  
  <pre>class SRA_QueryBuilderConstraint</pre>
  
  <h2>Class Information</h2>
  <ul>
    <li><a href="#comments">Class Comments</a></li>
    <li><a href="#constants">Constants</a></li>
    <li><a href="#constant_details">Constant Details</a></li>
    <li><a href="#attrs">Attributes</a></li>
    <li><a href="#attr_details">Attribute Details</a></li>
    <li><a href="#methods">Methods</a></li>
    <li><a href="#method_details">Method Details</a></li>
    <li><a href="#other">Other</a></li>
  </ul>
  
  <h2 id="comments">Comment</h2>
  <pre>
 
</pre>
  
  <h2 id="constants">Class Constants</h2>
  <table border="1" width="100%">
    <tr>
      <td><pre></pre></td>
      <td>
        <pre><a href="#constant_SRA_QUERY_BUILDER_CONSTRAINT_TYPE_EQUAL">SRA_QUERY_BUILDER_CONSTRAINT_TYPE_EQUAL</a></pre>
<pre> bit defining an equality match for a value constraint
</pre>      </td>
    </tr>
    <tr>
      <td><pre></pre></td>
      <td>
        <pre><a href="#constant_SRA_QUERY_BUILDER_CONSTRAINT_TYPE_GREATER">SRA_QUERY_BUILDER_CONSTRAINT_TYPE_GREATER</a></pre>
<pre> bit defining a greater than match for a value constraint. both GREATER and
  LESS bits cannot be set
</pre>      </td>
    </tr>
    <tr>
      <td><pre></pre></td>
      <td>
        <pre><a href="#constant_SRA_QUERY_BUILDER_CONSTRAINT_TYPE_LESS">SRA_QUERY_BUILDER_CONSTRAINT_TYPE_LESS</a></pre>
<pre> bit defining a less than match for a value constraint
</pre>      </td>
    </tr>
    <tr>
      <td><pre></pre></td>
      <td>
        <pre><a href="#constant_SRA_QUERY_BUILDER_CONSTRAINT_TYPE_STARTS_WITH">SRA_QUERY_BUILDER_CONSTRAINT_TYPE_STARTS_WITH</a></pre>
<pre> bit defining a starts with than match for a value constraint. string matching
  constraints cannot also have the equality matching (&gt;&lt;=) bits set
</pre>      </td>
    </tr>
    <tr>
      <td><pre></pre></td>
      <td>
        <pre><a href="#constant_SRA_QUERY_BUILDER_CONSTRAINT_TYPE_ENDS_WITH">SRA_QUERY_BUILDER_CONSTRAINT_TYPE_ENDS_WITH</a></pre>
<pre> bit defining a ends with than match for a value constraint. string matching
  constraints cannot also have the equality matching (&gt;&lt;=) bits set
</pre>      </td>
    </tr>
    <tr>
      <td><pre></pre></td>
      <td>
        <pre><a href="#constant_SRA_QUERY_BUILDER_CONSTRAINT_TYPE_IN_STR">SRA_QUERY_BUILDER_CONSTRAINT_TYPE_IN_STR</a></pre>
<pre> bit defining an in string match for a value constraint. string matching
  constraints cannot also have the equality matching (&gt;&lt;=) bits set. has the
  safe effect as setting both SRA_QUERY_BUILDER_CONSTRAINT_TYPE_STARTS_WITH
  and SRA_QUERY_BUILDER_CONSTRAINT_TYPE_ENDS_WITH bits
</pre>      </td>
    </tr>
    <tr>
      <td><pre></pre></td>
      <td>
        <pre><a href="#constant_SRA_QUERY_BUILDER_CONSTRAINT_TYPE_SORT_ASC">SRA_QUERY_BUILDER_CONSTRAINT_TYPE_SORT_ASC</a></pre>
<pre> bit defining a sort ascending constraint. sorting constraints cannot have any
  value constraint bits
</pre>      </td>
    </tr>
    <tr>
      <td><pre></pre></td>
      <td>
        <pre><a href="#constant_SRA_QUERY_BUILDER_CONSTRAINT_TYPE_SORT_DESC">SRA_QUERY_BUILDER_CONSTRAINT_TYPE_SORT_DESC</a></pre>
<pre> bit defining a sort descending constraint. sorting constraints cannot have any
  value constraint bits
</pre>      </td>
    </tr>
    <tr>
      <td><pre></pre></td>
      <td>
        <pre><a href="#constant_SRA_QUERY_BUILDER_CONSTRAINT_TYPE_NOT">SRA_QUERY_BUILDER_CONSTRAINT_TYPE_NOT</a></pre>
<pre> bit used to negate any of the above mentioned constraints
</pre>      </td>
    </tr>
    <tr>
      <td><pre></pre></td>
      <td>
        <pre><a href="#constant_SRA_QUERY_BUILDER_CONSTRAINT_TYPE_ALL">SRA_QUERY_BUILDER_CONSTRAINT_TYPE_ALL</a></pre>
<pre> used to validate constraint types
</pre>      </td>
    </tr>
    <tr>
      <td><pre></pre></td>
      <td>
        <pre><a href="#constant_SRA_QUERY_BUILDER_CONSTRAINT_NULL">SRA_QUERY_BUILDER_CONSTRAINT_NULL</a></pre>
<pre> NULL string constant
</pre>      </td>
    </tr>
  </table>
  
  <h2 id="attrs">Class Attributes</h2>
  <table border="1" width="100%">
    <tr>
      <td><pre>string </pre></td>
      <td>
        <pre><a href="#attr_attribute">attribute</a></pre>
<pre> the name of the attribute this constraint applies to
</pre>      </td>
    </tr>
    <tr>
      <td><pre>int </pre></td>
      <td>
        <pre><a href="#attr_type">type</a></pre>
<pre> the constraint type. will be a bitmask containing one or more the of the
  SRA_QUERY_BUILDER_CONSTRAINT_TYPE_* constraint bits set
</pre>      </td>
    </tr>
    <tr>
      <td><pre>mixed </pre></td>
      <td>
        <pre><a href="#attr_value">value</a></pre>
<pre> the constraint value. NULL values can be specified using the string &quot;NULL&quot;
  (case sensitive)
</pre>      </td>
    </tr>
  </table>

  <h2 id="methods">Class Methods</h2>
  <table border="1" width="100%">
    <tr>
      <td><pre>public void</pre></td>
      <td>
        <pre><a href="#method_SRA_QueryBuilderConstraint">SRA_QueryBuilderConstraint</a>($attribute, $type, $value)</pre>
<pre> Constructor
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public boolean</pre></td>
      <td>
        <pre><a href="#method_isSortingConstraint">isSortingConstraint</a>()</pre>
<pre> returns TRUE if this is a sorting constraint
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public array</pre></td>
      <td>
        <pre><a href="#method_getKeys">getKeys</a>()</pre>
<pre> returns an array of to all of the value ids for this constraint
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public string</pre></td>
      <td>
        <pre><a href="#method_getSqlOperator">getSqlOperator</a>(int $id)</pre>
<pre> returns the SQL operator to use for this constraint. i.e. &#039;&lt;&#039;, &#039;&lt;=&#039;, &#039;like&#039;
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public string</pre></td>
      <td>
        <pre><a href="#method_getSqlValue">getSqlValue</a>(DAO $dao, int $id)</pre>
<pre> returns the sql encoded value for this constraint using the $dao provided
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public boolean</pre></td>
      <td>
        <pre><a href="#method_validateConstraint">validateConstraint</a>(string $constraint)</pre>
<pre> validates a constraint value (using the bitmask values defined above for
  constraint types)
 
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public boolean</pre></td>
      <td>
        <pre><a href="#method_isValid">isValid</a>(Object $object)</pre>
<pre> Static method that returns true if the object parameter is a SRA_QueryBuilderConstraint object.
 
</pre>      </td>
    </tr>
  </table>

  <h2 id="constant_details">Constant Details</h2>
  <a href="#top" style="float:right">Top</a>
  <h3 id="constant_SRA_QUERY_BUILDER_CONSTRAINT_TYPE_EQUAL">SRA_QUERY_BUILDER_CONSTRAINT_TYPE_EQUAL</h3>
  <pre><b>SRA_QUERY_BUILDER_CONSTRAINT_TYPE_EQUAL</b> = 1</pre>
  <pre> bit defining an equality match for a value constraint
</pre>
 <hr />  <h3 id="constant_SRA_QUERY_BUILDER_CONSTRAINT_TYPE_GREATER">SRA_QUERY_BUILDER_CONSTRAINT_TYPE_GREATER</h3>
  <pre><b>SRA_QUERY_BUILDER_CONSTRAINT_TYPE_GREATER</b> = 2</pre>
  <pre> bit defining a greater than match for a value constraint. both GREATER and
  LESS bits cannot be set
</pre>
 <hr />  <h3 id="constant_SRA_QUERY_BUILDER_CONSTRAINT_TYPE_LESS">SRA_QUERY_BUILDER_CONSTRAINT_TYPE_LESS</h3>
  <pre><b>SRA_QUERY_BUILDER_CONSTRAINT_TYPE_LESS</b> = 4</pre>
  <pre> bit defining a less than match for a value constraint
</pre>
 <hr />  <h3 id="constant_SRA_QUERY_BUILDER_CONSTRAINT_TYPE_STARTS_WITH">SRA_QUERY_BUILDER_CONSTRAINT_TYPE_STARTS_WITH</h3>
  <pre><b>SRA_QUERY_BUILDER_CONSTRAINT_TYPE_STARTS_WITH</b> = 8</pre>
  <pre> bit defining a starts with than match for a value constraint. string matching
  constraints cannot also have the equality matching (&gt;&lt;=) bits set
</pre>
 <hr />  <h3 id="constant_SRA_QUERY_BUILDER_CONSTRAINT_TYPE_ENDS_WITH">SRA_QUERY_BUILDER_CONSTRAINT_TYPE_ENDS_WITH</h3>
  <pre><b>SRA_QUERY_BUILDER_CONSTRAINT_TYPE_ENDS_WITH</b> = 16</pre>
  <pre> bit defining a ends with than match for a value constraint. string matching
  constraints cannot also have the equality matching (&gt;&lt;=) bits set
</pre>
 <hr />  <h3 id="constant_SRA_QUERY_BUILDER_CONSTRAINT_TYPE_IN_STR">SRA_QUERY_BUILDER_CONSTRAINT_TYPE_IN_STR</h3>
  <pre><b>SRA_QUERY_BUILDER_CONSTRAINT_TYPE_IN_STR</b> = 32</pre>
  <pre> bit defining an in string match for a value constraint. string matching
  constraints cannot also have the equality matching (&gt;&lt;=) bits set. has the
  safe effect as setting both SRA_QUERY_BUILDER_CONSTRAINT_TYPE_STARTS_WITH
  and SRA_QUERY_BUILDER_CONSTRAINT_TYPE_ENDS_WITH bits
</pre>
 <hr />  <h3 id="constant_SRA_QUERY_BUILDER_CONSTRAINT_TYPE_SORT_ASC">SRA_QUERY_BUILDER_CONSTRAINT_TYPE_SORT_ASC</h3>
  <pre><b>SRA_QUERY_BUILDER_CONSTRAINT_TYPE_SORT_ASC</b> = 64</pre>
  <pre> bit defining a sort ascending constraint. sorting constraints cannot have any
  value constraint bits
</pre>
 <hr />  <h3 id="constant_SRA_QUERY_BUILDER_CONSTRAINT_TYPE_SORT_DESC">SRA_QUERY_BUILDER_CONSTRAINT_TYPE_SORT_DESC</h3>
  <pre><b>SRA_QUERY_BUILDER_CONSTRAINT_TYPE_SORT_DESC</b> = 128</pre>
  <pre> bit defining a sort descending constraint. sorting constraints cannot have any
  value constraint bits
</pre>
 <hr />  <h3 id="constant_SRA_QUERY_BUILDER_CONSTRAINT_TYPE_NOT">SRA_QUERY_BUILDER_CONSTRAINT_TYPE_NOT</h3>
  <pre><b>SRA_QUERY_BUILDER_CONSTRAINT_TYPE_NOT</b> = 256</pre>
  <pre> bit used to negate any of the above mentioned constraints
</pre>
 <hr />  <h3 id="constant_SRA_QUERY_BUILDER_CONSTRAINT_TYPE_ALL">SRA_QUERY_BUILDER_CONSTRAINT_TYPE_ALL</h3>
  <pre><b>SRA_QUERY_BUILDER_CONSTRAINT_TYPE_ALL</b> = 511</pre>
  <pre> used to validate constraint types
</pre>
 <hr />  <h3 id="constant_SRA_QUERY_BUILDER_CONSTRAINT_NULL">SRA_QUERY_BUILDER_CONSTRAINT_NULL</h3>
  <pre><b>SRA_QUERY_BUILDER_CONSTRAINT_NULL</b> = 'NULL'</pre>
  <pre> NULL string constant
</pre>

  <h2 id="attr_details">Attribute Details</h2>
  <a href="#top" style="float:right">Top</a>
  <h3 id="attr_attribute">attribute</h3>
  <pre>string var <b>$attribute</b></pre>
  <pre> the name of the attribute this constraint applies to
</pre>
 <hr />  <h3 id="attr_type">type</h3>
  <pre>int var <b>$type</b></pre>
  <pre> the constraint type. will be a bitmask containing one or more the of the
  SRA_QUERY_BUILDER_CONSTRAINT_TYPE_* constraint bits set
</pre>
 <hr />  <h3 id="attr_value">value</h3>
  <pre>mixed var <b>$value</b></pre>
  <pre> the constraint value. NULL values can be specified using the string &quot;NULL&quot;
  (case sensitive)
</pre>

  <h2 id="method_details">Method Details</h2>
  <a href="#top" style="float:right">Top</a>
  <h3 id="method_SRA_QueryBuilderConstraint">SRA_QueryBuilderConstraint</h3>
  <pre>public void function <b>SRA_QueryBuilderConstraint</b>($attribute, $type, $value)</pre>
  <pre> Constructor
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>attribute</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>type</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>value</td>
      <td>Not Specified</td>
      <td><pre>No API comments</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_isSortingConstraint">isSortingConstraint</h3>
  <pre>public boolean function <b>isSortingConstraint</b>()</pre>
  <pre> returns TRUE if this is a sorting constraint
</pre>
 <hr />  <h3 id="method_getKeys">getKeys</h3>
  <pre>public array function <b>getKeys</b>()</pre>
  <pre> returns an array of to all of the value ids for this constraint
</pre>
 <hr />  <h3 id="method_getSqlOperator">getSqlOperator</h3>
  <pre>public string function <b>getSqlOperator</b>(int $id)</pre>
  <pre> returns the SQL operator to use for this constraint. i.e. &#039;&lt;&#039;, &#039;&lt;=&#039;, &#039;like&#039;
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>id</td>
      <td>int</td>
      <td><pre>the id of the value to return the constraint for (if this constraint contains multiple values)</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_getSqlValue">getSqlValue</h3>
  <pre>public string function <b>getSqlValue</b>(DAO $dao, int $id)</pre>
  <pre> returns the sql encoded value for this constraint using the $dao provided
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>dao</td>
      <td>DAO</td>
      <td><pre>the DataAccessObject to use to convert the value</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>id</td>
      <td>int</td>
      <td><pre>the id of the value to return the constraint for (if this constraint contains multiple values)</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_validateConstraint">validateConstraint</h3>
  <pre>public boolean function <b>validateConstraint</b>(string $constraint)</pre>
  <pre> validates a constraint value (using the bitmask values defined above for
  constraint types)
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>constraint</td>
      <td>string</td>
      <td><pre>the constraint to validate</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_isValid">isValid</h3>
  <pre>public boolean function <b>isValid</b>(Object $object)</pre>
  <pre> Static method that returns true if the object parameter is a SRA_QueryBuilderConstraint object.
 
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>object</td>
      <td>Object</td>
      <td><pre>$object The object to validate</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
  </table>
  
  <h2>Other Information</h2>
  <table id="other" border="1" width="100%">
  <tr>
    <th>Source File</th>
    <td>/home/jread/www/sierra/lib/model/SRA_QueryBuilderConstraint.php</td>
  </tr>
  <tr>
    <th>author</th>
    <td>Jason Read &lt;jason@idir.org&gt;</td>
  </tr>
  </table>
  </form>
</body>
</html>