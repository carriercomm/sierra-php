<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>util.l10n.SRA_AddressFormat - sierra-php v1.1.3</title>
<script type="text/javascript">
<!--
var _qsAbortNext = false;
var _tipsIdx = 0;
var _tipIds;

function clearQsTips() {
  document.getElementById('quicksearch_tips').innerHTML = '';
}
function hideQsTips() {
  setTimeout("document.getElementById('quicksearch_tips').style.display = 'none'", 100);
}
function showQsTips() {
  document.getElementById('quicksearch_tips').style.display = '';
}
function qsTipsVisible() {
  return document.getElementById('quicksearch_tips').style.display != 'none';
}
function updateQsTips(evt) {
  if (qsTipsVisible() && evt && (evt.keyCode == 40 || evt.keyCode == 38 || evt.keyCode == 13)) {
    switch(evt.keyCode) {
      // up
      case 38:
      // down
      case 40:
        if (_tipsIdx >= 0) document.getElementById(_tipIds[_tipsIdx]).style.backgroundColor = '';
        evt.keyCode == 38 ? _tipsIdx-- : _tipsIdx++;
        if (_tipsIdx > _tipIds.length) _tipsIdx = 0;
        if (_tipsIdx < 0) _tipsIdx = _tipIds.length - 1;
        if (_tipsIdx >= 0) document.getElementById(_tipIds[_tipsIdx]).style.backgroundColor = '#ddd';
        break;
      // enter
      case 13:
        if (_tipsIdx >= 0 && _tipIds[_tipsIdx]) {
          document.location.replace('#' + _tipIds[_tipsIdx].substr(3));
        }
        break;
    }
    return;
  }
  
  _tipsIdx = -1;
  _tipIds = [];
  var str = document.getElementById('quicksearch').value.toLowerCase();
  var matches = {}
  var match = false;
  
  if (str) {
  // check constants
  if ("sra_address_format_country_properties".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_ADDRESS_FORMAT_COUNTRY_PROPERTIES'] = "SRA_ADDRESS_FORMAT_COUNTRY_PROPERTIES";
  }
  if ("sra_address_format_field_properties".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_ADDRESS_FORMAT_FIELD_PROPERTIES'] = "SRA_ADDRESS_FORMAT_FIELD_PROPERTIES";
  }
  if ("sra_address_format_field_mapping_properties".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_ADDRESS_FORMAT_FIELD_MAPPING_PROPERTIES'] = "SRA_ADDRESS_FORMAT_FIELD_MAPPING_PROPERTIES";
  }
  if ("sra_address_format_max_cols".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_ADDRESS_FORMAT_MAX_COLS'] = "SRA_ADDRESS_FORMAT_MAX_COLS";
  }
  if ("sra_address_format_max_rows".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_ADDRESS_FORMAT_MAX_ROWS'] = "SRA_ADDRESS_FORMAT_MAX_ROWS";
  }
  if ("sra_address_format_xml_data_file".indexOf(str) != -1) {
    match = true;
    matches['qs_constant_SRA_ADDRESS_FORMAT_XML_DATA_FILE'] = "SRA_ADDRESS_FORMAT_XML_DATA_FILE";
  }

  // check attributes
  if ("country".indexOf(str) != -1) {
    match = true;
    matches['qs_attr_country'] = "country";
  }
  if ("countryname".indexOf(str) != -1) {
    match = true;
    matches['qs_attr_countryName'] = "countryName";
  }
  if ("fields".indexOf(str) != -1) {
    match = true;
    matches['qs_attr_fields'] = "fields";
  }
  if ("locale".indexOf(str) != -1) {
    match = true;
    matches['qs_attr_locale'] = "locale";
  }

  // check methods
  if ("sra_addressformat".indexOf(str) != -1) {
    match = true;
    matches['qs_method_SRA_AddressFormat'] = "SRA_AddressFormat";
  }
  if ("getfieldsasgrid".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getFieldsAsGrid'] = "getFieldsAsGrid";
  }
  if ("getfield".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getField'] = "getField";
  }
  if ("getlabel".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getLabel'] = "getLabel";
  }
  if ("validatefieldvalues".indexOf(str) != -1) {
    match = true;
    matches['qs_method_validateFieldValues'] = "validateFieldValues";
  }
  if ("getcountries".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getCountries'] = "getCountries";
  }
  if ("getfieldoptions".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getFieldOptions'] = "getFieldOptions";
  }
  if ("getfieldvaluesfromentity".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getFieldValuesFromEntity'] = "getFieldValuesFromEntity";
  }
  if ("getinstance".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getInstance'] = "getInstance";
  }
  if ("getinstancewithlocale".indexOf(str) != -1) {
    match = true;
    matches['qs_method_getInstanceWithLocale'] = "getInstanceWithLocale";
  }
  if ("isfieldlabel".indexOf(str) != -1) {
    match = true;
    matches['qs_method_isFieldLabel'] = "isFieldLabel";
  }
  if ("isvalid".indexOf(str) != -1) {
    match = true;
    matches['qs_method_isValid'] = "isValid";
  }
  if ("_getxmlparser".indexOf(str) != -1) {
    match = true;
    matches['qs_method__getXmlParser'] = "_getXmlParser";
  }

  // check classes
  if ("sra_workflow".indexOf(str) != -1) {
    match = true;
    matches['qs_class_SRA_Workflow'] = "SRA_Workflow";
  }
  if ("sra_workflowconstraint".indexOf(str) != -1) {
    match = true;
    matches['qs_class_SRA_WorkflowConstraint'] = "SRA_WorkflowConstraint";
  }
  if ("sra_workflowconstraintgroup".indexOf(str) != -1) {
    match = true;
    matches['qs_class_SRA_WorkflowConstraintGroup'] = "SRA_WorkflowConstraintGroup";
  }
  if ("sra_workflowdecision".indexOf(str) != -1) {
    match = true;
    matches['qs_class_SRA_WorkflowDecision'] = "SRA_WorkflowDecision";
  }
  if ("sra_workflowmanager".indexOf(str) != -1) {
    match = true;
    matches['qs_class_SRA_WorkflowManager'] = "SRA_WorkflowManager";
  }
  if ("sra_workflowstep".indexOf(str) != -1) {
    match = true;
    matches['qs_class_SRA_WorkflowStep'] = "SRA_WorkflowStep";
  }
  if ("sra_workflowtask".indexOf(str) != -1) {
    match = true;
    matches['qs_class_SRA_WorkflowTask'] = "SRA_WorkflowTask";
  }


  // check dtds
  if ("workflow.dtd".indexOf(str) != -1) {
    match = true;
    matches['qs_dtd_workflow.dtd'] = "workflow.dtd";
  }

  // check packages
  if ("etc".indexOf(str) != -1) {
    match = true;
    matches['qs_package_etc'] = "etc";
  }
  if ("etc.l10n".indexOf(str) != -1) {
    match = true;
    matches['qs_package_etc.l10n'] = "etc.l10n";
  }
  if ("auth".indexOf(str) != -1) {
    match = true;
    matches['qs_package_auth'] = "auth";
  }
  if ("core".indexOf(str) != -1) {
    match = true;
    matches['qs_package_core'] = "core";
  }
  if ("model".indexOf(str) != -1) {
    match = true;
    matches['qs_package_model'] = "model";
  }
  if ("sql".indexOf(str) != -1) {
    match = true;
    matches['qs_package_sql'] = "sql";
  }
  if ("test".indexOf(str) != -1) {
    match = true;
    matches['qs_package_test'] = "test";
  }
  if ("util".indexOf(str) != -1) {
    match = true;
    matches['qs_package_util'] = "util";
  }
  if ("util.installer".indexOf(str) != -1) {
    match = true;
    matches['qs_package_util.installer'] = "util.installer";
  }
  if ("util.l10n".indexOf(str) != -1) {
    match = true;
    matches['qs_package_util.l10n'] = "util.l10n";
  }
  if ("workflow".indexOf(str) != -1) {
    match = true;
    matches['qs_package_workflow'] = "workflow";
  }


  }
  
  if (match) {
    var html = '';
    for(var i in matches) {
      _tipIds.push(i);
      html += '<div id="' + i + '" style="background-color: white; cursor: pointer;" onclick="document.location.replace(\'#\' + this.id.substr(3))">' + matches[i] + '</div>\n';
    }
    document.getElementById('quicksearch_tips').innerHTML = html;
    showQsTips();
  }
  else {
    hideQsTips();
  }
}
-->
</script></head>
<body id="class" onload="document.getElementById('quicksearch').onkeyup = updateQsTips; document.getElementById('quicksearch').focus()">
  <h1 id="top">class SRA_AddressFormat</h1>
<p>&nbsp;&nbsp;&nbsp;&nbsp;package <a href="../packages/util.l10n.html" target="contentFrame">util.l10n</a></p>  <hr />
  <form onsubmit="return false">
  
  <div style="float:right">
    <b><label for="quicksearch">Quick Search:</label></b><br />
    <input id="quicksearch" type="text" onfocus="clearQsTips()" onblur="hideQsTips()" autocomplete="off" onclick="this.select()" /><br />
    <div id="quicksearch_tips" style="border: 1px solid #333; position:absolute; display:none"></div>
  </div>
  
  <pre>class SRA_AddressFormat</pre>
  
  <h2>Class Information</h2>
  <ul>
    <li><a href="#comments">Class Comments</a></li>
    <li><a href="#constants">Constants</a></li>
    <li><a href="#constant_details">Constant Details</a></li>
    <li><a href="#attrs">Attributes</a></li>
    <li><a href="#attr_details">Attribute Details</a></li>
    <li><a href="#methods">Methods</a></li>
    <li><a href="#method_details">Method Details</a></li>
    <li><a href="#other">Other</a></li>
  </ul>
  
  <h2 id="comments">Comment</h2>
  <pre> used to represent an country specific address format as defined in
  &#039;sierra/etc/l10n/address-formats.xml&#039;. a single address format consists of
  the attributes that make up the address, the labels to use for those
  attributes, and the layout to use to display the address. for more
  information, review the address api comments below. when imported, a default
  instance of this class will be added to the application template using the
  variable name &#039;SRA_AddressFormat&#039;
</pre>
  
  <h2 id="constants">Class Constants</h2>
  <table border="1" width="100%">
    <tr>
      <td><pre>String </pre></td>
      <td>
        <pre><a href="#constant_SRA_ADDRESS_FORMAT_COUNTRY_PROPERTIES">SRA_ADDRESS_FORMAT_COUNTRY_PROPERTIES</a></pre>
<pre> the name of the properties file containing the ISO 3166 country code/names
</pre>      </td>
    </tr>
    <tr>
      <td><pre>String </pre></td>
      <td>
        <pre><a href="#constant_SRA_ADDRESS_FORMAT_FIELD_PROPERTIES">SRA_ADDRESS_FORMAT_FIELD_PROPERTIES</a></pre>
<pre> the name of the properties file containing the address field labels
</pre>      </td>
    </tr>
    <tr>
      <td><pre>String </pre></td>
      <td>
        <pre><a href="#constant_SRA_ADDRESS_FORMAT_FIELD_MAPPING_PROPERTIES">SRA_ADDRESS_FORMAT_FIELD_MAPPING_PROPERTIES</a></pre>
<pre> the name of the properties file containing the address field mappings
</pre>      </td>
    </tr>
    <tr>
      <td><pre>int </pre></td>
      <td>
        <pre><a href="#constant_SRA_ADDRESS_FORMAT_MAX_COLS">SRA_ADDRESS_FORMAT_MAX_COLS</a></pre>
<pre> the max columns for any address format
</pre>      </td>
    </tr>
    <tr>
      <td><pre>int </pre></td>
      <td>
        <pre><a href="#constant_SRA_ADDRESS_FORMAT_MAX_ROWS">SRA_ADDRESS_FORMAT_MAX_ROWS</a></pre>
<pre> the max rows for any address format
</pre>      </td>
    </tr>
    <tr>
      <td><pre>String </pre></td>
      <td>
        <pre><a href="#constant_SRA_ADDRESS_FORMAT_XML_DATA_FILE">SRA_ADDRESS_FORMAT_XML_DATA_FILE</a></pre>
<pre> the location of the SRA_AddressFormat xml definition file
</pre>      </td>
    </tr>
  </table>
  
  <h2 id="attrs">Class Attributes</h2>
  <table border="1" width="100%">
    <tr>
      <td><pre>String </pre></td>
      <td>
        <pre><a href="#attr_country">country</a></pre>
<pre> the ISO 3166 country code that this address format pertains to
</pre>      </td>
    </tr>
    <tr>
      <td><pre>String </pre></td>
      <td>
        <pre><a href="#attr_countryName">countryName</a></pre>
<pre> the full country name for this address format as defined by the $country
  ISO 3166 country code
</pre>      </td>
    </tr>
    <tr>
      <td><pre>array </pre></td>
      <td>
        <pre><a href="#attr_fields">fields</a></pre>
<pre> an array of hashes defining the fields that constitute this address
  format. each element in this array will be a hash with the following
  keys. alternative, the field definitions can be retrieved using the
  &#039;getFieldsAsGrid&#039; method. the keys in this array will be the field ids
    id:       the field identifier
    attr:     the name of the attribute to use to store this field
    col:      the column position within &quot;row&quot; for this field
    label:    the field label
    options:  a hash of key/value pairs representing the options for this
              field
    regex:    a regular expression validation constraint for this field
    required: whether or not this field is required
    row:      the row position for this field
</pre>      </td>
    </tr>
    <tr>
      <td><pre><a href="util.l10n.SRA_Locale.html" target="contentFrame">SRA_Locale</a> </pre></td>
      <td>
        <pre><a href="#attr_locale">locale</a></pre>
<pre> the locale used to initialize this object
</pre>      </td>
    </tr>
  </table>

  <h2 id="methods">Class Methods</h2>
  <table border="1" width="100%">
    <tr>
      <td><pre>public void</pre></td>
      <td>
        <pre><a href="#method_SRA_AddressFormat">SRA_AddressFormat</a>(String $country, object $conf, <a href="util.l10n.SRA_Locale.html" target="contentFrame">SRA_Locale</a> $locale)</pre>
<pre> constructor used to instantiate a new address format instance. DO NOT
  invoke this method directly. instead, use the static singleton method
  &quot;getInstance&quot; below
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public array</pre></td>
      <td>
        <pre>&amp;<a href="#method_getFieldsAsGrid">getFieldsAsGrid</a>(boolean $skipCountry=FALSE)</pre>
<pre> returns the $fields attribute as a grid, or in other words, as a
  two-dimensional array where the first level array is the rows and the
  second level array is the columns. each element in the columns array will
  correspond to one of the $field attributes and will be positioned
  correctly according to the &#039;col&#039; and &#039;row&#039; definition for that field. the
  grid uses 1-based indexing, meaning the first row will resize at $grid[1]
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public string</pre></td>
      <td>
        <pre>&amp;<a href="#method_getField">getField</a>(string $id)</pre>
<pre> returns the field specified by $id
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public string</pre></td>
      <td>
        <pre><a href="#method_getLabel">getLabel</a>(string $id)</pre>
<pre> returns the label to use for the attribute or field id specified
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public mixed</pre></td>
      <td>
        <pre><a href="#method_validateFieldValues">validateFieldValues</a>(mixed $values)</pre>
<pre> validates field values an returns an array of errors indexed by field id
  (if any validation errors  occurred), TRUE if all fields all are valid OR
  NULL if the $values parameter is not an array or entity. the value of each
  element in the return errors array will be either &#039;required&#039; or &#039;regex&#039;
  signifying why the field value is not valid (required == field is required
  but not specified in $values, and regex == field value failed regex
  validation)
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public hash</pre></td>
      <td>
        <pre>&amp;<a href="#method_getCountries">getCountries</a>()</pre>
<pre> returns a hash of ISO 3166 identifiers/country names corresponding with the
  countries that are defined in SRA_ADDRESS_FORMAT_XML_DATA_FILE
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public array</pre></td>
      <td>
        <pre>&amp;<a href="#method_getFieldOptions">getFieldOptions</a>(array $params, int $limit=NULL, int $offset=NULL)</pre>
<pre> can be mapped as a global web service or invoked directly. will return the
  matching field options (a hash) based on the $params specified
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public array</pre></td>
      <td>
        <pre>&amp;<a href="#method_getFieldValuesFromEntity">getFieldValuesFromEntity</a>(object $entity, string $view=NULL, boolean $htmlLineBreaks=TRUE)</pre>
<pre> returns the address field values from a sierra generated entity indexed by
  field id: (country|locality|postalCode|region|street)
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public <a href="util.l10n.SRA_AddressFormat.html" target="contentFrame">SRA_AddressFormat</a></pre></td>
      <td>
        <pre><a href="#method_getInstance">getInstance</a>(String $country=NULL)</pre>
<pre> singleton method used to retrieve an instance of SRA_AddressFormat based
  on a country code. this method instantiates the address format using the
  locale provided through SRA_Controller::getUserLocale if available,
  SRA_Controller::getAppLocale otherwise
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public <a href="util.l10n.SRA_AddressFormat.html" target="contentFrame">SRA_AddressFormat</a></pre></td>
      <td>
        <pre><a href="#method_getInstanceWithLocale">getInstanceWithLocale</a>(String $country=NULL, <a href="util.l10n.SRA_Locale.html" target="contentFrame">SRA_Locale</a> $locale)</pre>
<pre> singleton method used to retrieve an instance of SRA_AddressFormat based
  on a country code AND SRA_Locale
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public boolean</pre></td>
      <td>
        <pre><a href="#method_isFieldLabel">isFieldLabel</a>(string $attr, string $value)</pre>
<pre> returns true if $value is a label for $attr
</pre>      </td>
    </tr>
    <tr>
      <td><pre>public boolean</pre></td>
      <td>
        <pre><a href="#method_isValid">isValid</a>(Object $object)</pre>
<pre> Static method that returns true if the object parameter is an
  SRA_AddressFormat object
</pre>      </td>
    </tr>
    <tr>
      <td><pre>private <a href="util.SRA_XmlParser.html" target="contentFrame">SRA_XmlParser</a></pre></td>
      <td>
        <pre>&amp;<a href="#method__getXmlParser">_getXmlParser</a>()</pre>
<pre> returns a reference to the xml parser for SRA_ADDRESS_FORMAT_XML_DATA_FILE
</pre>      </td>
    </tr>
  </table>

  <h2 id="constant_details">Constant Details</h2>
  <a href="#top" style="float:right">Top</a>
  <h3 id="constant_SRA_ADDRESS_FORMAT_COUNTRY_PROPERTIES">SRA_ADDRESS_FORMAT_COUNTRY_PROPERTIES</h3>
  <pre>String <b>SRA_ADDRESS_FORMAT_COUNTRY_PROPERTIES</b> = 'iso3166'</pre>
  <pre> the name of the properties file containing the ISO 3166 country code/names
</pre>
 <hr />  <h3 id="constant_SRA_ADDRESS_FORMAT_FIELD_PROPERTIES">SRA_ADDRESS_FORMAT_FIELD_PROPERTIES</h3>
  <pre>String <b>SRA_ADDRESS_FORMAT_FIELD_PROPERTIES</b> = 'address-fields'</pre>
  <pre> the name of the properties file containing the address field labels
</pre>
 <hr />  <h3 id="constant_SRA_ADDRESS_FORMAT_FIELD_MAPPING_PROPERTIES">SRA_ADDRESS_FORMAT_FIELD_MAPPING_PROPERTIES</h3>
  <pre>String <b>SRA_ADDRESS_FORMAT_FIELD_MAPPING_PROPERTIES</b> = 'address-field-mappings'</pre>
  <pre> the name of the properties file containing the address field mappings
</pre>
 <hr />  <h3 id="constant_SRA_ADDRESS_FORMAT_MAX_COLS">SRA_ADDRESS_FORMAT_MAX_COLS</h3>
  <pre>int <b>SRA_ADDRESS_FORMAT_MAX_COLS</b> = 3</pre>
  <pre> the max columns for any address format
</pre>
 <hr />  <h3 id="constant_SRA_ADDRESS_FORMAT_MAX_ROWS">SRA_ADDRESS_FORMAT_MAX_ROWS</h3>
  <pre>int <b>SRA_ADDRESS_FORMAT_MAX_ROWS</b> = 5</pre>
  <pre> the max rows for any address format
</pre>
 <hr />  <h3 id="constant_SRA_ADDRESS_FORMAT_XML_DATA_FILE">SRA_ADDRESS_FORMAT_XML_DATA_FILE</h3>
  <pre>String <b>SRA_ADDRESS_FORMAT_XML_DATA_FILE</b> = file_exists(SRA_CONF_DIR . '/l10n/address-formats.xml') ? SRA_CONF_DIR . '/l10n/address-formats.xml' : SRA_CONF_DIR . '/l10n/address-formats-default.xml'</pre>
  <pre> the location of the SRA_AddressFormat xml definition file
</pre>

  <h2 id="attr_details">Attribute Details</h2>
  <a href="#top" style="float:right">Top</a>
  <h3 id="attr_country">country</h3>
  <pre>String var <b>$country</b></pre>
  <pre> the ISO 3166 country code that this address format pertains to
</pre>
 <hr />  <h3 id="attr_countryName">countryName</h3>
  <pre>String var <b>$countryName</b></pre>
  <pre> the full country name for this address format as defined by the $country
  ISO 3166 country code
</pre>
 <hr />  <h3 id="attr_fields">fields</h3>
  <pre>array var <b>$fields</b> = array()</pre>
  <pre> an array of hashes defining the fields that constitute this address
  format. each element in this array will be a hash with the following
  keys. alternative, the field definitions can be retrieved using the
  &#039;getFieldsAsGrid&#039; method. the keys in this array will be the field ids
    id:       the field identifier
    attr:     the name of the attribute to use to store this field
    col:      the column position within &quot;row&quot; for this field
    label:    the field label
    options:  a hash of key/value pairs representing the options for this
              field
    regex:    a regular expression validation constraint for this field
    required: whether or not this field is required
    row:      the row position for this field
</pre>
 <hr />  <h3 id="attr_locale">locale</h3>
  <pre><a href="util.l10n.SRA_Locale.html" target="contentFrame">SRA_Locale</a> var <b>$locale</b></pre>
  <pre> the locale used to initialize this object
</pre>

  <h2 id="method_details">Method Details</h2>
  <a href="#top" style="float:right">Top</a>
  <h3 id="method_SRA_AddressFormat">SRA_AddressFormat</h3>
  <pre>public void function <b>SRA_AddressFormat</b>(String $country, object $conf, <a href="util.l10n.SRA_Locale.html" target="contentFrame">SRA_Locale</a> $locale)</pre>
  <pre> constructor used to instantiate a new address format instance. DO NOT
  invoke this method directly. instead, use the static singleton method
  &quot;getInstance&quot; below
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>country</td>
      <td>String</td>
      <td><pre>the ISO 3166 country code that this address format  pertains to</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>conf</td>
      <td>object</td>
      <td><pre>the configuration to use to initialize this address  format as defined in &#039;sierra/etc/l10n/address-formats.xml&#039;</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>locale</td>
      <td>SRA_Locale</td>
      <td><pre>$locale the locale to use in initializing this object</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
  </table>
 <hr />  <h3 id="method_getFieldsAsGrid">getFieldsAsGrid</h3>
  <pre>public array function &amp;<b>getFieldsAsGrid</b>(boolean $skipCountry=FALSE)</pre>
  <pre> returns the $fields attribute as a grid, or in other words, as a
  two-dimensional array where the first level array is the rows and the
  second level array is the columns. each element in the columns array will
  correspond to one of the $field attributes and will be positioned
  correctly according to the &#039;col&#039; and &#039;row&#039; definition for that field. the
  grid uses 1-based indexing, meaning the first row will resize at $grid[1]
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>skipCountry</td>
      <td>boolean</td>
      <td><pre>whether or not to skip the country field</pre></td>
      <td>FALSE</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_getField">getField</h3>
  <pre>public string function &amp;<b>getField</b>(string $id)</pre>
  <pre> returns the field specified by $id
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>id</td>
      <td>string</td>
      <td><pre>the field id OR name</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_getLabel">getLabel</h3>
  <pre>public string function <b>getLabel</b>(string $id)</pre>
  <pre> returns the label to use for the attribute or field id specified
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>id</td>
      <td>string</td>
      <td><pre>the id or name of the field to return the label for</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_validateFieldValues">validateFieldValues</h3>
  <pre>public mixed function <b>validateFieldValues</b>(mixed $values)</pre>
  <pre> validates field values an returns an array of errors indexed by field id
  (if any validation errors  occurred), TRUE if all fields all are valid OR
  NULL if the $values parameter is not an array or entity. the value of each
  element in the return errors array will be either &#039;required&#039; or &#039;regex&#039;
  signifying why the field value is not valid (required == field is required
  but not specified in $values, and regex == field value failed regex
  validation)
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>values</td>
      <td>mixed</td>
      <td><pre>the values to validate indexed by field id  (country|locality|postalCode|region|street) OR an entity instance
  containing those field values retrievable using the
  &#039;SRA_AddressFormat::getFieldValuesFromEntity&#039; method</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
  </table>
 <hr />  <h3 id="method_getCountries">getCountries</h3>
  <pre>public hash function &amp;<b>getCountries</b>()</pre>
  <pre> returns a hash of ISO 3166 identifiers/country names corresponding with the
  countries that are defined in SRA_ADDRESS_FORMAT_XML_DATA_FILE
</pre>
 <hr />  <h3 id="method_getFieldOptions">getFieldOptions</h3>
  <pre>public array function &amp;<b>getFieldOptions</b>(array $params, int $limit=NULL, int $offset=NULL)</pre>
  <pre> can be mapped as a global web service or invoked directly. will return the
  matching field options (a hash) based on the $params specified
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>params</td>
      <td>array</td>
      <td><pre>contains the following values:    country: the iso 3166 code for the country
    field:   the id of the field
    locale:  the id of the locale for the address format
    value:   the current value of the tips field</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>limit</td>
      <td>int</td>
      <td><pre>the request limit</pre></td>
      <td>NULL</td>
      <td>No</td>
    </tr>
    <tr>
      <td>offset</td>
      <td>int</td>
      <td><pre>the request offset</pre></td>
      <td>NULL</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_getFieldValuesFromEntity">getFieldValuesFromEntity</h3>
  <pre>public array function &amp;<b>getFieldValuesFromEntity</b>(object $entity, string $view=NULL, boolean $htmlLineBreaks=TRUE)</pre>
  <pre> returns the address field values from a sierra generated entity indexed by
  field id: (country|locality|postalCode|region|street)
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>entity</td>
      <td>object</td>
      <td><pre>the generated entity to retrieve the fields from.  this entity must contain attributes whose names correspond with the field
  mappings defined in &#039;sierra/etc/l10n/address-field-mappings.properties&#039;</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>view</td>
      <td>string</td>
      <td><pre>an optional view to check for in retrieving those  values. if specified, and the $view is valid for a field attribute, the
  output of that view will be returned instead of the raw value</pre></td>
      <td>NULL</td>
      <td>No</td>
    </tr>
    <tr>
      <td>htmlLineBreaks</td>
      <td>boolean</td>
      <td><pre>whether or not to add html line breaks to  the &#039;street&#039; attribute when it is not rendered in a view</pre></td>
      <td>TRUE</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_getInstance">getInstance</h3>
  <pre>public <a href="util.l10n.SRA_AddressFormat.html" target="contentFrame">SRA_AddressFormat</a> function <b>getInstance</b>(String $country=NULL)</pre>
  <pre> singleton method used to retrieve an instance of SRA_AddressFormat based
  on a country code. this method instantiates the address format using the
  locale provided through SRA_Controller::getUserLocale if available,
  SRA_Controller::getAppLocale otherwise
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>country</td>
      <td>String</td>
      <td><pre>the ISO 3166 country code. if not specified,  SRA_COUNTRY_DEFAULT will be used</pre></td>
      <td>NULL</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_getInstanceWithLocale">getInstanceWithLocale</h3>
  <pre>public <a href="util.l10n.SRA_AddressFormat.html" target="contentFrame">SRA_AddressFormat</a> function <b>getInstanceWithLocale</b>(String $country=NULL, <a href="util.l10n.SRA_Locale.html" target="contentFrame">SRA_Locale</a> $locale)</pre>
  <pre> singleton method used to retrieve an instance of SRA_AddressFormat based
  on a country code AND SRA_Locale
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>country</td>
      <td>String</td>
      <td><pre>the ISO 3166 country code. if not specified,  SRA_COUNTRY_DEFAULT will be used</pre></td>
      <td>NULL</td>
      <td>No</td>
    </tr>
    <tr>
      <td>locale</td>
      <td>SRA_Locale</td>
      <td><pre>$locale an explicit locale to use in instantiating the  address format object</pre></td>
      <td>None</td>
      <td>Yes</td>
    </tr>
  </table>
 <hr />  <h3 id="method_isFieldLabel">isFieldLabel</h3>
  <pre>public boolean function <b>isFieldLabel</b>(string $attr, string $value)</pre>
  <pre> returns true if $value is a label for $attr
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>attr</td>
      <td>string</td>
      <td><pre>the address attribute (country|locality|postalCode|region|street)</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
    <tr>
      <td>value</td>
      <td>string</td>
      <td><pre>the value for that attribute</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method_isValid">isValid</h3>
  <pre>public boolean function <b>isValid</b>(Object $object)</pre>
  <pre> Static method that returns true if the object parameter is an
  SRA_AddressFormat object
</pre>
  <h2>Method Parameters</h2>
  <table border="1" width="100%">
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Comment</th>
      <th>Default Value</th>
      <th>By Reference?</th>
    </tr>
    <tr>
      <td>object</td>
      <td>Object</td>
      <td><pre>$object the object to validate</pre></td>
      <td>None</td>
      <td>No</td>
    </tr>
  </table>
 <hr />  <h3 id="method__getXmlParser">_getXmlParser</h3>
  <pre>private <a href="util.SRA_XmlParser.html" target="contentFrame">SRA_XmlParser</a> function &amp;<b>_getXmlParser</b>()</pre>
  <pre> returns a reference to the xml parser for SRA_ADDRESS_FORMAT_XML_DATA_FILE
</pre>
  
  <h2>Other Information</h2>
  <table id="other" border="1" width="100%">
  <tr>
    <th>Source File</th>
    <td>/home/jread/www/sierra/lib/util/l10n/SRA_AddressFormat.php</td>
  </tr>
  <tr>
    <th>author</th>
    <td>Jason Read &lt;jason@idir.org&gt;</td>
  </tr>
  </table>
  </form>
</body>
</html>